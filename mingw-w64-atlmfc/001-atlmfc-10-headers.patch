diff --git a/include/ATLComTime.h b/include/ATLComTime.h
index 1ab3534..4a07edc 100644
--- a/include/ATLComTime.h
+++ b/include/ATLComTime.h
@@ -387,7 +387,7 @@ inline CString COleDateTime::Format(_In_ UINT nFormatID) const
 	return Format(strFormat);
 }
 
-inline COleDateTime::COleDateTime(_In_ const DBTIMESTAMP& dbts)
+inline COleDateTime::COleDateTime(_In_ const DBTIMESTAMP& dbts) throw()
 {
 	SYSTEMTIME st;
 	::ZeroMemory(&st, sizeof(SYSTEMTIME));
@@ -402,7 +402,7 @@ inline COleDateTime::COleDateTime(_In_ const DBTIMESTAMP& dbts)
 	m_status = ::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;
 }
 
-inline bool COleDateTime::GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const
+inline bool COleDateTime::GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const throw()
 {
 	UDATE ud;
 	if (S_OK != VarUdateFromDate(m_dt, 0, &ud))
diff --git a/include/afx.h b/include/afx.h
index 07c0587..47bdaab 100644
--- a/include/afx.h
+++ b/include/afx.h
@@ -67,6 +67,7 @@
 /////////////////////////////////////////////////////////////////////////////
 // Win32 libraries
 
+#ifdef _MSC_VER
 #ifndef _AFXDLL
 	#ifndef _UNICODE
 		#ifdef _DEBUG
@@ -149,6 +150,7 @@
 #endif 
 
 #endif //_MANAGED
+#endif // _MSC_VER
 /////////////////////////////////////////////////////////////////////////////
 // Classes declared in this file
 //   in addition to standard primitive data types and various helper macros
@@ -226,6 +228,7 @@ class CDumpContext;                   // object diagnostic dumping
 struct __POSITION {};
 typedef __POSITION* POSITION;
 
+#ifdef _MSC_VER
 // Standard constants
 #undef FALSE
 #undef TRUE
@@ -234,6 +237,7 @@ typedef __POSITION* POSITION;
 #define FALSE   0
 #define TRUE    1
 #define NULL    0
+#endif
 
 /////////////////////////////////////////////////////////////////////////////
 // _AFX_FUNCNAME definition
@@ -294,7 +298,9 @@ void AFXAPI AfxAssertValidObject(const CObject* pOb,
 				LPCSTR lpszFileName, int nLine);
 void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView
 
+#ifdef _MSC_VER
 #include <atltrace.h>
+#endif
 
 // extern ATL::CTrace TRACE;
 #define TRACE ATLTRACE
@@ -360,6 +366,9 @@ inline void AFX_CDECL AfxTrace(...) { }
 #define ASSERT_NULL_OR_POINTER(p, type) \
 	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))
 
+#undef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(P) (void)(P)
+
 #ifdef _DEBUG
 #define UNUSED(x)
 #else
@@ -899,10 +908,12 @@ public:
 		bufferFull
 	};
 
+#ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable:4996)
 	AFX_DEPRECATED("CArchiveException::generic clashes with future language keyword generic and should not be used. Use CArchiveException::genericException instead.") static const int __identifier(generic) = genericException;
 #pragma warning(pop)
+#endif
 
 // Constructor
 	/* explicit */ CArchiveException(int cause = CArchiveException::none,
@@ -945,10 +956,12 @@ public:
 		endOfFile
 	};
 
+#ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable:4996)
 	AFX_DEPRECATED("CFileException::generic clashes with future language keyword generic and should not be used. Use CFileException::genericException instead.") static const int __identifier(generic) = genericException;
 #pragma warning(pop)
+#endif
 
 // Constructor
 	/* explicit */ CFileException(int cause = CFileException::none, LONG lOsError = -1,
@@ -1407,7 +1420,9 @@ void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);
 void * __cdecl operator new[](size_t);
 void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine);
 void __cdecl operator delete[](void* p, LPCSTR lpszFileName, int nLine);
+#ifdef _MSC_VER
 void __cdecl operator delete[](void *);
+#endif
 
 void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
 	LPCSTR lpszFileName, int nLine);
@@ -1676,7 +1691,7 @@ protected:
 
 	// array/map for CObject* and CRuntimeClass* load/store
 	UINT m_nMapCount;
-	union
+	struct
 	{
 		CPtrArray* m_pLoadArray;
 		CMapPtrToPtr* m_pStoreMap;
diff --git a/include/afxanimationcontroller.h b/include/afxanimationcontroller.h
index 0a5fcc8..cd20e2d 100644
--- a/include/afxanimationcontroller.h
+++ b/include/afxanimationcontroller.h
@@ -269,14 +269,14 @@ protected:
 	CBaseKeyFrame* 					m_pEndKeyframe;
 
 	/// <summary>
-	/// A pointer to an animation variable, which is animated with the transition stored in m_transition.
+	/// Specifies whether a transition has been added to a storyboard.
 	/// </summary>
-	CAnimationVariable*		 		m_pRelatedVariable;
+	BOOL						m_bAdded;
 
 	/// <summary>
-	/// Specifies whether a transition has been added to a storyboard.
+	/// A pointer to an animation variable, which is animated with the transition stored in m_transition.
 	/// </summary>
-	BOOL							m_bAdded;
+	CAnimationVariable*		 		m_pRelatedVariable;
 };
 
 /// <summary>
@@ -3169,6 +3169,8 @@ class CUIAnimationPriorityComparisonHandler : public CUIAnimationPriorityCompari
 {
 	CAnimationController* m_pAnimationController;
 public:
+	typedef typename CUIAnimationPriorityComparisonBase<CUIAnimationPriorityComparisonHandler<PriorityComparisonMethod>>::CUIAnimationCallbackBase CUIAnimationCallbackBase;
+
 	/// <summary>
 	/// Creates an instance of CUIAnimationPriorityComparisonHandler callback.
 	/// </summary>
diff --git a/include/afxanimationhelper.h b/include/afxanimationhelper.h
index 2dfa631..1351fea 100644
--- a/include/afxanimationhelper.h
+++ b/include/afxanimationhelper.h
@@ -23,6 +23,10 @@
 #ifndef __UIAnimationHelper_h__
 #define __UIAnimationHelper_h__
 
+#ifndef UI_E_VALUE_NOT_SET
+#define UI_E_VALUE_NOT_SET _HRESULT_TYPEDEF_(0x802A0005L)
+#endif
+
 // Base class template for all UIAnimation callback base class templates
 template <class IUIAnimationCallback, class CUIAnimationCallbackDerived>
 class CUIAnimationCallbackBase :
@@ -49,8 +53,8 @@ public:
             return E_POINTER;
         }
         
-        CUIAnimationCallbackObject<IUIAnimationCallback, CUIAnimationCallbackDerived> *pUIAnimationCallbackDerived =
-            new CUIAnimationCallbackObject<IUIAnimationCallback, CUIAnimationCallbackDerived>;
+        CUIAnimationCallbackObject *pUIAnimationCallbackDerived =
+            new CUIAnimationCallbackObject;
         
         if (pUIAnimationCallbackDerived == NULL)
         {
@@ -89,14 +93,14 @@ protected:
         if (::InlineIsEqualGUID(riid, IID_UNKNOWN))
         {
             *ppvObject = static_cast<IUIAnimationCallback *>(this);
-            AddRef();
+            this->AddRef();
             return S_OK;
         }
         
         if (::InlineIsEqualGUID(riid, riidCallback))
         {
             *ppvObject = static_cast<IUIAnimationCallback *>(this);
-            AddRef();
+            this->AddRef();
             return S_OK;
         }
         
@@ -106,7 +110,9 @@ protected:
     
 private:
     
+#ifdef _MSC_VER
     template <class IUIAnimationCallback, class CUIAnimationCallbackDerived>
+#endif
     class CUIAnimationCallbackObject :
         public CUIAnimationCallbackDerived
     {
@@ -128,7 +134,7 @@ private:
         )
         {
             IUIAnimationCallback **ppAnimationInterface = reinterpret_cast<IUIAnimationCallback **>(ppvObject);
-            return QueryInterfaceCallback(riid, IID_PPV_ARGS(ppAnimationInterface));
+            return this->QueryInterfaceCallback(riid, IID_IUnknown, (void**)ppAnimationInterface);
         }
         
         IFACEMETHOD_(ULONG, AddRef)
@@ -144,7 +150,7 @@ private:
         {
             if (--m_dwRef == 0)
             {
-                delete this;
+                delete (IUIAnimationCallback*)this;
                 return 0;
             }
             
diff --git a/include/afxbasepane.h b/include/afxbasepane.h
index 56c6970..b7ee820 100644
--- a/include/afxbasepane.h
+++ b/include/afxbasepane.h
@@ -45,7 +45,7 @@ typedef enum AFX_DOCK_METHOD
 	DM_SHOW,
 	DM_RECT,
 	DM_STANDARD
-};
+} AFX_DOCK_METHOD;
 
 // DT - dock type
 typedef enum AFX_DOCK_TYPES
@@ -55,7 +55,7 @@ typedef enum AFX_DOCK_TYPES
 	DT_DOCK_BEFORE,
 	DT_DOCK_AFTER,
 	DT_DOCK_BY_INDEX
-};
+} AFX_DOCK_TYPES;
 
 static const DWORD AFX_CBRS_FLOAT        = 0x1;
 static const DWORD AFX_CBRS_AUTOHIDE     = 0x2;
diff --git a/include/afxbaseribbonelement.h b/include/afxbaseribbonelement.h
index 777bb96..9552927 100644
--- a/include/afxbaseribbonelement.h
+++ b/include/afxbaseribbonelement.h
@@ -22,6 +22,8 @@
 #endif
 
 class CAccessibilityData;
+class CMDIChildWndEx;
+class CMFCRibbonBar;
 class CMFCRibbonCategory;
 class CMFCRibbonPanel;
 class CMFCRibbonCmdUI;
diff --git a/include/afxbasetabctrl.h b/include/afxbasetabctrl.h
index cc0315e..da58d41 100644
--- a/include/afxbasetabctrl.h
+++ b/include/afxbasetabctrl.h
@@ -407,7 +407,7 @@ protected:
 	virtual BOOL ActivateOnBtnUp() const { return m_bActivateOnBtnUp; }
 
 protected:
-	int CMFCBaseTabCtrl::FindTabInfo(int nBarID, CMFCTabInfo** ppTabInfo);
+	int FindTabInfo(int nBarID, CMFCTabInfo** ppTabInfo);
 
 	Location   m_location; // Tabs location
 	CPtrArray  m_arTabs;   // Array of CMFCTabInfo objects
diff --git a/include/afxcmdusagecount.h b/include/afxcmdusagecount.h
index 6a9ed1f..df59d07 100644
--- a/include/afxcmdusagecount.h
+++ b/include/afxcmdusagecount.h
@@ -32,7 +32,7 @@ public:
 	UINT GetCount(UINT uiCmd) const;
 	BOOL HasEnoughInformation() const;
 
-	BOOL IsFreqeuntlyUsedCmd(UINT uiCmd) const;
+	BOOL IsFrequentlyUsedCmd(UINT uiCmd) const;
 
 	static BOOL __stdcall SetOptions(UINT nStartCount, UINT nMinUsagePercentage);
 
diff --git a/include/afxcmn.inl b/include/afxcmn.inl
index 960356c..c834f8a 100644
--- a/include/afxcmn.inl
+++ b/include/afxcmn.inl
@@ -17,7 +17,7 @@
 _AFXCMN_INLINE CDragListBox::CDragListBox()
 	{ m_nLast = -1;}
 _AFXCMN_INLINE int CDragListBox::ItemFromPt(CPoint pt, BOOL bAutoScroll) const
-	{ASSERT(::IsWindow(m_hWnd)); return ::AfxLBItemFromPt(m_hWnd, pt, bAutoScroll); }
+	{ASSERT(::IsWindow(m_hWnd)); return ::LBItemFromPt(m_hWnd, pt, bAutoScroll); }
 
 /////////////////////////////////////////////////////////////////////////////
 
@@ -325,11 +325,11 @@ _AFXCMN_INLINE BOOL CTreeCtrl::GetItem(TVITEM* pItem) const
 _AFXCMN_INLINE BOOL CTreeCtrl::SetItem(TVITEM* pItem)
 	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem); }
 _AFXCMN_INLINE BOOL CTreeCtrl::SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
-	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL); }
+	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0); }
 _AFXCMN_INLINE BOOL CTreeCtrl::SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
-	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL); }
+	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, 0); }
 _AFXCMN_INLINE BOOL CTreeCtrl::SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
-	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL); }
+	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, 0); }
 _AFXCMN_INLINE BOOL CTreeCtrl::SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
 	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData); }
 _AFXCMN_INLINE CEdit* CTreeCtrl::EditLabel(HTREEITEM hItem)
@@ -764,7 +764,7 @@ _AFXCMN_INLINE long CRichEditCtrl::StreamOut(int nFormat, EDITSTREAM &es)
 	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }
 
 _AFXCMN_INLINE long CRichEditCtrl::GetTextLength() const
-	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }
+	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0); }
 
 #endif //!_AFX_NO_RICHEDIT_SUPPORT
 /////////////////////////////////////////////////////////////////////////////
diff --git a/include/afxcmn3.inl b/include/afxcmn3.inl
index ca8adcf..6f71ff5 100644
--- a/include/afxcmn3.inl
+++ b/include/afxcmn3.inl
@@ -445,6 +445,11 @@ AFX_INLINE int CLinkCtrl::GetIdealHeight() const
 }
 
 #if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
+
+#ifndef LM_GETIDEALSIZE
+#define LM_GETIDEALSIZE    LM_GETIDEALHEIGHT
+#endif
+
 AFX_INLINE int CLinkCtrl::GetIdealSize(int cxMaxWidth, SIZE* pSize) const
 {
 	ASSERT(::IsWindow(m_hWnd));
diff --git a/include/afxcom_.h b/include/afxcom_.h
index c9f82c9..82676a6 100644
--- a/include/afxcom_.h
+++ b/include/afxcom_.h
@@ -353,7 +353,7 @@ public:
 		if (pUnknown == NULL)
 			return;
 		Interface* pInterface;
-		HRESULT hr = pUnknown->QueryInterface(GetIID(),
+		HRESULT hr = pUnknown->QueryInterface(this->GetIID(),
 			reinterpret_cast<void**>(&pInterface));
 		ASSERT(SUCCEEDED(hr));
 		Attach(pInterface);
@@ -375,7 +375,7 @@ public:
 
 	CIP& operator=(IUnknown* pUnknown)
 	{
-		HRESULT hr = QueryInterface(pUnknown);
+		HRESULT hr = this->QueryInterface(IID_IUnknown, (void**)&pUnknown);
 		ASSERT(SUCCEEDED(hr));
 		return *this;
 	}
diff --git a/include/afxcomctl32.h b/include/afxcomctl32.h
index 2955598..d7570df 100644
--- a/include/afxcomctl32.h
+++ b/include/afxcomctl32.h
@@ -73,10 +73,10 @@ void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
 		return result;
 
 #define AFX_ISOLATIONAWARE_STATICLINK_FUNC(type, name, params, args, failure_retval) \
-	inline type AfxCtx##name##params \
+	inline type AfxCtx##name/**/params \
 	{ \
 		AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
-		result=name##args; \
+		result=name/**/args; \
 		AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
 	}
 
@@ -96,10 +96,10 @@ void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
 		}		
 
 #define AFX_ISOLATIONAWARE_STATICLINK_PROC(name, params, args) \
-	inline void AfxCtx##name##params \
+	inline void AfxCtx##name/**/params \
 	{ \
 		AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
-		name##args; \
+		name/**/args; \
 		AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
 	}
 	
@@ -107,7 +107,7 @@ void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
 #define AFX_PROC_PTR_TYPE(type, name_with_postfix, params) \
 	struct name_with_postfix \
 	{ \
-		typedef type (WINAPI *Ptr)##params; \
+		typedef type (WINAPI *Ptr)/**/params; \
 		Ptr p; \
 		name_with_postfix() : p(NULL) {} \
 		void operator=(Ptr q) { p = q; } \
@@ -128,12 +128,12 @@ void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
 		return m__##name; \
 	} \
 	\
-	type _##name##params \
+	type _##name/**/params \
 	{ \
 			AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
 			GetProcAddress_##name(); \
 			ENSURE(m__##name != NULL); \
-			result=m__##name##args; \
+			result=m__##name/**/args; \
 			AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
 	}
 
@@ -149,12 +149,12 @@ void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
 		return m__##name; \
 	} \
 	\
-	void _##name##params \
+	void _##name/**/params \
 	{ \
 			AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
 			GetProcAddress_##name(); \
 			ENSURE(m__##name != NULL); \
-			m__##name##args; \
+			m__##name/**/args; \
 			AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
 	}
 
@@ -476,6 +476,13 @@ AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryW,(LPCWSTR lpLibFileName),
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExA,(LPCSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExW,(LPCWSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)
 
+#ifndef _MSC_VER
+#define MUI_LANGUAGE_ID 0x4
+#define MUI_MERGE_SYSTEM_FALLBACK 0x10
+#define MUI_MERGE_USER_FALLBACK 0x20
+#define MUI_UI_FALLBACK MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK
+#endif
+
 #ifdef _UNICODE
 #define AfxCtxLoadLibrary AfxCtxLoadLibraryW
 #define AfxCtxLoadLibraryEx AfxCtxLoadLibraryExW
diff --git a/include/afxcomctl32.inl b/include/afxcomctl32.inl
index 19fdc52..e27563e 100644
--- a/include/afxcomctl32.inl
+++ b/include/afxcomctl32.inl
@@ -21,15 +21,15 @@
 #pragma push_macro("COMCTL_AFXPROC")
 
 #define COMCTL_AFXFUNC(type, name, params, args) \
-	inline type WINAPI Afx##name##params \
+	inline type WINAPI Afx##name/**/params \
 	{ \
-		return afxComCtlWrapper->_##name##args; \
+		return afxComCtlWrapper->_##name/**/args; \
 	}
 
 #define COMCTL_AFXPROC(name, params, args) \
-	inline void WINAPI Afx##name##params \
+	inline void WINAPI Afx##name/**/params \
 	{ \
-		afxComCtlWrapper->_##name##args; \
+		afxComCtlWrapper->_##name/**/args; \
 	}
 
 /////////////////////////////////////////////////////////////////////////////
@@ -156,9 +156,9 @@ COMCTL_AFXFUNC(INT_PTR, PropertySheetW, (LPCPROPSHEETHEADERW unnamed1), (unnamed
 //////////////////// Commdlg.h /////////////////////////////////////////////////////////
 #pragma push_macro("COMMDLG_AFXCTXFUNC")
 #define COMMDLG_AFXCTXFUNC(type, name, params, args) \
-	inline type WINAPI AfxCtx##name##params \
+	inline type WINAPI AfxCtx##name/**/params \
 	{ \
-		return afxCommDlgWrapper->_##name##args; \
+		return afxCommDlgWrapper->_##name/**/args; \
 	}
 
 COMMDLG_AFXCTXFUNC(BOOL,GetOpenFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1))
@@ -193,9 +193,9 @@ COMMDLG_AFXCTXFUNC(BOOL ,PageSetupDlgW,(LPPAGESETUPDLGW unnamed1),(unnamed1))
 #pragma push_macro("SHELL_AFXCTXFUNC")
 
 #define SHELL_AFXCTXFUNC(type, name, params, args) \
-	inline type WINAPI AfxCtx##name##params \
+	inline type WINAPI AfxCtx##name/**/params \
 	{ \
-		return afxShellWrapper->_##name##args; \
+		return afxShellWrapper->_##name/**/args; \
 	}
 
 SHELL_AFXCTXFUNC(BOOL ,InitNetworkAddressControl,(void),())
diff --git a/include/afxcontextmenumanager.h b/include/afxcontextmenumanager.h
index d314c45..46c5a8a 100644
--- a/include/afxcontextmenumanager.h
+++ b/include/afxcontextmenumanager.h
@@ -21,6 +21,7 @@
 #endif
 
 class CMFCPopupMenu;
+class CMFCPopupMenuBar;
 
 class CContextMenuManager : public CObject
 {
diff --git a/include/afxcontrolbarutil.h b/include/afxcontrolbarutil.h
index b120981..77a1b11 100644
--- a/include/afxcontrolbarutil.h
+++ b/include/afxcontrolbarutil.h
@@ -120,6 +120,6 @@ typedef enum AFX_SMARTDOCK_THEME
 	AFX_SDT_DEFAULT = 0,	// Visual Manager-specific theme
 	AFX_SDT_VS2005 = 1,		// VS 2005-style
 	AFX_SDT_VS2008 = 2		// VS 2008-style
-};
+} AFX_SMARTDOCK_THEME;
 
 
diff --git a/include/afxctl.h b/include/afxctl.h
index 0edbcee..612721f 100644
--- a/include/afxctl.h
+++ b/include/afxctl.h
@@ -524,6 +524,8 @@ public:
 struct _AFXCTL_ADVISE_INFO;     // implementation class
 struct _AFXCTL_UIACTIVE_INFO;   // implementation class
 
+class CControlFrameWnd;
+
 class CControlRectTracker : public CRectTracker
 {
 // Implementation
@@ -978,7 +980,7 @@ protected:
 	DWORD m_dwVersionLoaded;            // Version number of loaded state
 	COleDispatchDriver m_ambientDispDriver; // Driver for ambient properties
 	ULONG m_cEventsFrozen;              // Event freeze count (>0 means frozen)
-	union
+	struct
 	{
 #ifdef _AFXDLL
 		CControlFrameWnd* m_pWndOpenFrame;  // Open frame window.
@@ -1040,7 +1042,7 @@ protected:
 
 	// OLE client site interfaces
 	LPOLECLIENTSITE m_pClientSite;          // Client site
-	union
+	struct
 	{
 		LPOLEINPLACESITE m_pInPlaceSite;    // In-place site
 		LPOLEINPLACESITEEX m_pInPlaceSiteEx;
@@ -1388,7 +1390,7 @@ public:
 
 // Implementation
 public:
-   virtual ~CPropExchange() = 0 { }
+	virtual ~CPropExchange() {}
 protected:
 	CPropExchange();
 	BOOL m_bLoading;
diff --git a/include/afxdb.h b/include/afxdb.h
index 4eaf7dc..411e942 100644
--- a/include/afxdb.h
+++ b/include/afxdb.h
@@ -79,9 +79,38 @@
 // Non CObject classes
 class CDBVariant;
 struct CRecordsetStatus;
-struct CFieldInfo;
-struct CODBCFieldInfo;
-struct CODBCParamInfo;
+
+// Must maintian data binding info
+struct CFieldInfo
+{
+	// MFC specific info
+	void* m_pvDataCache;
+	LONG_PTR m_nLength;
+	int m_nDataType;
+	BYTE m_bStatus;
+#ifdef _DEBUG
+	void* m_pvBindAddress;
+#endif
+};
+
+struct CODBCFieldInfo
+{
+	// meta data from ODBC
+	CString m_strName;
+	SWORD m_nSQLType;
+	SQLULEN m_nPrecision;
+	SWORD m_nScale;
+	SWORD m_nNullability;
+};
+
+struct CODBCParamInfo
+{
+	// meta data from ODBC
+	SWORD m_nSQLType;
+	UDWORD m_nPrecision;
+	SWORD m_nScale;
+	SWORD m_nNullability;
+};
 
 /////////////////////////////////////////////////////////////////////////////
 
@@ -696,7 +725,7 @@ private:
 
 		// Now can actually get the data
 		SQLLEN nActualSize = GetData(m_pDatabase, m_hstmt, nIndex,
-			nFieldType, pvData, nLen * sizeof(StringType::XCHAR),
+			nFieldType, pvData, nLen * sizeof(typename StringType::XCHAR),
  			m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);
 
 		// Handle NULL data separately
@@ -709,7 +738,7 @@ private:
 		{
 			// May need to cleanup and call SQLGetData again if necessary
 			GetLongCharDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
-				nActualSize / (sizeof(StringType::XCHAR)), &pvData, nLen, strValue,
+				nActualSize / (sizeof(typename StringType::XCHAR)), &pvData, nLen, strValue,
 				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType, nFieldType);
 		}
 	}
@@ -971,40 +1000,6 @@ struct CRecordsetStatus
 #pragma warning( push )
 #pragma warning( disable: 4121 )
 
-// Must maintian data binding info
-struct CFieldInfo
-{
-	// MFC specific info
-	void* m_pvDataCache;
-	LONG_PTR m_nLength;
-	int m_nDataType;
-	BYTE m_bStatus;
-#ifdef _DEBUG
-	void* m_pvBindAddress;
-#endif
-};
-
-#pragma warning( pop )
-
-struct CODBCFieldInfo
-{
-	// meta data from ODBC
-	CString m_strName;
-	SWORD m_nSQLType;
-	SQLULEN m_nPrecision;
-	SWORD m_nScale;
-	SWORD m_nNullability;
-};
-
-struct CODBCParamInfo
-{
-	// meta data from ODBC
-	SWORD m_nSQLType;
-	UDWORD m_nPrecision;
-	SWORD m_nScale;
-	SWORD m_nNullability;
-};
-
 
 /////////////////////////////////////////////////////////////////////////////
 // CDBVariant
@@ -1032,7 +1027,7 @@ public:
 public:
 	DWORD m_dwType;
 
-	union
+	struct
 	{
 	  BOOL              m_boolVal;
 	  unsigned char     m_chVal;
@@ -1043,8 +1038,8 @@ public:
 	  TIMESTAMP_STRUCT* m_pdate;
 	  CString*          m_pstring;
 	  CLongBinary*      m_pbinary;
-	  CStringA*			m_pstringA;
-	  CStringW*			m_pstringW;
+	  CStringA*         m_pstringA;
+	  CStringW*         m_pstringW;
 	};
 
 // Operations
diff --git a/include/afxdlgs.h b/include/afxdlgs.h
index 30d41bc..169808b 100644
--- a/include/afxdlgs.h
+++ b/include/afxdlgs.h
@@ -113,7 +113,7 @@ public:
 
 // Implementation
 public:
-    virtual ~CCommonDialog() {};
+	virtual ~CCommonDialog() {}
 
 protected:
 	virtual void OnOK();
@@ -135,7 +135,11 @@ class CFileDialog : public CCommonDialog
 
 public:
 // Attributes
+#ifdef _MSC_VER
 	__declspec(property(get=GetOFN)) OPENFILENAME m_ofn;
+#else
+	OPENFILENAME m_ofn;
+#endif
 	const OPENFILENAME& GetOFN() const;
 	OPENFILENAME& GetOFN();
 	LPOPENFILENAME m_pOFN;
@@ -940,7 +944,11 @@ public:
 		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0);
 
 // Attributes
+#ifdef _MSC_VER
 	__declspec(property(get=GetPSP)) PROPSHEETPAGE m_psp;
+#else
+	PROPSHEETPAGE m_psp;
+#endif
 	const PROPSHEETPAGE & GetPSP() const;
 	PROPSHEETPAGE & GetPSP();
 	LPPROPSHEETPAGE m_pPSP;
diff --git a/include/afxdockablepane.h b/include/afxdockablepane.h
index a8a348f..16e1a5e 100644
--- a/include/afxdockablepane.h
+++ b/include/afxdockablepane.h
@@ -157,7 +157,7 @@ public:
 	virtual void UnSetAutoHideMode (CDockablePane* pFirstBarInGroup);
 	BOOL ReplacePane(CDockablePane* pBarToReplaceWith, AFX_DOCK_METHOD dockMethod, BOOL bRegisterWithFrame = FALSE);
 
-	void RemoveFromDefaultPaneDividier();
+	void RemoveFromDefaultPaneDivider();
 
 	virtual void ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate/* = TRUE*/);
 	virtual BOOL DockToRecentPos() { return Dock(NULL, NULL, DM_SHOW); }
diff --git a/include/afxglobals.h b/include/afxglobals.h
index 0224c1f..8f6baf9 100644
--- a/include/afxglobals.h
+++ b/include/afxglobals.h
@@ -42,7 +42,7 @@ typedef enum AFX_DOCK_TYPE
 	DT_IMMEDIATE = 1,    // control bar torn off immediately and follows the mouse
 	DT_STANDARD  = 2,    // user drags a frame
 	DT_SMART     = 0x80  // smart docking style
-};
+} AFX_DOCK_TYPE;
 
 // autohide sliding modes
 static const UINT AFX_AHSM_MOVE    = 1;
diff --git a/include/afxhtml.h b/include/afxhtml.h
index d4352ba..df395cf 100644
--- a/include/afxhtml.h
+++ b/include/afxhtml.h
@@ -541,7 +541,7 @@ public:
 		pT->GetDHtmlDocument(&spDoc);
 		if (spDoc)
 		{
-			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
+			CComQIPtr<IOleCommandTarget, &IID_IOleCommandTarget> spCmdTarg = *&spDoc;
 			if (spCmdTarg)
 			{
 				hr = spCmdTarg->Exec(pGuid, cmdID, cmdExecOpt, pInVar , pOutVar);
@@ -564,10 +564,10 @@ public:
 		pT->GetDHtmlDocument(&spDoc);
 		if (spDoc)
 		{
-			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
+			CComQIPtr<IOleCommandTarget, &IID_IOleCommandTarget> spCmdTarg = *&spDoc;
 			if (spCmdTarg)
 			{
-				OLECMD ocmd = {cmdID, 0};
+				OLECMD ocmd = {(ULONG)cmdID, 0};
 				if (S_OK == spCmdTarg->QueryStatus(&CGID_MSHTML, 1, &ocmd, NULL))
 					return ocmd.cmdf;
 			}
@@ -624,7 +624,7 @@ public:
 		HRESULT hr = E_FAIL;
 		const T* pT = static_cast<const T*>(this);
 		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
-		CComQIPtr<IPersistStreamInit> spPSI;
+		CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI;
 		CStreamOnCString stream;
 
 		pT->GetDHtmlDocument(&spHTMLDocument);
@@ -644,7 +644,7 @@ public:
 		HRESULT hr = E_NOINTERFACE;
 		const T* pT = static_cast<const T*>(this);
 		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
-		CComQIPtr<IPersistStreamInit> spPSI;
+		CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI;
 		CStreamOnCString stream;
 
 		pT->GetDHtmlDocument(&spHTMLDocument);
@@ -670,7 +670,7 @@ public:
 		const T* pT = static_cast<const T*>(this);
 		CStreamOnCString stream(szHTML);
 		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
-		CComQIPtr<IPersistStreamInit> spPSI;
+		CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI;
 
 		pT->GetDHtmlDocument(&spHTMLDocument);
 		if (spHTMLDocument)
@@ -687,7 +687,7 @@ public:
 		HRESULT hr = E_NOINTERFACE;
 		const T* pT = static_cast<const T*>(this);
 		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
-		CComQIPtr<IPersistStreamInit> spPSI;
+		CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI;
 
 		pT->GetDHtmlDocument(&spHTMLDocument);
 		if (spHTMLDocument)
diff --git a/include/afxinet.h b/include/afxinet.h
index 921f539..7d4a6a6 100644
--- a/include/afxinet.h
+++ b/include/afxinet.h
@@ -514,7 +514,7 @@ public:
 	CGopherLocator CreateLocator(LPCTSTR pstrDisplayString,
 		LPCTSTR pstrSelectorString, DWORD dwGopherType);
 
-	BOOL CGopherConnection::GetAttribute(CGopherLocator& refLocator,
+	BOOL GetAttribute(CGopherLocator& refLocator,
 		CString strRequestedAttributes, CString& strResult);
 
 	static CGopherLocator CreateLocator(LPCTSTR pstrLocator);
diff --git a/include/afxmdichildwndex.h b/include/afxmdichildwndex.h
index 30735c9..06eaec0 100644
--- a/include/afxmdichildwndex.h
+++ b/include/afxmdichildwndex.h
@@ -23,6 +23,7 @@
 
 class CMDIFrameWndEx;
 class CMDIChildWndEx;
+class CMFCTabCtrl;
 
 class CMDITabProxyWnd : public CWnd
 {
diff --git a/include/afxmdiclientareawnd.h b/include/afxmdiclientareawnd.h
index 7be5e43..b1715f9 100644
--- a/include/afxmdiclientareawnd.h
+++ b/include/afxmdiclientareawnd.h
@@ -21,6 +21,7 @@
 #pragma component(minrebuild, off)
 #endif
 
+class CMDIChildWndEx;
 class CMDIFrameWndEx;
 
 extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVETOTABGROUP;
diff --git a/include/afxocc.h b/include/afxocc.h
index 6e74138..dccec6f 100644
--- a/include/afxocc.h
+++ b/include/afxocc.h
@@ -317,7 +317,7 @@ public:
 	DWORD m_dwNotifyDBEvents; // INotifyDBEvents sink cookie
 	CDataSourceControl* m_pDataSourceControl;
 	CDataBoundProperty* m_pBindings;
-	union {
+	struct {
 		COleControlSite *m_pDSCSite;
 		WORD m_ctlidRowSource;
 	};
diff --git a/include/afxodlgs.h b/include/afxodlgs.h
index aeb5e90..b6de325 100644
--- a/include/afxodlgs.h
+++ b/include/afxodlgs.h
@@ -117,7 +117,7 @@ public:
 public:
 	int MapResult(UINT nResult);
 	explicit COleDialog(CWnd* pParentWnd);
-	virtual ~COleDialog() = 0 { }
+	virtual ~COleDialog() {}
 #ifdef _DEBUG
 	virtual void Dump(CDumpContext& dc) const;
 #endif
diff --git a/include/afxole.h b/include/afxole.h
index 3e61e14..8d64096 100644
--- a/include/afxole.h
+++ b/include/afxole.h
@@ -1494,7 +1494,7 @@ class COleStreamFile : public CFile
 {
 	DECLARE_DYNAMIC(COleStreamFile)
 
-private:
+protected:
    using CFile::Open;
 
 // Constructors and Destructors
@@ -1561,7 +1561,7 @@ class CMonikerFile: public COleStreamFile
 {
 	DECLARE_DYNAMIC(CMonikerFile)
 
-private:
+protected:
    using COleStreamFile::Open;
 
 public:
@@ -1640,7 +1640,7 @@ class CAsyncMonikerFile: public CMonikerFile
 {
 	DECLARE_DYNAMIC(CAsyncMonikerFile)
 
-private:
+protected:
    using CMonikerFile::Open;
 
 public:
diff --git a/include/afxoledb.h b/include/afxoledb.h
index a2ef09a..7cd7a93 100644
--- a/include/afxoledb.h
+++ b/include/afxoledb.h
@@ -118,5 +118,5 @@ protected:
 #pragma component(minrebuild, on)
 #endif
 
-#endif __AFXOLEDB_H__
+#endif // __AFXOLEDB_H__
 
diff --git a/include/afxoutlookbar.h b/include/afxoutlookbar.h
index e70d2c9..d8cdcbb 100644
--- a/include/afxoutlookbar.h
+++ b/include/afxoutlookbar.h
@@ -22,6 +22,7 @@
 #endif
 
 class CMFCOutlookBarPane;
+class CMFCOutlookBarTabCtrl;
 
 /////////////////////////////////////////////////////////////////////////////
 // CMFCOutlookBar window
diff --git a/include/afxpane.h b/include/afxpane.h
index 48c7fe5..7711c09 100644
--- a/include/afxpane.h
+++ b/include/afxpane.h
@@ -42,7 +42,7 @@ typedef enum AFX_CS_STATUS
 	CS_DOCK_IMMEDIATELY,
 	CS_DELAY_DOCK,
 	CS_DELAY_DOCK_TO_TAB
-};
+} AFX_CS_STATUS;
 
 
 static const DWORD AFX_DEFAULT_PANE_STYLE = AFX_CBRS_FLOAT | AFX_CBRS_CLOSE;
diff --git a/include/afxpanecontainer.h b/include/afxpanecontainer.h
index 63a13d5..6cde47c 100644
--- a/include/afxpanecontainer.h
+++ b/include/afxpanecontainer.h
@@ -24,6 +24,7 @@ class CBasePane;
 class CPane;
 class CDockablePane;
 class CPaneDivider;
+class CPaneContainerManager;
 
 class CPaneContainer : public CObject  
 {
diff --git a/include/afxpaneframewnd.h b/include/afxpaneframewnd.h
index 1bd8540..1c5cb01 100644
--- a/include/afxpaneframewnd.h
+++ b/include/afxpaneframewnd.h
@@ -44,7 +44,7 @@ typedef enum AFX_PREDOCK_STATE
 	PDS_NOTHING,
 	PDS_DOCK_REGULAR,
 	PDS_DOCK_TO_TAB
-};
+} AFX_PREDOCK_STATE;
 
 static const UINT AFX_DOCK_EVENT = 4;
 static const UINT AFX_CHECK_ROLL_STATE = 5;
@@ -333,7 +333,7 @@ protected:
 	AFX_PREDOCK_STATE m_preDockStateCurr;
 
 	AFX_IMPORT_DATA static CMap<UINT,UINT,HWND,HWND> m_mapFloatingBars;
-	AFX_IMPORT_DATA static CList<HWND, HWND> CPaneFrameWnd::m_lstFrames;
+	AFX_IMPORT_DATA static CList<HWND, HWND> m_lstFrames;
 	AFX_IMPORT_DATA static CFrameWnd* m_pParentWndForSerialize; // should be set by caller before starting serialization
 };
 
diff --git a/include/afxpropertysheet.h b/include/afxpropertysheet.h
index 24e7f2f..bfcbae1 100644
--- a/include/afxpropertysheet.h
+++ b/include/afxpropertysheet.h
@@ -51,11 +51,11 @@ class CMFCPropertySheetTabCtrl : public CMFCTabCtrl
 	CMFCPropertySheet* m_pParent;
 };
 
-class CMFCProperySheetListBox : public CListBox
+class CMFCPropertySheetListBox : public CListBox
 {
 	friend class CMFCPropertySheet;
 
-	CMFCProperySheetListBox();
+	CMFCPropertySheetListBox();
 
 	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
 	afx_msg void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
@@ -128,7 +128,7 @@ protected:
 	PropSheetLook  m_look;
 	CMFCOutlookBarPaneList m_wndPane1;
 	CMFCPropertySheetTabCtrl  m_wndTab;
-	CMFCProperySheetListBox m_wndList;
+	CMFCPropertySheetListBox m_wndList;
 	CMFCOutlookBar    m_wndOutlookBar;
 	CTreeCtrl      m_wndTree;
 	CImageList     m_Icons;
diff --git a/include/afxrendertarget.h b/include/afxrendertarget.h
index b4908b3..720c604 100644
--- a/include/afxrendertarget.h
+++ b/include/afxrendertarget.h
@@ -14,6 +14,7 @@
 #include <dwrite.h>
 
 class CBitmapRenderTarget;
+class CRenderTarget;
 
 #ifdef _AFX_PACKING
 #pragma pack(push, _AFX_PACKING)
diff --git a/include/afxribbonpanel.h b/include/afxribbonpanel.h
index a67fef4..6a087b5 100644
--- a/include/afxribbonpanel.h
+++ b/include/afxribbonpanel.h
@@ -27,6 +27,7 @@ class CMFCRibbonCategory;
 class CMFCRibbonBaseElement;
 class CMFCRibbonPanel;
 class CMFCRibbonGallery;
+class CMFCRibbonPanelMenu;
 
 #ifdef ENABLE_RIBBON_LAUNCH_BUTTON
 
diff --git a/include/afxrich.h b/include/afxrich.h
index cac34bf..4200a81 100644
--- a/include/afxrich.h
+++ b/include/afxrich.h
@@ -312,7 +312,7 @@ protected:
 	void DeleteUnmarkedItems() const;
 	void UpdateObjectCache();
 public:
-	virtual ~CRichEditDoc() = 0 { }
+	virtual ~CRichEditDoc() {}
 	BOOL m_bUpdateObjectCache;
 	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
 	virtual void SetTitle(LPCTSTR lpszTitle);
diff --git a/include/afxspinbuttonctrl.h b/include/afxspinbuttonctrl.h
index 6bc0dd3..7a83f85 100644
--- a/include/afxspinbuttonctrl.h
+++ b/include/afxspinbuttonctrl.h
@@ -33,8 +33,8 @@ public:
 protected:
 	BOOL m_bIsButtonPressedUp;
 	BOOL m_bIsButtonPressedDown;
-	BOOL m_bIsButtonHighligtedUp;
-	BOOL m_bIsButtonHighligtedDown;
+	BOOL m_bIsButtonHighlightedUp;
+	BOOL m_bIsButtonHighlightedDown;
 	BOOL m_bTracked;
 
 // Overrides
diff --git a/include/afxstat_.h b/include/afxstat_.h
index e470f23..a311c01 100644
--- a/include/afxstat_.h
+++ b/include/afxstat_.h
@@ -93,11 +93,11 @@ public:
 	const GUID* m_pTypeLibID;
 
 protected:
+	long m_cRef;
 	LCID m_lcid;
 	LPTYPELIB m_ptlib;
 	GUID m_guidInfo;
 	LPTYPEINFO m_ptinfo;
-	long m_cRef;
 };
 
 #endif //!_AFX_NO_OLE_SUPPORT
diff --git a/include/afxtaskdialog.h b/include/afxtaskdialog.h
index 5c17934..44d9b5d 100644
--- a/include/afxtaskdialog.h
+++ b/include/afxtaskdialog.h
@@ -140,7 +140,7 @@ private:
 
 	} CTaskDialogButton;
 
-	typedef union
+	typedef struct
 	{
 		HICON hIcon;
 		PCWSTR pszIcon;
diff --git a/include/afxtempl.h b/include/afxtempl.h
index 12982eb..f6e9963 100644
--- a/include/afxtempl.h
+++ b/include/afxtempl.h
@@ -160,7 +160,7 @@ template<class ARG_KEY>
 AFX_INLINE UINT AFXAPI HashKey(ARG_KEY key)
 {
 	// (algorithm copied from STL hash in xfunctional)
-	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);
+	ldiv_t HashVal = ldiv((LONG_PTR)(ARG_KEY)key, 127773);
 	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;
 	if (HashVal.rem < 0)
 		HashVal.rem += 2147483647;
@@ -2051,7 +2051,7 @@ public:
 
 	// Lookup
 	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
-		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }
+		{ return BASE_CLASS::Lookup(key, (typename BASE_CLASS::BASE_VALUE&)rValue); }
 
 	// Lookup and add if not there
 	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
@@ -2067,8 +2067,8 @@ public:
 
 	// iteration
 	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
-		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
-			(BASE_CLASS::BASE_VALUE&)rValue); }
+		{ BASE_CLASS::GetNextAssoc(rPosition, (typename BASE_CLASS::BASE_KEY&)rKey,
+			(typename BASE_CLASS::BASE_VALUE&)rValue); }
 };
 
 /////////////////////////////////////////////////////////////////////////////
diff --git a/include/afxtls_.h b/include/afxtls_.h
index 4755b71..1d8851d 100644
--- a/include/afxtls_.h
+++ b/include/afxtls_.h
@@ -143,7 +143,7 @@ public:
 	void* PASCAL operator new(size_t nSize, LPCSTR, int);
 	void PASCAL operator delete(void* pObject, LPCSTR, int);
 #endif
-    virtual ~CNoTrackObject() {};
+	virtual ~CNoTrackObject() {}
 };
 
 class AFX_NOVTABLE CThreadLocalObject
diff --git a/include/afxtoolbar.h b/include/afxtoolbar.h
index a2e5812..84040c9 100644
--- a/include/afxtoolbar.h
+++ b/include/afxtoolbar.h
@@ -455,7 +455,7 @@ public:
 	/// <summary> Specifies whether to scale or not toolbar images in high DPI mode.</summary>
 	AFX_IMPORT_DATA static BOOL   m_bDontScaleImages;    // don't scale shared images in high DPI mode
 
-	static void __stdcall CMFCToolBar::CleanUpImages();
+	static void __stdcall CleanUpImages();
 	void CleanUpLockedImages();
 
 	void AdjustSize();
@@ -521,6 +521,7 @@ protected:
 
 protected:
 	friend class CWinAppEx;
+	friend class CMFCToolBarsOptionsPropertyPage;
 
 	AFX_IMPORT_DATA static CMFCToolBar* m_pSelToolbar;        // "Selected" toolbar in the customization mode
 
diff --git a/include/afxv_w32.h b/include/afxv_w32.h
index 1f77e86..6e9d177 100644
--- a/include/afxv_w32.h
+++ b/include/afxv_w32.h
@@ -21,6 +21,8 @@
 #define STRICT 1
 #endif
 
+#ifdef _MSC_VER
+
 // WinSDKVer.h contains the definition for _WIN32_WINNT_MAXVER (and other maximums).
 #include <winsdkver.h>
 
@@ -40,6 +42,134 @@
 // SDKDDKVer.h will set any of WINVER, NTDDI_VERSION and _WIN32_IE that are yet unset.
 #include <sdkddkver.h>
 
+#else
+
+#undef WINVER
+#define WINVER		0x0601
+#undef _WIN32_WINNT
+#define _WIN32_WINNT	0x0601
+#undef _WIN32_IE
+#define _WIN32_IE	0x0601
+
+#define _Deref_inout_z_
+#define _Deref_opt_out_
+#define _Deref_opt_out_z_
+#define _Deref_out_
+#define _Deref_out_opt_
+#define _Deref_out_opt_z_
+#define _Deref_out_z_
+#define _Deref_post_cap_(size)
+#define _Deref_post_maybenull_
+#define _Deref_post_opt_bytecount_c_(size)
+#define _Deref_post_opt_cap_(size)
+#define _Deref_post_opt_valid_
+#define _Deref_post_z_
+#define _Deref_post_z_cap_(cap)
+#define _Deref_pre_maybenull_
+#define _Deref_pre_z_
+
+#define _In_
+#define _In_bytecount_(size)
+#define _In_bytecount_x_(size)
+#define _In_count_(size)
+#define _In_count_c_(size)
+#define _In_opt_
+#define _In_opt_bytecount_(size)
+#define _In_opt_count_(size)
+#define _In_opt_count_c_(size)
+#define _In_opt_z_
+#define _In_opt_z_count_(size)
+#define _In_z_
+#define _In_z_count_(size)
+#define _In_z_count_c_(count)
+#define _Inout_
+#define _Inout_cap_(size)
+#define _Inout_opt_
+#define _Inout_opt_bytecap_(size)
+#define _Inout_opt_cap_(cap)
+#define _Inout_opt_z_
+#define _Inout_z_
+#define _Inout_z_bytecap_(size)
+#define _Inout_z_cap_(size)
+#define _Inout_z_cap_c_(size)
+
+#define _Out_
+#define _Out_bytecap_(size)
+#define _Out_bytecap_post_bytecount_(cap,count)
+#define _Out_bytecap_x_(size)
+#define _Out_bytecapcount_(size)
+#define _Out_cap_(size)
+#define _Out_cap_c_(cap)
+#define _Out_cap_post_count_(cap,count)
+#define _Out_cap_x_(cap)
+#define _Out_capcount_(capcount)
+#define _Out_capcount_x_(capcount)
+#define _Out_opt_
+#define _Out_opt_cap_(size)
+#define _Out_opt_cap_c_(size)
+#define _Out_opt_cap_post_count_(size,count)
+#define _Out_opt_z_cap_(size)
+#define _Out_opt_z_cap_post_count_(cap,count)
+#define _Out_z_cap_(size)
+#define _Out_z_cap_c_(size)
+#define _Out_z_cap_post_count_(cap,count)
+#define _Out_z_capcount_(size)
+
+#define _Post_z_
+#define _Post_z_count_(size)
+#define _Post_bytecount_c_(size)
+#define _Post_bytecount_x_(size)
+#define _Pre_notnull_
+#define _Prepost_bytecount_x_(size)
+#define _Prepost_opt_bytecount_x_(size)
+#define _Printf_format_string_
+
+#define _Ret_cap_(size)
+#define _Ret_count_x_(size)
+#define _Ret_opt_bytecap_(size)
+#define _Ret_opt_count_(size)
+#define _Ret_opt_z_
+#define _Ret_opt_z_cap_(size)
+#define _Ret_z_
+#define _Success_(expr)
+
+#define __deref
+#define __deref_inout_opt
+#define __deref_opt_out
+#define __deref_opt_out_opt
+#define __deref_out
+#define __format_string
+#define __in
+#define __in_opt
+#define __interface interface
+#define __noop
+#define __nullterminated
+#define __out
+#define __out_bcount_part(size,length)
+#define __out_bcount_part_z(size,length)
+#define __out_ecount_part(size,length)
+#define __out_ecount_part_z(size,length)
+#define __out_ecount_part_z_opt(size,length)
+#define __out_opt
+#define __post
+#define __success(expr)
+#define __unaligned
+
+#undef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(P) (void)(P)
+
+#ifndef __try
+#define __try try
+#endif
+#ifndef __except
+#define __except(x) catch(...)
+#endif
+#ifndef __finally
+#define __finally catch(...)
+#endif
+
+#endif
+
 // certain parts of WINDOWS.H are necessary
 #undef NOKERNEL
 #undef NOGDI
diff --git a/include/afxver_.h b/include/afxver_.h
index c43f3e2..7f13b13 100644
--- a/include/afxver_.h
+++ b/include/afxver_.h
@@ -323,10 +323,14 @@
 #ifndef AFX_ALWAYS_VTABLE
 #ifndef AFX_NOVTABLE
 #if !defined(_DEBUG)
+#ifdef _MSC_VER
 #define AFX_NOVTABLE __declspec(novtable)
 #else
 #define AFX_NOVTABLE
 #endif
+#else
+#define AFX_NOVTABLE
+#endif
 #endif
 #endif
 
diff --git a/include/afxvisualmanager.h b/include/afxvisualmanager.h
index 0ca790e..15f709a 100644
--- a/include/afxvisualmanager.h
+++ b/include/afxvisualmanager.h
@@ -12,6 +12,7 @@
 #pragma once
 
 #include "afxcontrolbarutil.h"
+#include "afxribbonbar.h"
 
 #ifdef _AFX_PACKING
 #pragma pack(push, _AFX_PACKING)
diff --git a/include/afxwin.h b/include/afxwin.h
index c057f53..542f58f 100644
--- a/include/afxwin.h
+++ b/include/afxwin.h
@@ -19,6 +19,7 @@
 	#include <afx.h>
 #endif
 
+#ifdef _MSC_VER
 // Note: WINDOWS.H already included from AFXV_W32.H
 #ifndef NTDDI_LONGHORN
 #define NTDDI_LONGHORN 0x06000000
@@ -26,6 +27,7 @@
 #error Your version of the Windows SDK is earlier than 6.0. Try setting the 'WINVER' and '_WIN32_WINNT' definitions in your project to less than 0x0600.
 #endif
 #endif
+#endif
 
 #ifndef _INC_SHELLAPI
 	#include <shellapi.h>
@@ -1257,7 +1259,7 @@ public:
 	virtual void AssertValid() const;
 	virtual void Dump(CDumpContext& dc) const;
 #endif
-	static CMenu* PASCAL CMenu::FromHandlePermanent(HMENU hMenu);
+	static CMenu* PASCAL FromHandlePermanent(HMENU hMenu);
 };
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1456,22 +1458,22 @@ protected: \
 	theClass* pThis = \
 		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
 	AFX_MANAGE_STATE(pThis->m_pModuleState) \
-	pThis; // avoid warning from compiler \
+	pThis; /* avoid warning from compiler */ \
 
 #define METHOD_PROLOGUE_(theClass, localClass) \
 	theClass* pThis = \
 		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
-	pThis; // avoid warning from compiler \
+	pThis; /* avoid warning from compiler */ \
 
 #ifndef _AFX_NO_NESTED_DERIVATION
 #define METHOD_PROLOGUE_EX(theClass, localClass) \
 	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
 	AFX_MANAGE_STATE(pThis->m_pModuleState) \
-	pThis; // avoid warning from compiler \
+	pThis; /* avoid warning from compiler */ \
 
 #define METHOD_PROLOGUE_EX_(theClass, localClass) \
 	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
-	pThis; // avoid warning from compiler \
+	pThis; /* avoid warning from compiler */ \
 
 #else
 #define METHOD_PROLOGUE_EX(theClass, localClass) \
@@ -3336,7 +3338,7 @@ protected:
 	// strOut   - the CString containing the received text
 
 	template <class TReturnType, class TCchType >
-	TReturnType EnlargeBufferGetText(_In_ TReturnType errCode, LPTSTR& pszText, TCchType& cch, TCchType cchBegin, TCchType cchEnd, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
+	TReturnType EnlargeBufferGetText(_In_ TReturnType errCode, LPTSTR& pszText, TCchType& cch, TCchType cchBegin, TCchType cchEnd, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const noexcept(false)
 	{
 		ENSURE(::IsWindow(m_hWnd));
 		ENSURE(cchBegin < cchEnd);
@@ -3370,13 +3372,13 @@ protected:
 
 
 	template <class TReturnType>
-	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, int& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
+	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, int& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const noexcept(false)
 	{
 		return EnlargeBufferGetText<TReturnType, int>(errCode, pszText, pcch, 256, INT_MAX, uMsg, wParam, lParam, strOut);
 	}
 
 	template <class TReturnType>
-	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, UINT& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
+	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, UINT& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const noexcept(false)
 	{
 		// using INT_MAX instead of UINT_MAX here because CString has a INT_MAX limit
 		return EnlargeBufferGetText<TReturnType, UINT>(errCode, pszText, pcch, 256, INT_MAX, uMsg, wParam, lParam, strOut);
@@ -4842,6 +4844,7 @@ class AFX_NOVTABLE CCtrlView : public CView
 	DECLARE_DYNCREATE(CCtrlView)
 
 public:
+	using CView::OnFilePrint;
 	CCtrlView(LPCTSTR lpszClass, DWORD dwStyle);
 
 // Attributes
diff --git a/include/afxwin2.inl b/include/afxwin2.inl
index e78e120..596dd8f 100644
--- a/include/afxwin2.inl
+++ b/include/afxwin2.inl
@@ -658,7 +658,7 @@ _AFXWIN_INLINE void CWnd::EndModalState()
 _AFXWIN_INLINE void CFrameWnd::DelayUpdateFrameTitle()
 	{ m_nIdleFlags |= idleTitle; }
 _AFXWIN_INLINE void CFrameWnd::DelayRecalcLayout(BOOL bNotify)
-	{ m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
+	{ m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); }
 _AFXWIN_INLINE BOOL CFrameWnd::InModalState() const
 	{ return m_cModalStack != 0; }
 _AFXWIN_INLINE void CFrameWnd::AddControlBar(CControlBar *pBar)
diff --git a/include/afxwin4.inl b/include/afxwin4.inl
index d4f288b..2489938 100644
--- a/include/afxwin4.inl
+++ b/include/afxwin4.inl
@@ -182,7 +182,7 @@ AFX_INLINE BOOL CWnd::PrintWindow(CDC* pDC, UINT nFlags) const
 }
 
 AFX_INLINE BOOL CScrollBar::GetScrollBarInfo(PSCROLLBARINFO pScrollInfo) const
-	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, SBM_GETSCROLLBARINFO, NULL, (LPARAM)pScrollInfo); }
+	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, SBM_GETSCROLLBARINFO, 0, (LPARAM)pScrollInfo); }
 
 AFX_INLINE BOOL CEdit::SetCueBanner(_In_z_ LPCWSTR lpszText, _In_ BOOL fDrawWhenFocused /* = FALSE */)
 {
@@ -441,7 +441,7 @@ AFX_INLINE TCHAR CButton::GetSplitGlyph() const
 	BUTTON_SPLITINFO buttonSplitInfo = {0};
 	buttonSplitInfo.mask = BCSIF_GLYPH;
 	Button_GetSplitInfo(m_hWnd, &buttonSplitInfo);
-	return (WCHAR)buttonSplitInfo.himlGlyph;
+	return (INT_PTR)buttonSplitInfo.himlGlyph;
 }
 
 AFX_INLINE BOOL CButton::SetSplitGlyph(_In_ TCHAR chGlyph)
@@ -449,7 +449,7 @@ AFX_INLINE BOOL CButton::SetSplitGlyph(_In_ TCHAR chGlyph)
 	ASSERT(::IsWindow(m_hWnd));
 	BUTTON_SPLITINFO buttonSplitInfo = {0};
 	buttonSplitInfo.mask = BCSIF_GLYPH;
-	buttonSplitInfo.himlGlyph = (HIMAGELIST)chGlyph;
+	buttonSplitInfo.himlGlyph = (HIMAGELIST&)chGlyph;
 	return Button_SetSplitInfo(m_hWnd, &buttonSplitInfo);
 }
 
diff --git a/include/afxwinforms.h b/include/afxwinforms.h
index a714740..41f640c 100644
--- a/include/afxwinforms.h
+++ b/include/afxwinforms.h
@@ -181,6 +181,8 @@ public:
 	System::Windows::Forms::Control^ get_Control() const;
 	
 	gcroot<CWinFormsEventsHelper^> m_gcEventHelper;
+private:
+	typedef COleControlSite __super;
 };
 
 /////////////////////////////////////////////////////////////////////////////
@@ -269,6 +271,7 @@ protected:
 private:
 	CWinFormsControl<System::Windows::Forms::Control> m_control;
 	gcroot<System::Object^> m_CmdSource;
+	typedef CView __super;
 		
 	DECLARE_MESSAGE_MAP()
 
@@ -301,6 +304,7 @@ protected:
 private:
 	DECLARE_MESSAGE_MAP()
 	gcroot<TManagedControl^> m_pWFControl;
+	typedef CDialog __super;
 };
 
 template <typename T>
diff --git a/include/atlacc.h b/include/atlacc.h
index 9ee0e20..3e3d797 100644
--- a/include/atlacc.h
+++ b/include/atlacc.h
@@ -403,7 +403,7 @@ public :
 		if (m_spStdObject == NULL)
 		{
 			T* pT = static_cast<T*>(this);
-			HRESULT hr = CreateStdAccessibleObject(pT->m_hWnd, OBJID_CLIENT, __uuidof(IAccessible), (void**)&m_spStdObject);
+			HRESULT hr = CreateStdAccessibleObject(pT->m_hWnd, OBJID_CLIENT, IID_IAccessible, (void**)&m_spStdObject);
 			if (FAILED(hr))
 				return hr;
 		}
@@ -724,19 +724,19 @@ public :
 					if (SUCCEEDED(hr))
 					{
 						CComPtr<IAccessibleProxy> spProx;
-						hr = p->QueryInterface(&spProx);
+						hr = p->QueryInterface(IID_IAccessibleProxy, (void**)&spProx);
 						if (SUCCEEDED(hr))
 						{
 							m_pProxy = spProx;
 							spProx->SetServer(static_cast<IAccessible*>(this), static_cast<IAccessibleServer*>(this));
-							*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
+							*pResult = LresultFromObject (IID_IAccessible, wParam, m_pProxy);
 						}
 						hr = S_OK;
 					}
 				}
 				else
 				{
-					*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
+					*pResult = LresultFromObject (IID_IAccessible, wParam, m_pProxy);
 					hr = S_OK;
 				}
 			}
@@ -1242,7 +1242,7 @@ inline HRESULT STDMETHODCALLTYPE AtlIAccessibleGetIDsOfNamesHelper(
 	_In_ LCID,
 	_Out_cap_(cNames) DISPID *rgDispId)
 {
-	static LPOLESTR names[] =
+	static LPCOLESTR names[] =
 	{
 		L"accParent",
 		L"accChildCount",
@@ -1289,7 +1289,7 @@ inline HRESULT STDMETHODCALLTYPE AtlIAccessibleGetIDsOfNamesHelper(
 	for (unsigned int i = 0; i < cNames; ++i)
 	{
 		bool bFoundIt = false;
-		for (unsigned int j = 0; j < sizeof(names)/sizeof(LPOLESTR); ++j)
+		for (unsigned int j = 0; j < sizeof(names)/sizeof(LPCOLESTR); ++j)
 		{
 			if (lstrcmpW(rgszNames[i], names[j]) == 0)
 			{
diff --git a/include/atlalloc.h b/include/atlalloc.h
index c179a94..ea2cf4b 100644
--- a/include/atlalloc.h
+++ b/include/atlalloc.h
@@ -214,7 +214,7 @@ inline T AtlAddThrow(
 	return tResult;
 }
 
-_Ret_opt_bytecount_x_(nCount * nSize) inline LPVOID AtlCoTaskMemCAlloc(
+inline LPVOID AtlCoTaskMemCAlloc(
 	_In_ ULONG nCount,
 	_In_ ULONG nSize)
 {
@@ -227,7 +227,7 @@ _Ret_opt_bytecount_x_(nCount * nSize) inline LPVOID AtlCoTaskMemCAlloc(
 	return ::CoTaskMemAlloc(nBytes);
 }
 
-_Ret_opt_bytecount_x_(nCount * nSize) inline LPVOID AtlCoTaskMemRecalloc(
+inline LPVOID AtlCoTaskMemRecalloc(
 	_In_opt_ void *pvMemory,
 	_In_ ULONG nCount,
 	_In_ ULONG nSize)
@@ -467,7 +467,7 @@ public:
 		{
 			return false;
 		}
-		return AllocateBytes(nBytes);
+		return this->AllocateBytes(nBytes);
 	}
 
 	// Reallocate the buffer to hold a given number of elements
@@ -478,7 +478,7 @@ public:
 		{
 			return false;
 		}
-		return ReallocateBytes(nBytes);
+		return this->ReallocateBytes(nBytes);
 	}
 };
 
@@ -490,7 +490,7 @@ public:
 		m_p( NULL )
 	{
 	}
-	CTempBuffer(_In_ size_t nElements) throw( ... ) :
+	CTempBuffer(_In_ size_t nElements) noexcept(false) :
 		m_p( NULL )
 	{
 		Allocate( nElements );
@@ -514,12 +514,12 @@ public:
 		return( m_p );
 	}
 
-	_Ret_opt_bytecap_x_(nElements * sizeof(T)) T* Allocate(_In_ size_t nElements) throw( ... )
+	T* Allocate(_In_ size_t nElements) noexcept(false)
 	{
 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );
 	}
 
-	_Ret_opt_bytecap_x_(nElements * sizeof(T)) T* Reallocate(_In_ size_t nElements) throw( ... )
+	T* Reallocate(_In_ size_t nElements) noexcept(false)
 	{
 		ATLENSURE(nElements < size_t(-1)/sizeof(T) );
 		size_t nNewSize = nElements*sizeof( T ) ;
@@ -721,23 +721,15 @@ public :
 // Disable _alloca not within try-except prefast warning since we verify stack space is available before.
 #ifdef _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE
 #define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
-	__pragma(warning(push))\
-	__pragma(warning(disable:4616))\
-	__pragma(warning(disable:6255))\
 	((nRequestedSize <= nThreshold && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold) ) ?	\
 		_alloca(nThreshold) :	\
 		((ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold)) ? _alloca(nThreshold) : 0),	\
-			_AtlSafeAllocaManager.Allocate(nRequestedSize))\
-	__pragma(warning(pop))
+			_AtlSafeAllocaManager.Allocate(nRequestedSize))
 #else
 #define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
-	__pragma(warning(push))\
-	__pragma(warning(disable:4616))\
-	__pragma(warning(disable:6255))\
 	((nRequestedSize <= nThreshold && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nRequestedSize) ) ?	\
 		_alloca(nRequestedSize) :	\
-		_AtlSafeAllocaManager.Allocate(nRequestedSize))\
-	__pragma(warning(pop))
+		_AtlSafeAllocaManager.Allocate(nRequestedSize))
 #endif
 
 // Use 1024 bytes as the default threshold in ATL
diff --git a/include/atlbase.h b/include/atlbase.h
index 617eda0..9d63812 100644
--- a/include/atlbase.h
+++ b/include/atlbase.h
@@ -100,6 +100,7 @@
 
 #ifndef _ATL_NO_DEFAULT_LIBS
 
+#ifdef _MSC_VER
 #if defined(_ATL_DLL)
 	#pragma comment(lib, "atl.lib")
 
@@ -115,6 +116,7 @@
 	#pragma message("_ATL_MIN_CRT is no longer supported.  Please see documentation for more information.")
 #endif
 
+#endif // _MSC_VER
 
 #endif	// !_ATL_NO_DEFAULT_LIBS
 
@@ -202,7 +204,7 @@ struct _ATL_OBJMAP_ENTRY30
 		IUnknown* p = NULL;
 		if (pfnGetClassObject == NULL)
 			return S_OK;
-		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, __uuidof(IUnknown), (LPVOID*) &p);
+		HRESULT hRes = pfnGetClassObject((PVOID)pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
 		if (SUCCEEDED(hRes))
 			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
 		if (p != NULL)
@@ -217,13 +219,20 @@ typedef _ATL_OBJMAP_ENTRY30 _ATL_OBJMAP_ENTRY;
 
 // Auto Object Map
 
+#ifdef _MSC_VER
 #pragma section("ATL$__a", read)
 #pragma section("ATL$__z", read)
 #pragma section("ATL$__m", read)
+#endif
 extern "C"
 {
+#ifdef _MSC_VER
 __declspec(selectany) __declspec(allocate("ATL$__a")) _ATL_OBJMAP_ENTRY* __pobjMapEntryFirst = NULL;
 __declspec(selectany) __declspec(allocate("ATL$__z")) _ATL_OBJMAP_ENTRY* __pobjMapEntryLast = NULL;
+#else
+__declspec(selectany) __attribute__((section("ATL$__a"))) _ATL_OBJMAP_ENTRY* __pobjMapEntryFirst = NULL;
+__declspec(selectany) __attribute__((section("ATL$__z"))) _ATL_OBJMAP_ENTRY* __pobjMapEntryLast = NULL;
+#endif
 }
 
 #if !defined(_M_IA64)
@@ -536,7 +545,7 @@ ATLAPI AtlRegisterClassCategoriesHelper(
 	_In_opt_ const struct _ATL_CATMAP_ENTRY* pCatMap,
 	_In_ BOOL bRegister);
 
-ATLAPI AtlUpdateRegistryFromResourceD(
+STDAPI AtlUpdateRegistryFromResourceD(
 	_In_ HINSTANCE hInst,
 	_In_z_ LPCOLESTR lpszRes,
 	_In_ BOOL bRegister,
@@ -2588,7 +2597,7 @@ public:
 			++m_nIndexQI;
 			if (m_nIndexBreakAt == m_nIndexQI)
 				DebugBreak();
-			ATLTRY(pThunk = new _QIThunk(p, lpsz, __uuidof(IUnknown), m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
+			ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
 			if (pThunk == NULL)
 			{
 				return E_OUTOFMEMORY;
@@ -2865,7 +2874,7 @@ public :
 		if (m_pGIT == NULL)
 		{
 			hr = ::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
-				__uuidof(IGlobalInterfaceTable), (void**)&m_pGIT);
+				IID_IGlobalInterfaceTable, (void**)&m_pGIT);
 		}
 
 		if (SUCCEEDED(hr))
@@ -3005,14 +3014,14 @@ ATLPREFAST_UNSUPPRESS()
 		_In_z_ LPCTSTR psz1,
 		_In_z_ LPCTSTR psz2) throw()
 	{
-		TCHAR c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
-		TCHAR c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
+		TCHAR c1 = (TCHAR)*CharUpper((LPTSTR)psz1);
+		TCHAR c2 = (TCHAR)*CharUpper((LPTSTR)psz2);
 		while (c1 != _T('\0') && c1 == c2 && c1 != ' ' && c1 != '\t')
 		{
 			psz1 = CharNext(psz1);
 			psz2 = CharNext(psz2);
-			c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
-			c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
+			c1 = (TCHAR)*CharUpper((LPTSTR)psz1);
+			c2 = (TCHAR)*CharUpper((LPTSTR)psz2);
 		}
 		if ((c1 == _T('\0') || c1 == ' ' || c1 == '\t') && (c2 == _T('\0') || c2 == ' ' || c2 == '\t'))
 			return 0;
@@ -3058,7 +3067,7 @@ inline HRESULT AtlGetGITPtr(_Deref_out_ IGlobalInterfaceTable** ppGIT) throw()
 	if (_pAtlModule == NULL)
 	{
 		return CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IGlobalInterfaceTable), (void**)ppGIT);
+			IID_IGlobalInterfaceTable, (void**)ppGIT);
 	}
 	else
 	{
@@ -3066,6 +3075,169 @@ inline HRESULT AtlGetGITPtr(_Deref_out_ IGlobalInterfaceTable** ppGIT) throw()
 	}
 }
 
+/////////////////////////////////////////////////////////////////////////////
+// CRegKey
+
+class CRegKey
+{
+public:
+	/// <summary>
+	/// CRegKey constructor</summary>
+	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
+	CRegKey(_In_opt_ CAtlTransactionManager* pTM = NULL) throw();
+	CRegKey(_Inout_ CRegKey& key) throw();
+	explicit CRegKey(_In_ HKEY hKey) throw();
+	~CRegKey() throw();
+
+	CRegKey& operator=(_Inout_ CRegKey& key) throw();
+
+// Attributes
+public:
+	operator HKEY() const throw();
+	HKEY m_hKey;
+	REGSAM m_samWOW64;
+
+	/// <summary>
+	/// Pointer to CAtlTransactionManager object</summary>
+	CAtlTransactionManager* m_pTM;
+
+// Operations
+public:
+	ATL_DEPRECATED("CRegKey::SetValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::SetDWORDValue")
+	LONG SetValue(
+		_In_ DWORD dwValue,
+		_In_opt_z_ LPCTSTR lpszValueName);
+
+	ATL_DEPRECATED("CRegKey::SetValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::SetStringValue and CRegKey::SetMultiStringValue")
+	LONG SetValue(
+		_In_z_ LPCTSTR lpszValue,
+		_In_opt_z_ LPCTSTR lpszValueName = NULL,
+		_In_ bool bMulti = false,
+		_In_ int nValueLen = -1);
+	LONG SetValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_ DWORD dwType,
+		_In_opt_ const void* pValue,
+		_In_ ULONG nBytes) throw();
+	LONG SetGUIDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_ REFGUID guidValue) throw();
+	LONG SetBinaryValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_opt_ const void* pValue,
+		_In_ ULONG nBytes) throw();
+	LONG SetDWORDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_ DWORD dwValue) throw();
+	LONG SetQWORDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_ ULONGLONG qwValue) throw();
+	LONG SetStringValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_opt_z_ LPCTSTR pszValue,
+		_In_ DWORD dwType = REG_SZ) throw();
+	LONG SetMultiStringValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_In_z_ LPCTSTR pszValue) throw();
+
+	ATL_DEPRECATED("CRegKey::QueryValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::QueryDWORDValue")
+	LONG QueryValue(
+		_Out_ DWORD& dwValue,
+		_In_opt_z_ LPCTSTR lpszValueName);
+
+	ATL_DEPRECATED("CRegKey::QueryValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::QueryStringValue and CRegKey::QueryMultiStringValue")
+	LONG QueryValue(
+		_Out_opt_z_cap_post_count_(*pdwCount, *pdwCount) LPTSTR szValue,
+		_In_opt_z_ LPCTSTR lpszValueName,
+		_Inout_ DWORD* pdwCount);
+	LONG QueryValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_opt_ DWORD* pdwType,
+		_Out_opt_ void* pData,
+		_Inout_ ULONG* pnBytes) throw();
+	LONG QueryGUIDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_ GUID& guidValue) throw();
+	LONG QueryBinaryValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_opt_ void* pValue,
+		_Inout_opt_ ULONG* pnBytes) throw();
+	LONG QueryDWORDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_ DWORD& dwValue) throw();
+	LONG QueryQWORDValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_ ULONGLONG& qwValue) throw();
+	LONG QueryStringValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
+		_Inout_ ULONG* pnChars) throw();
+	LONG QueryMultiStringValue(
+		_In_opt_z_ LPCTSTR pszValueName,
+		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
+		_Inout_ ULONG* pnChars) throw();
+
+	// Get the key's security attributes.
+	LONG GetKeySecurity(
+		_In_ SECURITY_INFORMATION si,
+		_Out_opt_ PSECURITY_DESCRIPTOR psd,
+		_Inout_ LPDWORD pnBytes) throw();
+	// Set the key's security attributes.
+	LONG SetKeySecurity(
+		_In_ SECURITY_INFORMATION si,
+		_In_ PSECURITY_DESCRIPTOR psd) throw();
+
+	LONG SetKeyValue(
+		_In_z_ LPCTSTR lpszKeyName,
+		_In_opt_z_ LPCTSTR lpszValue,
+		_In_opt_z_ LPCTSTR lpszValueName = NULL) throw();
+	static LONG WINAPI SetValue(
+		_In_ HKEY hKeyParent,
+		_In_z_ LPCTSTR lpszKeyName,
+		_In_opt_z_ LPCTSTR lpszValue,
+		_In_opt_z_ LPCTSTR lpszValueName = NULL);
+
+	// Create a new registry key (or open an existing one).
+	LONG Create(
+		_In_ HKEY hKeyParent,
+		_In_z_ LPCTSTR lpszKeyName,
+		_In_opt_z_ LPTSTR lpszClass = REG_NONE,
+		_In_ DWORD dwOptions = REG_OPTION_NON_VOLATILE,
+		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE,
+		_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
+		_Out_opt_ LPDWORD lpdwDisposition = NULL) throw();
+	// Open an existing registry key.
+	LONG Open(
+		_In_ HKEY hKeyParent,
+		_In_opt_z_ LPCTSTR lpszKeyName,
+		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE) throw();
+	// Close the registry key.
+	LONG Close() throw();
+	// Flush the key's data to disk.
+	LONG Flush() throw();
+
+	// Detach the CRegKey object from its HKEY.  Releases ownership.
+	HKEY Detach() throw();
+	// Attach the CRegKey object to an existing HKEY.  Takes ownership.
+	void Attach(_In_ HKEY hKey) throw();
+
+	// Enumerate the subkeys of the key.
+	LONG EnumKey(
+		_In_ DWORD iIndex,
+		_Out_z_cap_post_count_(*pnNameLength, *pnNameLength) LPTSTR pszName,
+		_Inout_ LPDWORD pnNameLength,
+		_Out_opt_ FILETIME* pftLastWriteTime = NULL) throw();
+	LONG NotifyChangeKeyValue(
+		_In_ BOOL bWatchSubtree,
+		_In_ DWORD dwNotifyFilter,
+		_In_ HANDLE hEvent,
+		_In_ BOOL bAsync = TRUE) throw();
+
+	LONG DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw();
+	LONG RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw();
+	LONG DeleteValue(_In_z_ LPCTSTR lpszValue) throw();
+};
+
 template <class T>
 class ATL_NO_VTABLE CAtlModuleT : 
 	public CAtlModule
@@ -3354,7 +3526,7 @@ public :
 #endif
 
 		// Call term functions before COM is uninitialized
-		Term();
+		this->Term();
 
 #ifndef _ATL_NO_COM_SUPPORT
 
@@ -3497,10 +3669,10 @@ public :
 		TCHAR szTokens[] = _T("-/");
 
 		T* pT = static_cast<T*>(this);
-		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
+		LPCTSTR lpszToken = this->FindOneOf(lpCmdLine, szTokens);
 		while (lpszToken != NULL)
 		{
-			if (WordCmpI(lpszToken, _T("UnregServer"))==0)
+			if (this->WordCmpI(lpszToken, _T("UnregServer"))==0)
 			{
 				*pnRetCode = pT->UnregisterServer(TRUE);
 				if (SUCCEEDED(*pnRetCode))
@@ -3508,7 +3680,7 @@ public :
 				return false;
 			}
 
-			if (WordCmpI(lpszToken, _T("RegServer"))==0)
+			if (this->WordCmpI(lpszToken, _T("RegServer"))==0)
 			{
 				*pnRetCode = pT->RegisterAppId();
 				if (SUCCEEDED(*pnRetCode))
@@ -3516,7 +3688,7 @@ public :
 				return false;
 			}
 
-			if (WordCmpI(lpszToken, _T("UnregServerPerUser"))==0)
+			if (this->WordCmpI(lpszToken, _T("UnregServerPerUser"))==0)
 			{
 				*pnRetCode = AtlSetPerUserRegistration(true);
 				if (FAILED(*pnRetCode))
@@ -3530,7 +3702,7 @@ public :
 				return false;
 			}
 
-			if (WordCmpI(lpszToken, _T("RegServerPerUser"))==0)
+			if (this->WordCmpI(lpszToken, _T("RegServerPerUser"))==0)
 			{
 				*pnRetCode = AtlSetPerUserRegistration(true);
 				if (FAILED(*pnRetCode))
@@ -3544,7 +3716,7 @@ public :
 				return false;
 			}
 
-			lpszToken = FindOneOf(lpszToken, szTokens);
+			lpszToken = this->FindOneOf(lpszToken, szTokens);
 		}
 
 		return true;
@@ -3844,17 +4016,17 @@ public :
 		*pnRetCode = S_OK;
 
 		T* pT = static_cast<T*>(this);
-		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
+		LPCTSTR lpszToken = this->FindOneOf(lpCmdLine, szTokens);
 		while (lpszToken != NULL)
 		{
-			if (WordCmpI(lpszToken, _T("Service"))==0)
+			if (this->WordCmpI(lpszToken, _T("Service"))==0)
 			{
 				*pnRetCode = pT->RegisterAppId(true);
 				if (SUCCEEDED(*pnRetCode))
 					*pnRetCode = pT->RegisterServer(TRUE);
 				return false;
 			}
-			lpszToken = FindOneOf(lpszToken, szTokens);
+			lpszToken = this->FindOneOf(lpszToken, szTokens);
 		}
 		return true;
 	}
@@ -4322,6 +4494,10 @@ public:
 	SERVICE_STATUS m_status;
 	BOOL m_bService;
 	DWORD m_dwThreadID;
+	DWORD m_dwTimeOut;
+	HANDLE m_hEventShutdown;
+	bool m_bDelayShutdown;
+	bool m_bComInitialized;
 };
 
 #endif //	_ATL_NO_SERVICE
@@ -4485,13 +4661,21 @@ public :
 #endif
 	}
 
+#ifdef _MSC_VER
 	__declspec(property(get = get_m_hInst)) HINSTANCE m_hInst;
+#else
+	HINSTANCE m_hInst;
+#endif
 	HINSTANCE& get_m_hInst() const throw()
 	{
 		return _AtlBaseModule.m_hInst;
 	}
 
+#ifdef _MSC_VER
 	__declspec(property(get = get_m_hInstResource, put = put_m_hInstResource)) HINSTANCE m_hInstResource;
+#else
+	HINSTANCE m_hInstResource;
+#endif
 	HINSTANCE& get_m_hInstResource() const throw()
 	{
 		return _AtlBaseModule.m_hInstResource;
@@ -4514,7 +4698,11 @@ public :
 		return _AtlBaseModule.m_hInstResource;
 	}
 
+#ifdef _MSC_VER
 	__declspec(property(get = get_m_hInstTypeLib, put = put_m_hInstTypeLib)) HINSTANCE m_hInstTypeLib;
+#else
+	HINSTANCE m_hInstTypeLib;
+#endif
 	HINSTANCE& get_m_hInstTypeLib() const throw()
 	{
 		return _AtlComModule.m_hInstTypeLib;
@@ -4532,14 +4720,27 @@ public :
 	// For Backward compatibility
 	_ATL_OBJMAP_ENTRY* m_pObjMap;
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_csWindowCreate)) CRITICAL_SECTION m_csWindowCreate;
+#else
+	CRITICAL_SECTION m_csWindowCreate;
+#endif
 	CRITICAL_SECTION& get_m_csWindowCreate() throw();
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_csObjMap)) CRITICAL_SECTION m_csObjMap;
+#else
+	HINSTANCE m_csObjMap;
+#endif
 	CRITICAL_SECTION& get_m_csObjMap() throw();
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csTypeInfoHolder;
 	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csStaticDataInit;
+#else
+	CRITICAL_SECTION m_csTypeInfoHolder;
+	CRITICAL_SECTION m_csStaticDataInit;
+#endif
 	CRITICAL_SECTION& get_m_csStaticDataInit() throw();
 	void EnterStaticDataCriticalSection() throw()
 	{
@@ -4551,17 +4752,29 @@ public :
 		LeaveCriticalSection(&m_csStaticDataInit);
 	}
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_dwAtlBuildVer)) DWORD dwAtlBuildVer;
+#else
+	DWORD dwAtlBuildVer;
+#endif
 	DWORD& get_dwAtlBuildVer() throw()
 	{
 		return _AtlBaseModule.dwAtlBuildVer;
 	}
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_pCreateWndList, put = put_m_pCreateWndList)) _AtlCreateWndData* m_pCreateWndList;
+#else
+	_AtlCreateWndData* m_pCreateWndList;
+#endif
 	_AtlCreateWndData*& get_m_pCreateWndList() throw();
 	void put_m_pCreateWndList(_In_ _AtlCreateWndData* p) throw();
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_pguidVer)) const GUID* pguidVer;
+#else
+	const GUID* pguidVer;
+#endif
 	const GUID*& get_pguidVer() throw()
 	{
 		return _AtlBaseModule.pguidVer;
@@ -4569,15 +4782,27 @@ public :
 
 #ifdef _ATL_DEBUG_INTERFACES
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_nIndexQI, put = put_m_nIndexQI)) UINT m_nIndexQI;
+#else
+	UINT m_nIndexQI;
+#endif
 	UINT& get_m_nIndexQI() throw();
 	void put_m_nIndexQI(_In_ UINT nIndex) throw();
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_nIndexBreakAt, put = put_m_nIndexBreakAt)) UINT m_nIndexBreakAt;
+#else
+	UINT m_nIndexBreakAt;
+#endif
 	UINT& get_m_nIndexBreakAt() throw();
 	void put_m_nIndexBreakAt(_In_ UINT nIndex) throw();
 
+#ifdef _MSC_VER
 	__declspec(property(get  = get_m_paThunks)) CSimpleArray<_QIThunk*>* m_paThunks;
+#else
+	CSimpleArray<_QIThunk*>* m_paThunks;
+#endif
 	CSimpleArray<_QIThunk*>* get_m_paThunks() throw();
 	HRESULT AddThunk(
 		_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
@@ -4960,7 +5185,7 @@ public:
 			{
 				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
 				IUnknown* pUnk = NULL;
-				pdata->hRes = pdata->pfnCreateInstance(NULL, __uuidof(IUnknown), (void**)&pUnk);
+				pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
 				if (SUCCEEDED(pdata->hRes))
 					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
 				if (SUCCEEDED(pdata->hRes))
@@ -5175,6 +5400,7 @@ public :
 };
 
 #ifndef _ATL_NO_COMMODULE
+#ifndef _ATL_DLL_IMPL
 
 template <class ThreadAllocator = CComSimpleThreadAllocator, DWORD dwWait = INFINITE>
 class CComAutoThreadModule :
@@ -5182,7 +5408,9 @@ class CComAutoThreadModule :
 	public CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>
 {
 public:
-	CComAutoThreadModule(_In_ int nThreads = GetDefaultThreads()) :
+	typedef CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait> CThisAutoThreadModule;
+
+	CComAutoThreadModule(_In_ int nThreads = CThisAutoThreadModule::GetDefaultThreads()) :
 		CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>(nThreads)
 	{
 	}
@@ -5190,7 +5418,7 @@ public:
 		_In_ _ATL_OBJMAP_ENTRY* p,
 		_In_ HINSTANCE h,
 		_In_opt_ const GUID* plibid = NULL,
-		_In_ int nThreads = GetDefaultThreads())
+		_In_ int nThreads = CThisAutoThreadModule::GetDefaultThreads())
 	{
 		nThreads;
 		ATLASSERT(nThreads == GetDefaultThreads() && _T("Set number of threads through the constructor"));
@@ -5198,6 +5426,7 @@ public:
 	}
 };
 
+#endif
 #endif	// !_ATL_NO_COMMODULE
 
 // Used in CThreadPool
@@ -5452,168 +5681,6 @@ public:
 	DWORD m_dwCookie;
 };
 
-/////////////////////////////////////////////////////////////////////////////
-// CRegKey
-
-class CRegKey
-{
-public:
-	/// <summary>
-	/// CRegKey constructor</summary>
-	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
-	CRegKey(_In_opt_ CAtlTransactionManager* pTM = NULL) throw();
-	CRegKey(_Inout_ CRegKey& key) throw();
-	explicit CRegKey(_In_ HKEY hKey) throw();
-	~CRegKey() throw();
-
-	CRegKey& operator=(_Inout_ CRegKey& key) throw();
-
-// Attributes
-public:
-	operator HKEY() const throw();
-	HKEY m_hKey;
-	REGSAM m_samWOW64;
-
-	/// <summary>
-	/// Pointer to CAtlTransactionManager object</summary>
-	CAtlTransactionManager* m_pTM;
-
-// Operations
-public:
-	ATL_DEPRECATED("CRegKey::SetValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::SetDWORDValue")
-	LONG SetValue(
-		_In_ DWORD dwValue,
-		_In_opt_z_ LPCTSTR lpszValueName);
-
-	ATL_DEPRECATED("CRegKey::SetValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::SetStringValue and CRegKey::SetMultiStringValue")
-	LONG SetValue(
-		_In_z_ LPCTSTR lpszValue,
-		_In_opt_z_ LPCTSTR lpszValueName = NULL,
-		_In_ bool bMulti = false,
-		_In_ int nValueLen = -1);
-	LONG SetValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_ DWORD dwType,
-		_In_opt_ const void* pValue,
-		_In_ ULONG nBytes) throw();
-	LONG SetGUIDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_ REFGUID guidValue) throw();
-	LONG SetBinaryValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_opt_ const void* pValue,
-		_In_ ULONG nBytes) throw();
-	LONG SetDWORDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_ DWORD dwValue) throw();
-	LONG SetQWORDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_ ULONGLONG qwValue) throw();
-	LONG SetStringValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_opt_z_ LPCTSTR pszValue,
-		_In_ DWORD dwType = REG_SZ) throw();
-	LONG SetMultiStringValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_In_z_ LPCTSTR pszValue) throw();
-
-	ATL_DEPRECATED("CRegKey::QueryValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::QueryDWORDValue")
-	LONG QueryValue(
-		_Out_ DWORD& dwValue,
-		_In_opt_z_ LPCTSTR lpszValueName);
-
-	ATL_DEPRECATED("CRegKey::QueryValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::QueryStringValue and CRegKey::QueryMultiStringValue")
-	LONG QueryValue(
-		_Out_opt_z_cap_post_count_(*pdwCount, *pdwCount) LPTSTR szValue,
-		_In_opt_z_ LPCTSTR lpszValueName,
-		_Inout_ DWORD* pdwCount);
-	LONG QueryValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_opt_ DWORD* pdwType,
-		_Out_opt_ void* pData,
-		_Inout_ ULONG* pnBytes) throw();
-	LONG QueryGUIDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_ GUID& guidValue) throw();
-	LONG QueryBinaryValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_opt_ void* pValue,
-		_Inout_opt_ ULONG* pnBytes) throw();
-	LONG QueryDWORDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_ DWORD& dwValue) throw();
-	LONG QueryQWORDValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_ ULONGLONG& qwValue) throw();
-	LONG QueryStringValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
-		_Inout_ ULONG* pnChars) throw();
-	LONG QueryMultiStringValue(
-		_In_opt_z_ LPCTSTR pszValueName,
-		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
-		_Inout_ ULONG* pnChars) throw();
-
-	// Get the key's security attributes.
-	LONG GetKeySecurity(
-		_In_ SECURITY_INFORMATION si,
-		_Out_opt_ PSECURITY_DESCRIPTOR psd,
-		_Inout_ LPDWORD pnBytes) throw();
-	// Set the key's security attributes.
-	LONG SetKeySecurity(
-		_In_ SECURITY_INFORMATION si,
-		_In_ PSECURITY_DESCRIPTOR psd) throw();
-
-	LONG SetKeyValue(
-		_In_z_ LPCTSTR lpszKeyName,
-		_In_opt_z_ LPCTSTR lpszValue,
-		_In_opt_z_ LPCTSTR lpszValueName = NULL) throw();
-	static LONG WINAPI SetValue(
-		_In_ HKEY hKeyParent,
-		_In_z_ LPCTSTR lpszKeyName,
-		_In_opt_z_ LPCTSTR lpszValue,
-		_In_opt_z_ LPCTSTR lpszValueName = NULL);
-
-	// Create a new registry key (or open an existing one).
-	LONG Create(
-		_In_ HKEY hKeyParent,
-		_In_z_ LPCTSTR lpszKeyName,
-		_In_opt_z_ LPTSTR lpszClass = REG_NONE,
-		_In_ DWORD dwOptions = REG_OPTION_NON_VOLATILE,
-		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE,
-		_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
-		_Out_opt_ LPDWORD lpdwDisposition = NULL) throw();
-	// Open an existing registry key.
-	LONG Open(
-		_In_ HKEY hKeyParent,
-		_In_opt_z_ LPCTSTR lpszKeyName,
-		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE) throw();
-	// Close the registry key.
-	LONG Close() throw();
-	// Flush the key's data to disk.
-	LONG Flush() throw();
-
-	// Detach the CRegKey object from its HKEY.  Releases ownership.
-	HKEY Detach() throw();
-	// Attach the CRegKey object to an existing HKEY.  Takes ownership.
-	void Attach(_In_ HKEY hKey) throw();
-
-	// Enumerate the subkeys of the key.
-	LONG EnumKey(
-		_In_ DWORD iIndex,
-		_Out_z_cap_post_count_(*pnNameLength, *pnNameLength) LPTSTR pszName,
-		_Inout_ LPDWORD pnNameLength,
-		_Out_opt_ FILETIME* pftLastWriteTime = NULL) throw();
-	LONG NotifyChangeKeyValue(
-		_In_ BOOL bWatchSubtree,
-		_In_ DWORD dwNotifyFilter,
-		_In_ HANDLE hEvent,
-		_In_ BOOL bAsync = TRUE) throw();
-
-	LONG DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw();
-	LONG RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw();
-	LONG DeleteValue(_In_z_ LPCTSTR lpszValue) throw();
-};
 
 inline CRegKey::CRegKey(_In_opt_ CAtlTransactionManager* pTM) throw() :
 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)
@@ -6677,7 +6744,7 @@ inline HRESULT WINAPI CComModule::RegisterClassHelper(
 	USES_CONVERSION_EX;
 	TCHAR szModule[_MAX_PATH + _ATL_QUOTES_SPACE];
 
-	ATLENSURE(lpszProgID && lpszVerIndProgID || !lpszProgID && !lpszVerIndProgID);
+	ATLENSURE((lpszProgID && lpszVerIndProgID) || (!lpszProgID && !lpszVerIndProgID));
 
 	if (!szDesc)
 	{
@@ -7120,7 +7187,7 @@ ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper(
    }
 
    hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
-	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );
+	  CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
    if( FAILED( hResult ) )
    {
 	  // Since not all systems have the category manager installed, we'll allow
@@ -7330,7 +7397,7 @@ ATLINLINE ATLAPIINL AtlRegisterTypeLib(
 		OLECHAR szDirBuffer[MAX_PATH];
 		CComBSTR bstrHelpFile;
 		hr = pTypeLib->GetDocumentation(-1, NULL, NULL, NULL, &bstrHelpFile);
-		if (SUCCEEDED(hr) && bstrHelpFile != NULL)
+		if (SUCCEEDED(hr))
 		{
 			Checked::wcsncpy_s(szDirBuffer, MAX_PATH, bstrHelpFile.m_str, bstrHelpFile.Length());
 			szDirBuffer[MAX_PATH - 1] = 0;
@@ -7833,7 +7900,7 @@ inline HRESULT CComModule::GetClassObject(
 
 					if (pEntry->pCF == NULL)
 					{
-						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
+						hr = pEntry->pfnGetClassObject((PVOID)pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
 					}
 				}
 
diff --git a/include/atlbase.inl b/include/atlbase.inl
index 5269721..1497bd4 100644
--- a/include/atlbase.inl
+++ b/include/atlbase.inl
@@ -35,7 +35,7 @@ ATLINLINE ATLAPI AtlAdvise(
 
 	CComPtr<IConnectionPointContainer> pCPC;
 	CComPtr<IConnectionPoint> pCP;
-	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
+	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
 	if (SUCCEEDED(hRes))
 		hRes = pCPC->FindConnectionPoint(iid, &pCP);
 	if (SUCCEEDED(hRes))
@@ -53,7 +53,7 @@ ATLINLINE ATLAPI AtlUnadvise(
 
 	CComPtr<IConnectionPointContainer> pCPC;
 	CComPtr<IConnectionPoint> pCP;
-	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
+	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
 	if (SUCCEEDED(hRes))
 		hRes = pCPC->FindConnectionPoint(iid, &pCP);
 	if (SUCCEEDED(hRes))
@@ -176,7 +176,7 @@ ATLINLINE ATLAPI AtlComModuleGetClassObject(
 
 					if (pEntry->pCF == NULL)
 					{
-						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
+						hr = pEntry->pfnGetClassObject((PVOID)pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
 					}
 				}
 
diff --git a/include/atlcoll.h b/include/atlcoll.h
index cc3f8d4..3610c2e 100644
--- a/include/atlcoll.h
+++ b/include/atlcoll.h
@@ -419,7 +419,7 @@ public:
 	}
 };
 
-template< typename T, class CharTraits = CDefaultCharTraits<T::XCHAR> >
+template< typename T, class CharTraits = CDefaultCharTraits<typename T::XCHAR> >
 class CStringElementTraitsI :
 	public CElementTraitsBase< T >
 {
@@ -431,7 +431,7 @@ public:
 	{
 		ULONG nHash = 0;
 
-		const T::XCHAR* pch = str;
+		const typename T::XCHAR* pch = str;
 
 		ATLENSURE( pch != NULL );
 
@@ -464,11 +464,13 @@ class CStringRefElementTraits :
 	public CElementTraitsBase< T >
 {
 public:
+	typedef typename T::PCXSTR INARGTYPE;
+
 	static ULONG Hash(_In_ INARGTYPE str)
 	{
 		ULONG nHash = 0;
 
-		const T::XCHAR* pch = str;
+		const typename T::XCHAR* pch = str;
 
 		ATLENSURE( pch != NULL );
 
@@ -1475,7 +1477,7 @@ CAtlList< E, ETraits >::CAtlList(_In_ UINT nBlockSize) throw() :
 }
 
 template< typename E, class ETraits >
-void CAtlList< E, ETraits >::RemoveAll()
+void CAtlList< E, ETraits >::RemoveAll() throw()
 {
 	while( m_nElements > 0 )
 	{
@@ -1715,7 +1717,7 @@ E CAtlList< E, ETraits >::RemoveHead()
 }
 
 template< typename E, class ETraits >
-void CAtlList< E, ETraits >::RemoveHeadNoReturn()
+void CAtlList< E, ETraits >::RemoveHeadNoReturn() throw()
 {
 	ATLENSURE( m_pHead != NULL );
 
@@ -1757,7 +1759,7 @@ E CAtlList< E, ETraits >::RemoveTail()
 }
 
 template< typename E, class ETraits >
-void CAtlList< E, ETraits >::RemoveTailNoReturn()
+void CAtlList< E, ETraits >::RemoveTailNoReturn() throw()
 {
 	ATLENSURE( m_pTail != NULL );
 
@@ -1834,7 +1836,7 @@ POSITION CAtlList< E, ETraits >::InsertAfter(
 }
 
 template< typename E, class ETraits >
-void CAtlList< E, ETraits >::RemoveAt(_In_ POSITION pos)
+void CAtlList< E, ETraits >::RemoveAt(_In_ POSITION pos) throw()
 {
 	ATLASSERT_VALID(this);
 	ATLENSURE( pos != NULL );
@@ -2158,7 +2160,7 @@ public:
 		_Out_ VOUTARGTYPE value) const;
 	const CPair* Lookup(/* _In_ */ KINARGTYPE key) const throw();
 	CPair* Lookup(/* _In_ */ KINARGTYPE key) throw();
-	V& operator[](/* _In_ */ KINARGTYPE key) throw(...);
+	V& operator[](/* _In_ */ KINARGTYPE key) noexcept(false);
 
 	POSITION SetAt(
 		/* _In_ */ KINARGTYPE key,
@@ -2240,7 +2242,7 @@ private:
 	CNode* CreateNode(
 		/* _In_ */ KINARGTYPE key,
 		_In_ UINT iBin,
-		_In_ UINT nHash) throw(...);
+		_In_ UINT nHash) noexcept(false);
 	void RemoveNode(
 		_In_ CNode* pNode,
 		_In_opt_ CNode* pPrev) throw();
@@ -2307,7 +2309,7 @@ inline bool CAtlMap< K, V, KTraits, VTraits >::IsEmpty() const throw()
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-inline V& CAtlMap< K, V, KTraits, VTraits >::operator[](/* _In_ */ KINARGTYPE key) throw(...)
+inline V& CAtlMap< K, V, KTraits, VTraits >::operator[](/* _In_ */ KINARGTYPE key) noexcept(false)
 {
 	CNode* pNode;
 	UINT iBin;
@@ -2448,7 +2450,7 @@ template< typename K, typename V, class KTraits, class VTraits >
 typename CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::CreateNode(
 	/* _In_ */ KINARGTYPE key,
 	_In_ UINT iBin,
-	_In_ UINT nHash) throw(...)
+	_In_ UINT nHash) noexcept(false)
 {
 	CNode* pNode;
 
@@ -2869,7 +2871,7 @@ bool CAtlMap< K, V, KTraits, VTraits >::RemoveKey(/* _In_ */ KINARGTYPE key) thr
 template< typename K, typename V, class KTraits, class VTraits >
 void CAtlMap< K, V, KTraits, VTraits >::RemoveNode(
 	_In_ CNode* pNode,
-	_In_opt_ CNode* pPrev)
+	_In_opt_ CNode* pPrev) throw()
 {
 	ATLENSURE( pNode != NULL );
 
@@ -2889,7 +2891,7 @@ void CAtlMap< K, V, KTraits, VTraits >::RemoveNode(
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-void CAtlMap< K, V, KTraits, VTraits >::RemoveAtPos(_In_ POSITION pos)
+void CAtlMap< K, V, KTraits, VTraits >::RemoveAtPos(_In_ POSITION pos) throw()
 {
 	ATLENSURE( pos != NULL );
 
@@ -3213,7 +3215,7 @@ private:
 
 	CNode* NewNode(
 		/* _In_ */ KINARGTYPE key,
-		/* _In_ */ VINARGTYPE value) throw( ... );
+		/* _In_ */ VINARGTYPE value) noexcept(false);
 	void FreeNode(_Inout_ CNode* pNode) throw();
 	void RemovePostOrder(_In_ CNode* pNode) throw();
 	CNode* LeftRotate(_In_ CNode* pNode) throw();
@@ -3223,7 +3225,7 @@ private:
 		_Inout_ CNode* pSrc) throw();
 	CNode* InsertImpl(
 		/* _In_ */ KINARGTYPE key,
-		/* _In_ */ VINARGTYPE value) throw( ... );
+		/* _In_ */ VINARGTYPE value) noexcept(false);
 	void RBDeleteFixup(_In_ CNode* pNode) throw();
 	bool RBDelete(_In_opt_ CNode* pZ) throw();
 
@@ -3253,7 +3255,7 @@ protected:
 	CNode* Successor(_In_opt_ CNode* pNode) const throw();
 	CNode* RBInsert(
 		/* _In_ */ KINARGTYPE key,
-		/* _In_ */ VINARGTYPE value) throw( ... );
+		/* _In_ */ VINARGTYPE value) noexcept(false);
 	CNode* Find(/* _In_ */ KINARGTYPE key) const throw();
 	CNode* FindPrefix(/* _In_ */ KINARGTYPE key) const throw();
 
@@ -3311,7 +3313,7 @@ inline bool CRBTree< K, V, KTraits, VTraits >::IsNil(_In_ CNode *p) const throw(
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-inline void CRBTree< K, V, KTraits, VTraits >::SetNil(_Deref_out_ CNode **p)
+inline void CRBTree< K, V, KTraits, VTraits >::SetNil(_Deref_out_ CNode **p) throw()
 {
 	ATLENSURE( p != NULL );
 	*p = m_pNil;
@@ -3540,7 +3542,7 @@ void CRBTree< K, V, KTraits, VTraits >::SetValueAt(
 template< typename K, typename V, class KTraits, class VTraits >
 typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::NewNode(
 	/* _In_ */ KINARGTYPE key,
-	/* _In_ */ VINARGTYPE value) throw( ... )
+	/* _In_ */ VINARGTYPE value) noexcept(false)
 {
 	if( m_pFree == NULL )
 	{
@@ -3589,7 +3591,7 @@ typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTrai
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-void CRBTree< K, V, KTraits, VTraits >::FreeNode(_Inout_ CNode* pNode)
+void CRBTree< K, V, KTraits, VTraits >::FreeNode(_Inout_ CNode* pNode) throw()
 {
 	ATLENSURE( pNode != NULL );
 	pNode->~CNode();
@@ -3775,7 +3777,7 @@ typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTrai
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-void CRBTree< K, V, KTraits, VTraits >::SwapNode(_Out_ CNode* pDest, _Inout_ CNode* pSrc)
+void CRBTree< K, V, KTraits, VTraits >::SwapNode(_Out_ CNode* pDest, _Inout_ CNode* pSrc) throw()
 {
 	ATLENSURE( pDest != NULL );
 	ATLENSURE( pSrc != NULL );
@@ -3805,7 +3807,7 @@ void CRBTree< K, V, KTraits, VTraits >::SwapNode(_Out_ CNode* pDest, _Inout_ CNo
 template< typename K, typename V, class KTraits, class VTraits >
 typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::InsertImpl(
 	/* _In_ */ KINARGTYPE key,
-	/* _In_ */ VINARGTYPE value) throw( ... )
+	/* _In_ */ VINARGTYPE value) noexcept(false)
 {
 	CNode* pNew = NewNode( key, value );
 
@@ -3835,7 +3837,7 @@ typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTrai
 }
 
 template< typename K, typename V, class KTraits, class VTraits >
-void CRBTree< K, V, KTraits, VTraits >::RBDeleteFixup(_In_ CNode* pNode)
+void CRBTree< K, V, KTraits, VTraits >::RBDeleteFixup(_In_ CNode* pNode) throw()
 {
 	ATLENSURE( pNode != NULL );
 
@@ -4048,7 +4050,7 @@ typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTrai
 template< typename K, typename V, class KTraits, class VTraits >
 typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::RBInsert(
 	/* _In_ */ KINARGTYPE key,
-	/* _In_ */ VINARGTYPE value) throw( ... )
+	/* _In_ */ VINARGTYPE value) noexcept(false)
 {
 	CNode* pNewNode = InsertImpl( key, value );
 
@@ -4185,17 +4187,22 @@ class CRBMap :
 	public CRBTree< K, V, KTraits, VTraits >
 {
 public:
+	typedef typename KTraits::INARGTYPE KINARGTYPE;
+	typedef typename VTraits::INARGTYPE VINARGTYPE;
+	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;
+	typedef typename CRBTree< K, V, KTraits, VTraits >::CPair CPair;
+
 	explicit CRBMap(_In_ size_t nBlockSize = 10) throw();
 	~CRBMap() throw();
 
 	bool Lookup(
 		/* _In_ */ KINARGTYPE key,
-		_Out_ VOUTARGTYPE value) const throw( ... );
+		_Out_ VOUTARGTYPE value) const noexcept(false);
 	const CPair* Lookup(/* _In_ */ KINARGTYPE key) const throw();
 	CPair* Lookup(/* _In_ */ KINARGTYPE key) throw();
 	POSITION SetAt(
 		/* _In_ */ KINARGTYPE key,
-		/* _In_ */ VINARGTYPE value) throw( ... );
+		/* _In_ */ VINARGTYPE value) noexcept(false);
 	bool RemoveKey(/* _In_ */ KINARGTYPE key) throw();
 };
 
@@ -4227,7 +4234,7 @@ typename CRBMap< K, V, KTraits, VTraits >::CPair* CRBMap< K, V, KTraits, VTraits
 template< typename K, typename V, class KTraits, class VTraits >
 bool CRBMap< K, V, KTraits, VTraits >::Lookup(
 	/* _In_ */ KINARGTYPE key,
-	_Out_ VOUTARGTYPE value) const throw( ... )
+	_Out_ VOUTARGTYPE value) const noexcept(false)
 {
 	const CPair* pLookup = Find( key );
 	if( pLookup == NULL )
@@ -4240,7 +4247,7 @@ bool CRBMap< K, V, KTraits, VTraits >::Lookup(
 template< typename K, typename V, class KTraits, class VTraits >
 POSITION CRBMap< K, V, KTraits, VTraits >::SetAt(
 	/* _In_ */ KINARGTYPE key,
-	/* _In_ */ VINARGTYPE value) throw( ... )
+	/* _In_ */ VINARGTYPE value) noexcept(false)
 {
 	CPair* pNode = Find( key );
 	if( pNode == NULL )
@@ -4261,7 +4268,7 @@ bool CRBMap< K, V, KTraits, VTraits >::RemoveKey(/* _In_ */ KINARGTYPE key) thro
 	POSITION pos = Lookup( key );
 	if( pos != NULL )
 	{
-		RemoveAt( pos );
+		CRBTree< K, V, KTraits, VTraits >::RemoveAt( pos );
 
 		return( true );
 	}
@@ -4276,12 +4283,16 @@ class CRBMultiMap :
 	public CRBTree< K, V, KTraits, VTraits >
 {
 public:
+	typedef typename KTraits::INARGTYPE KINARGTYPE;
+	typedef typename VTraits::INARGTYPE VINARGTYPE;
+	typedef typename CRBTree< K, V, KTraits, VTraits >::CPair CPair;
+
 	explicit CRBMultiMap(_In_ size_t nBlockSize = 10) throw();
 	~CRBMultiMap() throw();
 
 	POSITION Insert(
 		/* _In_ */ KINARGTYPE key,
-		/* _In_ */ VINARGTYPE value) throw( ... );
+		/* _In_ */ VINARGTYPE value) noexcept(false);
 	size_t RemoveKey(/* _In_ */ KINARGTYPE key) throw();
 
 	POSITION FindFirstWithKey(/* _In_ */ KINARGTYPE key) const throw();
@@ -4313,7 +4324,7 @@ CRBMultiMap< K, V, KTraits, VTraits >::~CRBMultiMap() throw()
 template< typename K, typename V, class KTraits, class VTraits >
 POSITION CRBMultiMap< K, V, KTraits, VTraits >::Insert(
 	/* _In_ */ KINARGTYPE key,
-	/* _In_ */ VINARGTYPE value) throw( ... )
+	/* _In_ */ VINARGTYPE value) noexcept(false)
 {
 	return( RBInsert( key, value ) );
 }
@@ -4329,7 +4340,7 @@ size_t CRBMultiMap< K, V, KTraits, VTraits >::RemoveKey(
 	{
 		POSITION posDelete = pos;
 		GetNextWithKey( pos, key );
-		RemoveAt( posDelete );
+		CRBTree< K, V, KTraits, VTraits >::RemoveAt( posDelete );
 		nElementsDeleted++;
 	}
 
@@ -4349,7 +4360,7 @@ const typename CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V,
 	/* _In_ */ KINARGTYPE key) const throw()
 {
 	ATLASSERT( pos != NULL );
-	const CPair* pNode = GetNext( pos );
+	const CPair* pNode = CRBTree< K, V, KTraits, VTraits >::GetNext( pos );
 	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
 	{
 		pos = NULL;
@@ -4364,7 +4375,7 @@ typename CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V, KTrait
 	/* _In_ */ KINARGTYPE key) throw()
 {
 	ATLASSERT( pos != NULL );
-	CPair* pNode = GetNext( pos );
+	CPair* pNode = CRBTree< K, V, KTraits, VTraits >::GetNext( pos );
 	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
 	{
 		pos = NULL;
diff --git a/include/atlcom.h b/include/atlcom.h
index 49d412b..1276e34 100644
--- a/include/atlcom.h
+++ b/include/atlcom.h
@@ -491,14 +491,14 @@ struct AtlExpectedDispatchOrUnknown
 #endif
 
 #define PROP_ENTRY(szDesc, dispid, clsid) \
-		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), NULL, 0, dispid, 0, 0, VT_EMPTY},
+		{OLESTR(szDesc), &clsid, &IID_IDispatch, NULL, 0, dispid, 0, 0, VT_EMPTY},
 
 #define PROP_ENTRY_INTERFACE(szDesc, dispid, clsid, rgclsidAllowed, cclsidAllowed, vt) \
-		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), rgclsidAllowed, cclsidAllowed, dispid, 0, 0, \
+		{OLESTR(szDesc), &clsid, &IID_IDispatch, rgclsidAllowed, cclsidAllowed, dispid, 0, 0, \
 		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
 		
 #define PROP_ENTRY_INTERFACE_CALLBACK(szDesc, dispid, clsid, pfnFunc, vt) \
-		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), reinterpret_cast<const CLSID *>(pfnFunc), 0, dispid, 0, 0, \
+		{OLESTR(szDesc), &clsid, &IID_IDispatch, reinterpret_cast<const CLSID *>(pfnFunc), 0, dispid, 0, 0, \
 		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
 
 #define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
@@ -513,7 +513,7 @@ struct AtlExpectedDispatchOrUnknown
 		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
 		
 #define PROP_ENTRY_TYPE(szDesc, dispid, clsid, vt) \
-		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), NULL, 0, dispid, 0, 0, vt},
+		{OLESTR(szDesc), &clsid, &IID_IDispatch, NULL, 0, dispid, 0, 0, vt},
 
 #define PROP_ENTRY_TYPE_EX(szDesc, dispid, clsid, iidDispatch, vt) \
 		{OLESTR(szDesc), &clsid, &iidDispatch, NULL, 0, dispid, 0, 0, vt},
@@ -822,8 +822,8 @@ IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
 {
 	T* pT = static_cast<T*>(this);
 	IPersistStreamInit* p;
-	if (FAILED(pT->GetUnknown()->QueryInterface(__uuidof(IPersistStreamInit), (void**)&p)))
-		pT->_InternalQueryInterface(__uuidof(IPersistStreamInit), (void**)&p);
+	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
+		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
 	return p;
 }
 
@@ -1032,7 +1032,7 @@ inline CSecurityDescriptor::CSecurityDescriptor()
 
 inline CSecurityDescriptor::~CSecurityDescriptor()
 {
-	delete m_pSD;
+	delete (SECURITY_DESCRIPTOR*)m_pSD;
 	free(m_pOwner);
 	free(m_pGroup);
 	free(m_pDACL);
@@ -1041,7 +1041,7 @@ inline CSecurityDescriptor::~CSecurityDescriptor()
 
 inline HRESULT CSecurityDescriptor::Initialize()
 {
-	delete m_pSD;
+	delete (SECURITY_DESCRIPTOR*)m_pSD;
 	m_pSD = NULL;
 
 	free(m_pOwner);
@@ -1063,7 +1063,7 @@ inline HRESULT CSecurityDescriptor::Initialize()
 			return S_OK;
 
 		HRESULT hr = AtlHresultFromLastError();
-		delete m_pSD;
+		delete (SECURITY_DESCRIPTOR*)m_pSD;
 		m_pSD = NULL;
 		ATLASSERT(FALSE);
 		return hr;
@@ -1664,7 +1664,7 @@ inline HRESULT CSecurityDescriptor::Attach(_In_ PSECURITY_DESCRIPTOR pSelfRelati
 		free(m_pSACL);
 		m_pSACL = NULL;
 
-		delete m_pSD;
+		delete (SECURITY_DESCRIPTOR*)m_pSD;
 	 	m_pSD = NULL;
 	}
 
@@ -1968,8 +1968,8 @@ _Error_CloseHandle:
 // COM Objects
 
 #define DECLARE_PROTECT_FINAL_CONSTRUCT()\
-	void InternalFinalConstructAddRef() {InternalAddRef();}\
-	void InternalFinalConstructRelease() {InternalRelease();}
+	void InternalFinalConstructAddRef() {this->InternalAddRef();}\
+	void InternalFinalConstructRelease() {this->InternalRelease();}
 
 ATLPREFAST_SUPPRESS(6387)
 template <class T1>
@@ -2165,7 +2165,7 @@ public:
 		// Add the following line to your object if you get a message about
 		// GetControllingUnknown() being undefined
 		// DECLARE_GET_CONTROLLING_UNKNOWN()
-		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, __uuidof(IUnknown), ppv);
+		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
 	}
 };
 
@@ -2216,7 +2216,7 @@ public:
 		_In_ REFIID iid, \
 		_Deref_out_ void** ppvObject) throw() \
 	{ \
-		return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); \
+		return this->InternalQueryInterface(this, _GetEntries(), iid, ppvObject); \
 	} \
 	const static ATL::_ATL_INTMAP_ENTRY* WINAPI _GetEntries() throw() { \
 	static const ATL::_ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)
@@ -2260,12 +2260,12 @@ public:
 
 #define COM_INTERFACE_ENTRY2(x, x2)\
 	{&_ATL_IIDOF(x),\
-	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(8))))-8,\
+	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(_ATL_PACKING)))) - _ATL_PACKING,\
 	_ATL_SIMPLEMAPENTRY},
 
 #define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
 	{&iid,\
-	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(8))))-8,\
+	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(_ATL_PACKING)))) - _ATL_PACKING,\
 	_ATL_SIMPLEMAPENTRY},
 
 #define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
@@ -2559,7 +2559,7 @@ public:
 		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
 		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
 		if (*pp == NULL)
-			hRes = pcd->pFunc(pv, __uuidof(IUnknown), (void**)pp);
+			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
 		if (*pp != NULL)
 			hRes = (*pp)->QueryInterface(iid, ppvObject);
 		return hRes;
@@ -2711,7 +2711,7 @@ public:
 
 typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;
 
-#if defined(_WINDLL) | defined(_USRDLL)
+#if defined(_WINDLL) || defined(_USRDLL)
 #define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectCached< cf > > _ClassFactoryCreatorClass;
 #else
 // don't let class factory refcount influence lock count
@@ -2855,8 +2855,8 @@ public:
 	// also catch mismatched Release in debug builds
 	virtual ~CComObject() throw()
 	{
-		m_dwRef = -(LONG_MAX/2);
-		FinalRelease();
+		long m_dwRef = -(LONG_MAX/2);
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -2864,13 +2864,13 @@ public:
 	}
 	//If InternalAddRef or InternalRelease is undefined then your class
 	//doesn't derive from CComObjectRoot
-	STDMETHOD_(ULONG, AddRef)() 
+	STDMETHOD_(ULONG, AddRef)() throw()
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
-	STDMETHOD_(ULONG, Release)()
+	STDMETHOD_(ULONG, Release)() throw()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -2880,7 +2880,7 @@ public:
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return _InternalQueryInterface(iid, ppvObject);
+		return this->_InternalQueryInterface(iid, ppvObject);
 	}
 	template <class Q>
 	HRESULT STDMETHODCALLTYPE QueryInterface(
@@ -2943,8 +2943,8 @@ public:
 	// also catch mismatched Release in debug builds
 	virtual ~CComObjectCached()
 	{
-		m_dwRef = -(LONG_MAX/2);
-		FinalRelease();
+		long m_dwRef = -(LONG_MAX/2);
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -2953,14 +2953,14 @@ public:
 	//doesn't derive from CComObjectRoot
 	STDMETHOD_(ULONG, AddRef)() throw()
 	{
-		ULONG l = InternalAddRef();
+		ULONG l = this->InternalAddRef();
 		if (l == 2)
 			_pAtlModule->Lock();
 		return l;
 	}
 	STDMETHOD_(ULONG, Release)() throw()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		else if (l == 1)
@@ -2972,7 +2972,7 @@ public:
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return _InternalQueryInterface(iid, ppvObject);
+		return this->_InternalQueryInterface(iid, ppvObject);
 	}
 	static HRESULT WINAPI CreateInstance(
 		_Deref_out_ CComObjectCached<Base>** pp) throw();
@@ -3029,8 +3029,8 @@ public:
 
 	virtual ~CComObjectNoLock()
 	{
-		m_dwRef = -(LONG_MAX/2);
-		FinalRelease();
+		long m_dwRef = -(LONG_MAX/2);
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -3040,11 +3040,11 @@ public:
 	//doesn't derive from CComObjectRoot
 	STDMETHOD_(ULONG, AddRef)() throw() 
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
 	STDMETHOD_(ULONG, Release)() throw()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -3054,7 +3054,7 @@ public:
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return _InternalQueryInterface(iid, ppvObject);
+		return this->_InternalQueryInterface(iid, ppvObject);
 	}
 };
 
@@ -3074,14 +3074,14 @@ public:
 		{
 			__if_exists(InternalFinalConstructAddRef)
 			{
-				InternalFinalConstructAddRef();
+				this->InternalFinalConstructAddRef();
 			}
-			m_hResFinalConstruct = _AtlInitialConstruct();
+			m_hResFinalConstruct = this->_AtlInitialConstruct();
 			if (SUCCEEDED(m_hResFinalConstruct))
-				m_hResFinalConstruct = FinalConstruct();
+				m_hResFinalConstruct = this->FinalConstruct();
 			__if_exists(InternalFinalConstructRelease)
 			{
-				InternalFinalConstructRelease();
+				this->InternalFinalConstructRelease();
 			}
 		}
 	}
@@ -3089,7 +3089,7 @@ public:
 	{
 		__if_exists(FinalRelease)
 		{
-			FinalRelease();
+			this->FinalRelease();
 		}
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
@@ -3108,7 +3108,7 @@ public:
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return _InternalQueryInterface(iid, ppvObject);
+		return this->_InternalQueryInterface(iid, ppvObject);
 	}
 	HRESULT m_hResFinalConstruct;
 };
@@ -3123,13 +3123,13 @@ public:
 	typedef Base _BaseClass;
 	CComObjectStack(_In_opt_ void* = NULL)
 	{
-		m_hResFinalConstruct = _AtlInitialConstruct();
+		m_hResFinalConstruct = this->_AtlInitialConstruct();
 		if (SUCCEEDED(m_hResFinalConstruct))
-			m_hResFinalConstruct = FinalConstruct();
+			m_hResFinalConstruct = this->FinalConstruct();
 	}
 	virtual ~CComObjectStack()
 	{
-		FinalRelease();
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -3166,11 +3166,11 @@ public:
 	CComObjectStackEx(_In_opt_ void* = NULL) 
 	{ 
 #ifdef _DEBUG
-		m_dwRef = 0;
+		long m_dwRef = 0;
 #endif
-		m_hResFinalConstruct = _AtlInitialConstruct();
+		m_hResFinalConstruct = this->_AtlInitialConstruct();
 		if (SUCCEEDED(m_hResFinalConstruct))
-			m_hResFinalConstruct = FinalConstruct(); 
+			m_hResFinalConstruct = this->FinalConstruct(); 
 	}
 
 	virtual ~CComObjectStackEx()
@@ -3182,7 +3182,7 @@ public:
 		// by some other means that the object remains 
 		// alive while clients have references to its interfaces.
 		ATLASSUME(m_dwRef == 0);
-		FinalRelease();
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -3191,7 +3191,7 @@ public:
 	STDMETHOD_(ULONG, AddRef)() throw()
 	{
 #ifdef _DEBUG
-		return InternalAddRef();
+		return this->InternalAddRef();
 #else
 		return 0;
 #endif
@@ -3200,7 +3200,7 @@ public:
 	STDMETHOD_(ULONG, Release)() throw()
 	{
 #ifdef _DEBUG
-		return InternalRelease();
+		return this->InternalRelease();
 #else
 		return 0;
 #endif
@@ -3210,7 +3210,7 @@ public:
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return _InternalQueryInterface(iid, ppvObject);
+		return this->_InternalQueryInterface(iid, ppvObject);
 	}
 
 	HRESULT m_hResFinalConstruct;
@@ -3229,24 +3229,24 @@ public:
 #ifdef _ATL_DEBUG_INTERFACES
 	virtual ~CComContainedObject()
 	{
-		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
+		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this->_GetRawUnknown());
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(m_pOuterUnknown);
 	}
 #endif
 
 	STDMETHOD_(ULONG, AddRef)() throw() 
 	{
-		return OuterAddRef();
+		return this->OuterAddRef();
 	}
 	STDMETHOD_(ULONG, Release)() throw() 
 	{
-		return OuterRelease();
+		return this->OuterRelease();
 	}
 	STDMETHOD(QueryInterface)(
 		_In_ REFIID iid, 
 		_Deref_out_ void** ppvObject) throw()
 	{
-		return OuterQueryInterface(iid, ppvObject);
+		return this->OuterQueryInterface(iid, ppvObject);
 	}
 	template <class Q>
 	HRESULT STDMETHODCALLTYPE QueryInterface(
@@ -3266,6 +3266,7 @@ public:
 		return m_pOuterUnknown;
 #endif
 	}
+	IUnknown* m_pOuterUnknown;
 };
 
 //contained is the user's class that derives from CComObjectRoot and whatever
@@ -3295,19 +3296,19 @@ public:
 	// override it in your class and call each base class' version of this
 	HRESULT FinalConstruct()
 	{
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
 		return m_contained.FinalConstruct();
 	}
 	void FinalRelease()
 	{
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
 		m_contained.FinalRelease();
 	}
 	// Set refcount to -(LONG_MAX/2) to protect destruction and 
 	// also catch mismatched Release in debug builds
 	virtual ~CComAggObject()
 	{
-		m_dwRef = -(LONG_MAX/2);
+		long m_dwRef = -(LONG_MAX/2);
 		FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
@@ -3317,11 +3318,11 @@ public:
 
 	STDMETHOD_(ULONG, AddRef)() 
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
 	STDMETHOD_(ULONG, Release)()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -3414,22 +3415,22 @@ public:
 	// override it in your class and call each base class' version of this
 	HRESULT FinalConstruct()
 	{
-		InternalAddRef();
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
+		this->InternalAddRef();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
 		HRESULT hr = m_contained.FinalConstruct();
-		InternalRelease();
+		this->InternalRelease();
 		return hr;
 	}
 	void FinalRelease()
 	{
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
 		m_contained.FinalRelease();
 	}
 	// Set refcount to -(LONG_MAX/2) to protect destruction and 
 	// also catch mismatched Release in debug builds
 	virtual ~CComPolyObject()
 	{
-		m_dwRef = -(LONG_MAX/2);
+		long m_dwRef = -(LONG_MAX/2);
 		FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
@@ -3439,11 +3440,11 @@ public:
 
 	STDMETHOD_(ULONG, AddRef)() 
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
 	STDMETHOD_(ULONG, Release)()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -3523,15 +3524,15 @@ public:
 	CComTearOffObject(_In_ void* pv)
 	{
 		ATLASSUME(m_pOwner == NULL);
-		m_pOwner = reinterpret_cast<Base::_OwnerClass*>(pv);
+		m_pOwner = reinterpret_cast<typename Base::_OwnerClass*>(pv);
 		m_pOwner->AddRef();
 	}
 	// Set refcount to -(LONG_MAX/2) to protect destruction and 
 	// also catch mismatched Release in debug builds
 	virtual ~CComTearOffObject()
 	{
-		m_dwRef = -(LONG_MAX/2);
-		FinalRelease();
+		long m_dwRef = -(LONG_MAX/2);
+		this->FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
 #endif
@@ -3540,11 +3541,11 @@ public:
 
 	STDMETHOD_(ULONG, AddRef)() throw() 
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
 	STDMETHOD_(ULONG, Release)() throw()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -3555,6 +3556,7 @@ public:
 	{
 		return m_pOwner->QueryInterface(iid, ppvObject);
 	}
+	IUnknown* m_pOwner;
 };
 
 template <class contained>
@@ -3565,10 +3567,10 @@ class CComCachedTearOffObject :
 public:
 	typedef contained _BaseClass;
 	CComCachedTearOffObject(_In_ void* pv) :
-		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
+		m_contained(((typename contained::_OwnerClass*)pv)->GetControllingUnknown())
 	{
 		ATLASSUME(m_contained.m_pOwner == NULL);
-		m_contained.m_pOwner = reinterpret_cast<contained::_OwnerClass*>(pv);
+		m_contained.m_pOwner = reinterpret_cast<typename contained::_OwnerClass*>(pv);
 	}
 	HRESULT _AtlInitialConstruct()
 	{
@@ -3583,19 +3585,19 @@ public:
 	// override it in your class and call each base class' version of this
 	HRESULT FinalConstruct()
 	{
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
 		return m_contained.FinalConstruct();
 	}
 	void FinalRelease()
 	{
-		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
+		CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
 		m_contained.FinalRelease();
 	}
 	// Set refcount to -(LONG_MAX/2) to protect destruction and 
 	// also catch mismatched Release in debug builds
 	virtual ~CComCachedTearOffObject()
 	{
-		m_dwRef = -(LONG_MAX/2);
+		long m_dwRef = -(LONG_MAX/2);
 		FinalRelease();
 #ifdef _ATL_DEBUG_INTERFACES
 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
@@ -3604,11 +3606,11 @@ public:
 
 	STDMETHOD_(ULONG, AddRef)() 
 	{
-		return InternalAddRef();
+		return this->InternalAddRef();
 	}
 	STDMETHOD_(ULONG, Release)()
 	{
-		ULONG l = InternalRelease();
+		ULONG l = this->InternalRelease();
 		if (l == 0)
 			delete this;
 		return l;
@@ -3702,7 +3704,13 @@ class CComClassFactory2 :
 {
 public:
 	typedef license _LicenseClass;
+#ifdef _MSC_VER
 	typedef CComClassFactory2<license> _ComMapClass;
+#else
+	BOOL GetLicenseKey(DWORD dwReserved, BSTR* pbstrKey);
+	BOOL VerifyLicenseKey(BSTR bstrKey);
+	BOOL IsLicenseValid();
+#endif
 BEGIN_COM_MAP(CComClassFactory2<license>)
 	COM_INTERFACE_ENTRY(IClassFactory)
 	COM_INTERFACE_ENTRY(IClassFactory2)
@@ -3825,7 +3833,7 @@ ATLPREFAST_SUPPRESS(6387)
 				if (_pAtlAutoThreadModule == NULL)
 					return E_FAIL;
 
-				hRes = _pAtlAutoThreadModule->CreateInstance(m_pfnCreateInstance, riid, ppvObj);
+				hRes = _pAtlAutoThreadModule->CreateInstance((PVOID)m_pfnCreateInstance, riid, ppvObj);
 			}
 		}		
 		return hRes;
@@ -4291,7 +4299,7 @@ inline HRESULT CComTypeInfoHolder::GetTI(_In_ LCID lcid)
 			{
 				CComPtr<ITypeInfo> spInfo(spTypeInfo);
 				CComPtr<ITypeInfo2> spTypeInfo2;
-				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
+				if (SUCCEEDED(spTypeInfo->QueryInterface(IID_ITypeInfo2, (void**)&spTypeInfo2)))
 					spInfo = spTypeInfo2;
 
 				m_pInfo = spInfo.Detach();
@@ -4363,7 +4371,7 @@ public:
 
 		HRESULT hr;
 		CComPtr<IObjectWithSite> spChildSite;
-		hr = punkChild->QueryInterface(__uuidof(IObjectWithSite), (void**)&spChildSite);
+		hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&spChildSite);
 		if (SUCCEEDED(hr))
 			hr = spChildSite->SetSite((IUnknown*)this);
 
@@ -4411,7 +4419,7 @@ public:
 			return QueryInterface(riid, ppvObject);
 
 #define SERVICE_ENTRY_CHAIN(x) \
-		ATL::CComQIPtr<IServiceProvider, &__uuidof(IServiceProvider)> spProvider(x); \
+		ATL::CComQIPtr<IServiceProvider, &IID_IServiceProvider> spProvider(x); \
 		if (spProvider != NULL) \
 			return spProvider->QueryService(guidService, riid, ppvObject);
 
@@ -4553,11 +4561,15 @@ class ATL_NO_VTABLE _IDispEventLocator :
 public:
 };
 
+template <class T> struct _ATL_EVENT_ENTRY;
+
 template <UINT nID, class T, const IID* pdiid>
 class ATL_NO_VTABLE IDispEventSimpleImpl : 
 	public _IDispEventLocator<nID, pdiid>
 {
 public:
+	IID m_iid;
+	DWORD m_dwEventCookie;
 	STDMETHOD(_LocDEQueryInterface)(
 		_In_ REFIID riid, 
 		_Deref_out_ void** ppvObject)
@@ -4572,7 +4584,7 @@ public:
 
 		if (InlineIsEqualGUID(riid, *pdiid) || 
 			InlineIsEqualUnknown(riid) ||
-			InlineIsEqualGUID(riid, __uuidof(IDispatch)) ||
+			InlineIsEqualGUID(riid, IID_IDispatch) ||
 			InlineIsEqualGUID(riid, m_iid))
 		{
 			*ppvObject = this;
@@ -4980,6 +4992,10 @@ public:
 	}
 
 	//Helper for finding the function index for a DISPID
+	GUID m_libid; // used for dynamic case
+	IID m_iid; // used for dynamic case
+	unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
+	unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
 	HRESULT GetFuncInfoFromId(
 		_In_ const IID& iid, 
 		_In_ DISPID dispidMember, 
@@ -5522,36 +5538,6 @@ STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(_In_ ULONG celt)
 	return (celt == nSkip) ? S_OK : S_FALSE;
 }
 
-ATLPREFAST_SUPPRESS(6387)
-template <class Base, const IID* piid, class T, class Copy>
-STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(
-	_Deref_out_ Base** ppEnum)
-{
-	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
-	HRESULT hRes = E_POINTER;
-	if (ppEnum != NULL)
-	{
-		*ppEnum = NULL;
-		_class* p;
-		hRes = _class::CreateInstance(&p);
-		if (SUCCEEDED(hRes))
-		{		
-			// If this object has ownership of the data then we need to keep it around
-			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);
-			if (SUCCEEDED(hRes))
-			{
-				p->m_iter = m_iter;
-				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
-			}
-			if (FAILED(hRes))
-				delete p;
-		}
-	}
-		
-	return hRes;
-}
-ATLPREFAST_UNSUPPRESS()
-
 template <class Base, const IID* piid, class T, class Copy>
 HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(
 	_In_ T* begin, 
@@ -5607,6 +5593,37 @@ public:
 	END_COM_MAP()
 };
 
+ATLPREFAST_SUPPRESS(6387)
+template <class Base, const IID* piid, class T, class Copy>
+STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(
+	_Deref_out_ Base** ppEnum)
+{
+	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
+	HRESULT hRes = E_POINTER;
+	if (ppEnum != NULL)
+	{
+		*ppEnum = NULL;
+		_class* p;
+		hRes = _class::CreateInstance(&p);
+		if (SUCCEEDED(hRes))
+		{		
+			// If this object has ownership of the data then we need to keep it around
+			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);
+			if (SUCCEEDED(hRes))
+			{
+				p->m_iter = m_iter;
+				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
+			}
+			if (FAILED(hRes))
+				delete p;
+		}
+	}
+		
+	return hRes;
+}
+ATLPREFAST_UNSUPPRESS()
+
+
 template <class Base, const IID* piid, class T, class Copy, class CollType>
 class ATL_NO_VTABLE IEnumOnSTLImpl : 
 	public Base
@@ -5699,6 +5716,20 @@ STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Skip(_In_ ULONG celt
 	return hr;
 }
 
+
+template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
+class ATL_NO_VTABLE CComEnumOnSTL :
+	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType>,
+	public CComObjectRootEx< ThreadModel >
+{
+public:
+	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
+	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType > _CComEnumBase;
+	BEGIN_COM_MAP(_CComEnum)
+		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
+	END_COM_MAP()
+};
+
 template <class Base, const IID* piid, class T, class Copy, class CollType>
 STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Clone(
 	_Deref_out_ Base** ppEnum)
@@ -5725,18 +5756,6 @@ STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Clone(
 	return hRes;
 }
 
-template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
-class ATL_NO_VTABLE CComEnumOnSTL :
-	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType>,
-	public CComObjectRootEx< ThreadModel >
-{
-public:
-	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
-	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType > _CComEnumBase;
-	BEGIN_COM_MAP(_CComEnum)
-		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
-	END_COM_MAP()
-};
 
 template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
 class ICollectionOnSTLImpl : 
@@ -5764,7 +5783,7 @@ public:
 			return E_INVALIDARG;
 		HRESULT hr = E_FAIL;
 		Index--;
-		CollType::const_iterator iter = m_coll.begin();
+		typename CollType::const_iterator iter = m_coll.begin();
 		while (iter != m_coll.end() && Index > 0)
 		{
 			iter++;
@@ -5786,7 +5805,7 @@ public:
 		{
 			hRes = p->Init(this, m_coll);
 			if (hRes == S_OK)
-				hRes = p->QueryInterface(__uuidof(IUnknown), (void**)ppUnk);
+				hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
 		}
 		if (hRes != S_OK)
 			delete p;
@@ -6185,7 +6204,9 @@ inline DWORD CComDynamicUnkArray::Add(_In_ IUnknown* pUnk)
 #else
 	int nAlloc = m_nSize*2;
 #endif
+#if __MSVCRT_VERSION__ >= 0x900
 	pp = (IUnknown**)_recalloc(m_ppUnk, sizeof(IUnknown*),nAlloc);
+#endif
 	if (pp == NULL)
 		return 0;
 	m_ppUnk = pp;
@@ -6230,7 +6251,7 @@ template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
 class ATL_NO_VTABLE IConnectionPointImpl : 
 	public _ICPLocator<piid>
 {
-	typedef CComEnum<IEnumConnections, &__uuidof(IEnumConnections), CONNECTDATA,
+	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
 		_Copy<CONNECTDATA> > CComEnumConnections;
 	typedef CDV _CDV;
 public:
@@ -6247,10 +6268,10 @@ ATLPREFAST_SUPPRESS(6387)
 			return E_POINTER;
 		*ppvObject = NULL;
 
-		if (InlineIsEqualGUID(riid, __uuidof(IConnectionPoint)) || InlineIsEqualUnknown(riid))
+		if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualUnknown(riid))
 		{
 			*ppvObject = this;
-			AddRef();
+			this->AddRef();
 #ifdef _ATL_DEBUG_INTERFACES
 			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
 #endif // _ATL_DEBUG_INTERFACES
@@ -6273,7 +6294,7 @@ ATLPREFAST_UNSUPPRESS()
 	{
 		T* pT = static_cast<T*>(this);
 		// No need to check ppCPC for NULL since QI will do that for us
-		return pT->QueryInterface(__uuidof(IConnectionPointContainer), (void**)ppCPC);
+		return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
 	}
 	STDMETHOD(Advise)(
 		_Inout_ IUnknown* pUnkSink, 
@@ -6315,7 +6336,7 @@ STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(
 	{
 		pT->Lock();
 		*pdwCookie = m_vec.Add(p);
-		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
+		hRes = (*pdwCookie != 0) ? S_OK : CONNECT_E_ADVISELIMIT;
 		pT->Unlock();
 		if (hRes != S_OK)
 			p->Release();
@@ -6377,7 +6398,7 @@ STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
 	// don't copy the data, but transfer ownership to it
 	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
 	pT->Unlock();
-	HRESULT hRes = pEnum->_InternalQueryInterface(__uuidof(IEnumConnections), (void**)ppEnum);
+	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
 	if (FAILED(hRes))
 		delete pEnum;
 	return hRes;
@@ -6391,7 +6412,7 @@ class ATL_NO_VTABLE IConnectionPointContainerImpl :
 	public IConnectionPointContainer
 {
 	typedef CComEnum<IEnumConnectionPoints,
-		&__uuidof(IEnumConnectionPoints), IConnectionPoint*,
+		&IID_IEnumConnectionPoints, IConnectionPoint*,
 		_CopyInterface<IConnectionPoint> >
 		CComEnumConnectionPoints;
 public:
@@ -6451,7 +6472,7 @@ ATLPREFAST_SUPPRESS(6014 6211 6387)
 			delete pEnum;
 			return hRes;
 		}
-		hRes = pEnum->QueryInterface(__uuidof(IEnumConnectionPoints), (void**)ppEnum);
+		hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
 		if (FAILED(hRes))
 			delete pEnum;
 				
@@ -6613,7 +6634,7 @@ ATLINLINE ATLAPI AtlSetErrorInfo(
 		}
 		CoTaskMemFree(lpsz);
 		pICEI->SetDescription((LPOLESTR)lpszDesc);
-		if (SUCCEEDED(pICEI->QueryInterface(__uuidof(IErrorInfo), (void**)&pErrorInfo)))
+		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
 			SetErrorInfo(0, pErrorInfo);
 	}
 	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
@@ -7048,7 +7069,7 @@ ATLINLINE ATLAPI AtlGetObjectSourceInterface(
 	if (punkObj != NULL)
 	{
 		CComPtr<IDispatch> spDispatch;
-		hr = punkObj->QueryInterface(__uuidof(IDispatch), (void**)&spDispatch);
+		hr = punkObj->QueryInterface(IID_IDispatch, (void**)&spDispatch);
 		if (SUCCEEDED(hr))
 		{
 			CComPtr<ITypeInfo> spTypeInfo;
@@ -7070,7 +7091,7 @@ ATLINLINE ATLAPI AtlGetObjectSourceInterface(
 						// First see if the object is willing to tell us about the
 						// default source interface via IProvideClassInfo2
 						CComPtr<IProvideClassInfo2> spProvideClassInfo;
-						hr = punkObj->QueryInterface(__uuidof(IProvideClassInfo2), (void**)&spProvideClassInfo);
+						hr = punkObj->QueryInterface(IID_IProvideClassInfo2, (void**)&spProvideClassInfo);
 						if (SUCCEEDED(hr) && spProvideClassInfo != NULL)
 							hr = spProvideClassInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
 						else
@@ -7081,7 +7102,7 @@ ATLINLINE ATLAPI AtlGetObjectSourceInterface(
 							// Otherwise, try to locate the clsid from IPersist
 							CComPtr<IPersist> spPersist;
 							CLSID clsid;
-							hr = punkObj->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
+							hr = punkObj->QueryInterface(IID_IPersist, (void**)&spPersist);
 							if (SUCCEEDED(hr))
 							{
 								hr = spPersist->GetClassID(&clsid);
diff --git a/include/atlcomcli.h b/include/atlcomcli.h
index d2b79b6..d69c553 100644
--- a/include/atlcomcli.h
+++ b/include/atlcomcli.h
@@ -13,16 +13,20 @@
 
 #pragma once
 
+#include <atltrace.h>
 #include <atlcore.h>
 #include <ole2.h>
 #include <olectl.h>
 
+#ifdef _MSC_VER
 #pragma warning (push)
 #pragma warning (disable: 4127)  // conditional expression constant
 #pragma warning (disable: 4571)  //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
 
 
 #pragma pack(push,_ATL_PACKING)
+#endif
+
 namespace ATL
 {
 /////////////////////////////////////////////////////////////////////////////
@@ -128,7 +132,7 @@ _Check_return_ inline HRESULT AtlSetChildSite(
 
 	HRESULT hr;
 	IObjectWithSite* pChildSite = NULL;
-	hr = punkChild->QueryInterface(__uuidof(IObjectWithSite), (void**)&pChildSite);
+	hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
 	if (SUCCEEDED(hr) && pChildSite != NULL)
 	{
 		hr = pChildSite->SetSite(punkParent);
@@ -137,6 +141,69 @@ _Check_return_ inline HRESULT AtlSetChildSite(
 	return hr;
 }
 
+template <class T> class CComPtrBase;
+
+template <class T>
+class CComPtr : 
+	public CComPtrBase<T>
+{
+public:
+	CComPtr() throw()
+	{
+	}
+	CComPtr(_Inout_opt_ T* lp) throw() :
+		CComPtrBase<T>(lp)
+	{
+	}
+	CComPtr(_Inout_ const CComPtr<T>& lp) throw() :
+		CComPtrBase<T>(lp.p)
+	{	
+	}
+	T* operator=(_Inout_opt_ T* lp) throw()
+	{
+        if(*this!=lp)
+        {
+    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
+        }
+        return *this;
+	}
+	template <typename Q>
+	T* operator=(_Inout_ const CComPtr<Q>& lp) throw()
+	{
+        if( !CComPtrBase<T>::IsEqualObject(lp) )
+        {
+    		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T)));
+        }
+        return *this;
+	}
+	T* operator=(_Inout_ const CComPtr<T>& lp) throw()
+	{
+        if(*this!=lp)
+        {
+    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
+        }
+        return *this;
+	}	
+	CComPtr(_Inout_ CComPtr<T>&& lp) throw() :	
+		CComPtrBase<T>()
+	{	
+		p = lp.p;		
+		lp.p = NULL;
+	}	
+	T* operator=(_Inout_ CComPtr<T>&& lp) throw()
+	{			
+		if (*this != lp)
+		{
+			if (p != NULL)			
+				p->Release();
+			
+			p = lp.p;
+			lp.p = NULL;
+		}
+		return *this;		
+	}
+	T* p;
+};
 
 //CComPtrBase provides the basis for all other smart pointers
 //The other smartpointers add their own constructors and operators
@@ -220,8 +287,8 @@ public:
 
 		CComPtr<IUnknown> punk1;
 		CComPtr<IUnknown> punk2;
-		p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);
-		pOther->QueryInterface(__uuidof(IUnknown), (void**)&punk2);
+		p->QueryInterface(IID_IUnknown, (void**)&punk1);
+		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
 		return punk1 == punk2;
 	}
 	// Attach to an existing interface (does not AddRef)
@@ -288,67 +355,6 @@ public:
 	T* p;
 };
 
-template <class T>
-class CComPtr : 
-	public CComPtrBase<T>
-{
-public:
-	CComPtr() throw()
-	{
-	}
-	CComPtr(_Inout_opt_ T* lp) throw() :
-		CComPtrBase<T>(lp)
-	{
-	}
-	CComPtr(_Inout_ const CComPtr<T>& lp) throw() :
-		CComPtrBase<T>(lp.p)
-	{	
-	}
-	T* operator=(_Inout_opt_ T* lp) throw()
-	{
-        if(*this!=lp)
-        {
-    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
-        }
-        return *this;
-	}
-	template <typename Q>
-	T* operator=(_Inout_ const CComPtr<Q>& lp) throw()
-	{
-        if( !IsEqualObject(lp) )
-        {
-    		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T)));
-        }
-        return *this;
-	}
-	T* operator=(_Inout_ const CComPtr<T>& lp) throw()
-	{
-        if(*this!=lp)
-        {
-    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
-        }
-        return *this;
-	}	
-	CComPtr(_Inout_ CComPtr<T>&& lp) throw() :	
-		CComPtrBase<T>()
-	{	
-		p = lp.p;		
-		lp.p = NULL;
-	}	
-	T* operator=(_Inout_ CComPtr<T>&& lp) throw()
-	{			
-		if (*this != lp)
-		{
-			if (p != NULL)			
-				p->Release();
-			
-			p = lp.p;
-			lp.p = NULL;
-		}
-		return *this;		
-	}
-};
-
 //specialization for IDispatch
 template <>
 class CComPtr<IDispatch> : 
@@ -625,6 +631,7 @@ public:
         }
         return *this;
 	}
+	T* p;
 };
 
 //Specialization to make it work
@@ -640,7 +647,7 @@ public:
 	{
 		//Actually do a QI to get identity
 		if (lp != NULL)
-			lp->QueryInterface(__uuidof(IUnknown), (void **)&p);
+			lp->QueryInterface(IID_IUnknown, (void **)&p);
 	}
 	CComQIPtr(_Inout_ const CComQIPtr<IUnknown,&IID_IUnknown>& lp) throw() :
 		CComPtr<IUnknown>(lp.p)
@@ -651,7 +658,7 @@ public:
         if(*this!=lp)
         {
 		    //Actually do a QI to get identity
-		    return AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(IUnknown));
+		    return AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
         }
         return *this;
 	}
@@ -666,7 +673,7 @@ public:
 	}
 };
 
-typedef CComQIPtr<IDispatch, &__uuidof(IDispatch)> CComDispatchDriver;
+typedef CComQIPtr<IDispatch, &IID_IDispatch> CComDispatchDriver;
 
 #define com_cast ATL::CComQIPtr
 #ifndef _ATL_STREAM_MAX_SIZE
@@ -2956,10 +2963,10 @@ _Check_return_ inline HRESULT CComVariant::WriteToStream(_Inout_ IStream* pStrea
 			CComPtr<IPersistStream> spStream;
 			if (punkVal != NULL)
 			{
-				hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);
+				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
 				if (FAILED(hr))
 				{
-					hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);
+					hr = punkVal->QueryInterface(IID_IPersistStreamInit, (void**)&spStream);
 					if (FAILED(hr))
 						return hr;
 				}
@@ -3063,7 +3070,7 @@ _Check_return_ inline HRESULT CComVariant::ReadFromStream(
 		{
 			punkVal = NULL;
 			hr = AtlInternalOleLoadFromStream(pStream,
-				(vtRead == VT_UNKNOWN) ? __uuidof(IUnknown) : __uuidof(IDispatch),
+				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
 				(void**)&punkVal, rgclsidAllowed, cclsidAllowed);
 			// If IPictureDisp or IFontDisp property is not set, 
 			// OleLoadFromStream() will return REGDB_E_CLASSNOTREG.
@@ -3150,10 +3157,10 @@ inline HRESULT CComVariant::GetSizeMax(_Out_ ULARGE_INTEGER* pcbSize) const
 			{
 				CComPtr<IPersistStream> spStream;
 				
-				hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);
+				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
 				if (FAILED(hr))
 				{
-					hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);
+					hr = punkVal->QueryInterface(IID_IPersistStreamInit, (void**)&spStream);
 					if (FAILED(hr))
 					{
 						break;
@@ -3359,7 +3366,7 @@ _Check_return_ inline HRESULT AtlInternalOleLoadFromStream(
 	}
 
 	CComPtr<IPersistStream> pPersistStm;
-	hr = punkVal->QueryInterface(&pPersistStm);
+	hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&pPersistStm);
 	
 	if (SUCCEEDED(hr))
 	{
diff --git a/include/atlconv.h b/include/atlconv.h
index 48702ab..19b9e2e 100644
--- a/include/atlconv.h
+++ b/include/atlconv.h
@@ -96,7 +96,6 @@ inline void* WINAPI InterlockedExchangePointer(
 
 #define ATLCONV_DEADLAND_FILL _SECURECRT_FILL_BUFFER_PATTERN
 
-#pragma pack(push,_ATL_PACKING)
 namespace ATL
 {
 
@@ -125,6 +124,7 @@ inline void AtlConvAllocMemory(
 	{
 		if( nLength > nFixedBufferLength )
 		{
+#if __MSVCRT_VERSION__ >= 0x900
 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );
 			if (ppReallocBuf == NULL) 
 			{
@@ -133,6 +133,7 @@ inline void AtlConvAllocMemory(
 			*ppBuff = ppReallocBuf;
 		} else
 		{
+#endif
 			free(*ppBuff);
 			*ppBuff=pszFixedBuffer;
 		}
@@ -177,14 +178,14 @@ template< int t_nBufferLength = 128 >
 class CW2WEX
 {
 public:
-	CW2WEX(_In_z_ LPCWSTR psz) throw(...) :
+	CW2WEX(_In_z_ LPCWSTR psz) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz );
 	}
 	CW2WEX(
 			_In_z_ LPCWSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		(void)nCodePage;  // Code page doesn't matter
@@ -202,7 +203,7 @@ public:
 	}
 
 private:
-	void Init(_In_z_ LPCWSTR psz) throw(...)
+	void Init(_In_z_ LPCWSTR psz) noexcept(false)
 	{
 		if (psz == NULL)
 		{
@@ -229,14 +230,14 @@ template< int t_nBufferLength = 128 >
 class CA2AEX
 {
 public:
-	CA2AEX(_In_z_ LPCSTR psz) throw(...) :
+	CA2AEX(_In_z_ LPCSTR psz) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz );
 	}
 	CA2AEX(
 			_In_z_ LPCSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		(void)nCodePage;  // Code page doesn't matter
@@ -254,7 +255,7 @@ public:
 	}
 
 private:
-	void Init(_In_z_ LPCSTR psz) throw(...)
+	void Init(_In_z_ LPCSTR psz) noexcept(false)
 	{
 		if (psz == NULL)
 		{
@@ -280,13 +281,13 @@ template< int t_nBufferLength = 128 >
 class CA2CAEX
 {
 public:
-	CA2CAEX(_In_z_ LPCSTR psz) throw(...) :
+	CA2CAEX(_In_z_ LPCSTR psz) noexcept(false) :
 		m_psz( psz )
 	{
 	}
 	CA2CAEX(
 			_In_z_ LPCSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( psz )
 	{
 		(void)nCodePage;
@@ -313,13 +314,13 @@ template< int t_nBufferLength = 128 >
 class CW2CWEX
 {
 public:
-	CW2CWEX(_In_z_ LPCWSTR psz) throw(...) :
+	CW2CWEX(_In_z_ LPCWSTR psz) noexcept(false) :
 		m_psz( psz )
 	{
 	}
 	CW2CWEX(
 			_In_z_ LPCWSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( psz )
 	{		
 		UNREFERENCED_PARAMETER(nCodePage);
@@ -346,14 +347,14 @@ template< int t_nBufferLength = 128 >
 class CA2WEX
 {
 public:
-	CA2WEX(_In_z_ LPCSTR psz) throw(...) :
+	CA2WEX(_In_z_ LPCSTR psz) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz, _AtlGetConversionACP() );
 	}
 	CA2WEX(
 			_In_z_ LPCSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz, nCodePage );
@@ -371,7 +372,7 @@ public:
 private:
 	void Init(
 		_In_z_ LPCSTR psz, 
-		_In_ UINT nCodePage) throw(...)
+		_In_ UINT nCodePage) noexcept(false)
 	{
 		if (psz == NULL)
 		{
@@ -413,14 +414,14 @@ template< int t_nBufferLength = 128 >
 class CW2AEX
 {
 public:
-	CW2AEX(_In_z_ LPCWSTR psz) throw(...) :
+	CW2AEX(_In_z_ LPCWSTR psz) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz, _AtlGetConversionACP() );
 	}
 	CW2AEX(
 			_In_z_ LPCWSTR psz, 
-			_In_ UINT nCodePage) throw(...) :
+			_In_ UINT nCodePage) noexcept(false) :
 		m_psz( m_szBuffer )
 	{
 		Init( psz, nCodePage );
@@ -438,7 +439,7 @@ public:
 private:
 	void Init(
 		_In_z_ LPCWSTR psz, 
-		_In_ UINT nConvertCodePage) throw(...)
+		_In_ UINT nConvertCodePage) noexcept(false)
 	{
 		if (psz == NULL)
 		{
@@ -528,9 +529,6 @@ typedef CW2AEX<> CW2A;
 #define CT2COLEEX CT2CWEX
 
 };  // namespace ATL
-#pragma pack(pop)
-
-#pragma pack(push,8)
 
 #ifndef _ATL_EX_CONVERSION_MACROS_ONLY
 
@@ -752,10 +750,7 @@ inline OLECHAR* ocscpy(
 	_Inout_ _Post_z_ LPOLESTR dest, 
 	_In_z_ LPCOLESTR src) throw()
 {
-#pragma warning(push)
-#pragma warning(disable:4996)
 	return wcscpy(dest, src);
-#pragma warning(pop)
 }
 
 _ATL_INSECURE_DEPRECATE("ocscat is not safe. Intead, use ocscat_s")
@@ -763,10 +758,7 @@ inline OLECHAR* ocscat(
 	_Inout_ _Post_z_ LPOLESTR dest, 
 	_In_z_ LPCOLESTR src) throw()
 {
-#pragma warning(push)
-#pragma warning(disable:4996)
 	return wcscat(dest, src);
-#pragma warning(pop)
 }
 
 _Ret_z_ inline LPCOLESTR T2COLE_EX(
@@ -1252,13 +1244,10 @@ inline LPDEVMODEW AtlDevModeA2W(
 	if (lpDevModeA->dmDriverExtra != 0)
 	{
 		// lpDevModeW holds more info
-#pragma warning(push)
-#pragma warning(disable:26000)
 		if(0 != memcpy_s(lpDevModeW+1, lpDevModeA->dmDriverExtra, lpDevModeA+1, lpDevModeA->dmDriverExtra))
 		{
 			return NULL;
 		}
-#pragma warning(pop)
 	}
 	lpDevModeW->dmSize = sizeof(DEVMODEW);
 	return lpDevModeW;
@@ -1451,7 +1440,6 @@ inline LPTEXTMETRICOLE TEXTMETRICT2OLE(_In_ LPTEXTMETRICW lp)
 
 #endif //_WINGDI_
 
-#pragma pack(pop)
 
 /////////////////////////////////////////////////////////////////////////////
 
@@ -1487,13 +1475,10 @@ ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(
 	if (lpDevModeW->dmDriverExtra != 0)
 	{
 		// lpDevModeW holds more info
-#pragma warning(push)
-#pragma warning(disable:26000)
 		if(0 != memcpy_s(lpDevModeA+1, lpDevModeW->dmDriverExtra, lpDevModeW+1, lpDevModeW->dmDriverExtra))
 		{
 			return NULL;
 		}
-#pragma warning(pop)
 	}
 	
 	lpDevModeA->dmSize = sizeof(DEVMODEA);
@@ -1505,7 +1490,6 @@ ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(
 #endif // !_ATL_DLL
 
 #ifndef _ATL_NO_PRAGMA_WARNINGS
-#pragma warning (pop)
 #endif //!_ATL_NO_PRAGMA_WARNINGS
 
 #endif // __ATLCONV_H__
diff --git a/include/atlcore.h b/include/atlcore.h
index 0f1610d..493ca8d 100644
--- a/include/atlcore.h
+++ b/include/atlcore.h
@@ -70,7 +70,7 @@ inline BOOL AtlIsValidAddress(
 
 template<typename T>
 inline void AtlAssertValidObject(
-	_In_opt_ _Prepost_opt_bytecount_x_(sizeof(T)) const T *pOb)
+	_In_opt_ const T *pOb)
 {
 	ATLASSERT(pOb);
 	ATLASSERT(AtlIsValidAddress(pOb, sizeof(T)));
diff --git a/include/atlctl.h b/include/atlctl.h
index da9a338..6fd1ab7 100644
--- a/include/atlctl.h
+++ b/include/atlctl.h
@@ -89,11 +89,11 @@ public:
 		_Inout_ IUnknown* pUnk, 
 		_In_ DISPID dispID)
 	{
-		CComQIPtr<IConnectionPointContainer, &__uuidof(IConnectionPointContainer)> pCPC(pUnk);
+		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
 		if (!pCPC)
 			return S_OK;
 		CComPtr<IConnectionPoint> pCP;
-		pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
+		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
 		if (!pCP)
 			return S_OK;
 		CComPtr<IEnumConnections> pEnum;
@@ -106,7 +106,7 @@ public:
 			if (cd.pUnk)
 			{
 				HRESULT hr = S_OK;
-				CComQIPtr<IPropertyNotifySink, &__uuidof(IPropertyNotifySink)> pSink(cd.pUnk);
+				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
 #ifdef _DEBUG
 				if (pSink == NULL)
 				{
@@ -128,11 +128,11 @@ public:
 		_Inout_ IUnknown* pUnk, 
 		_In_ DISPID dispID)
 	{
-		CComQIPtr<IConnectionPointContainer, &__uuidof(IConnectionPointContainer)> pCPC(pUnk);
+		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
 		if (!pCPC)
 			return S_OK;
 		CComPtr<IConnectionPoint> pCP;
-		pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
+		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
 		if (!pCP)
 			return S_OK;
 		CComPtr<IEnumConnections> pEnum;
@@ -144,7 +144,7 @@ public:
 		{
 			if (cd.pUnk)
 			{
-				CComQIPtr<IPropertyNotifySink, &__uuidof(IPropertyNotifySink)> pSink(cd.pUnk);
+				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
 #ifdef _DEBUG
 				if (pSink == NULL)
 				{
@@ -173,7 +173,7 @@ public:
 public:
 	CComControlBase(_Inout_ HWND& h) : m_hWndCD(h)
 	{
-		memset(this, 0, sizeof(CComControlBase));
+		memset((void*)this, 0, sizeof(CComControlBase));
 		m_phWndCD = &h;
 		m_sizeExtent.cx = 2*2540;
 		m_sizeExtent.cy = 2*2540;
@@ -245,10 +245,10 @@ public:
 		if (m_bInPlaceActive)
 		{
 			CComPtr<IOleObject> pOleObject;
-			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);
+			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
 			if (pOleObject != NULL)
 				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
-			CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);
+			CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
 			if (m_bInPlaceActive && spSite != NULL)
 				spSite->OnFocus(TRUE);
 		}
@@ -261,7 +261,7 @@ public:
 		_In_ LPARAM /*lParam*/, 
 		_Out_ BOOL& bHandled)
 	{
-		CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);
+		CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
 		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
 			spSite->OnFocus(FALSE);
 		bHandled = FALSE;
@@ -280,7 +280,7 @@ public:
 		if (FAILED(hRet) || bUserMode)
 		{
 			CComPtr<IOleObject> pOleObject;
-			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);
+			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
 			if (pOleObject != NULL)
 				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
 		}
@@ -361,7 +361,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (SUCCEEDED(hRes) && var.pdispVal)
 		{
 			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
-				hRes = var.pdispVal->QueryInterface(__uuidof(IFont), (void**)ppFont);
+				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
 			else
 				hRes = DISP_E_BADVARTYPE;
 		}
@@ -382,7 +382,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (SUCCEEDED(hRes) && var.pdispVal)
 		{
 			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
-				hRes = var.pdispVal->QueryInterface(__uuidof(IFontDisp), (void**)ppFont);
+				hRes = var.pdispVal->QueryInterface(IID_IFontDisp, (void**)ppFont);
 			else
 				hRes = DISP_E_BADVARTYPE;
 		}
@@ -743,7 +743,7 @@ public:
 	RECT m_rcPos; // position in pixels
 #pragma warning(push)
 #pragma warning(disable: 4510 4610) // unnamed union
-	union
+	struct
 	{
 		HWND& m_hWndCD;
 		HWND* m_phWndCD;
@@ -785,13 +785,13 @@ inline HRESULT CComControlBase::IQuickActivate_QuickActivate(
 
 	// get all interfaces we are going to need
 	CComPtr<IOleObject> pOO;
-	ControlQueryInterface(__uuidof(IOleObject), (void**)&pOO);
+	ControlQueryInterface(IID_IOleObject, (void**)&pOO);
 	CComPtr<IViewObjectEx> pVOEX;
-	ControlQueryInterface(__uuidof(IViewObjectEx), (void**)&pVOEX);
+	ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
 	CComPtr<IPointerInactive> pPI;
-	ControlQueryInterface(__uuidof(IPointerInactive), (void**)&pPI);
+	ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
 	CComPtr<IProvideClassInfo2> pPCI;
-	ControlQueryInterface(__uuidof(IProvideClassInfo2), (void**)&pPCI);
+	ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);
 
 	if (pOO == NULL || pVOEX == NULL)
 		return E_FAIL;
@@ -805,7 +805,7 @@ inline HRESULT CComControlBase::IQuickActivate_QuickActivate(
 	}
 
 	CComPtr<IConnectionPointContainer> pCPC;
-	ControlQueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
+	ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
 
 	if (pQACont->pPropertyNotifySink)
 	{
@@ -813,7 +813,7 @@ inline HRESULT CComControlBase::IQuickActivate_QuickActivate(
 		CComPtr<IConnectionPoint> pCP;
 		if (pCPC != NULL)
 		{
-			hRes = pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
+			hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
 			if (SUCCEEDED(hRes))
 				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
 		}
@@ -885,9 +885,9 @@ inline HRESULT CComControlBase::DoVerbProperties(
 	_In_ HWND hwndParent)
 {
 	HRESULT hr = S_OK;
-	CComQIPtr <ISpecifyPropertyPages, &__uuidof(ISpecifyPropertyPages)> spPages;
-	CComQIPtr <IOleObject, &__uuidof(IOleObject)> spObj;
-	CComQIPtr <IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);
+	CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
+	CComQIPtr <IOleObject, &IID_IOleObject> spObj;
+	CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
 
 	if (spSite)
 	{
@@ -897,7 +897,7 @@ inline HRESULT CComControlBase::DoVerbProperties(
 	}
 
 	CComPtr<IUnknown> pUnk;
-	ControlQueryInterface(__uuidof(IUnknown), (void**)&pUnk);
+	ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
 	ATLASSERT(pUnk != NULL);
 	CAUUID pages;
 	spPages = pUnk;
@@ -947,14 +947,14 @@ inline HRESULT CComControlBase::InPlaceActivate(
 		return S_OK;
 
 	CComPtr<IOleInPlaceObject> pIPO;
-	ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
+	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
 	ATLASSERT(pIPO != NULL);
 
 	if (!m_bNegotiatedWnd)
 	{
 		if (!m_bWindowOnly)
 			// Try for windowless site
-			hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteWindowless), (void **)&m_spInPlaceSite);
+			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);
 
 		if (m_spInPlaceSite)
 		{
@@ -972,11 +972,11 @@ inline HRESULT CComControlBase::InPlaceActivate(
 		}
 		else
 		{
-			m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteEx), (void **)&m_spInPlaceSite);
+			m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
 			if (m_spInPlaceSite)
 				m_bInPlaceSiteEx = TRUE;
 			else
-				hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSite), (void **)&m_spInPlaceSite);
+				hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
 		}
 	}
 
@@ -1046,7 +1046,7 @@ inline HRESULT CComControlBase::InPlaceActivate(
 	}
 
 	CComPtr<IOleInPlaceActiveObject> spActiveObject;
-	ControlQueryInterface(__uuidof(IOleInPlaceActiveObject), (void**)&spActiveObject);
+	ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);
 
 	// Gone active by now, take care of UIACTIVATE
 	if (DoesVerbUIActivate(iVerb))
@@ -1090,7 +1090,7 @@ inline HRESULT CComControlBase::SendOnDataChange(_In_ DWORD advf)
 	if (m_spDataAdviseHolder)
 	{
 		CComPtr<IDataObject> pdo;
-		if (SUCCEEDED(ControlQueryInterface(__uuidof(IDataObject), (void**)&pdo)))
+		if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
 			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
 	}
 	return hRes;
@@ -1103,7 +1103,7 @@ inline HRESULT CComControlBase::IOleObject_SetClientSite(_Inout_opt_ IOleClientS
 	m_spAmbientDispatch.Release();
 	if (m_spClientSite != NULL)
 	{
-		m_spClientSite->QueryInterface(__uuidof(IDispatch),
+		m_spClientSite->QueryInterface(IID_IDispatch,
 			(void**) &m_spAmbientDispatch.p);
 	}
 	return S_OK;
@@ -1144,7 +1144,7 @@ inline HRESULT CComControlBase::IOleObject_Close(_In_ DWORD dwSaveOption)
 	if (m_bInPlaceActive)
 	{
 		CComPtr<IOleInPlaceObject> pIPO;
-		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
+		ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
 		ATLASSERT(pIPO != NULL);
 		HRESULT hr = pIPO->InPlaceDeactivate();
 		if (FAILED(hr))
@@ -1184,7 +1184,7 @@ inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
 
 	if(m_bUIActive) {
 		CComPtr<IOleInPlaceObject> pIPO;
-		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
+		ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
 		ATLENSURE(pIPO != NULL);
 		pIPO->UIDeactivate();
 	}
@@ -1323,8 +1323,8 @@ inline HRESULT CComControlBase::IViewObject_Draw(
 	_In_opt_ LPCRECTL prcWBounds)
 {
 	ATLTRACE(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
-		dwDrawAspect, lindex, reinterpret_cast<int>(ptd), 
-			reinterpret_cast<int>(hicTargetDev), reinterpret_cast<int>(hdcDraw));
+		dwDrawAspect, lindex, reinterpret_cast<INT_PTR>(ptd), 
+			reinterpret_cast<INT_PTR>(hicTargetDev), reinterpret_cast<INT_PTR>(hdcDraw));
 #ifdef _DEBUG
 	if (prcBounds == NULL)
 		ATLTRACE(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
@@ -1560,6 +1560,7 @@ class ATL_NO_VTABLE CComControl :
 	public WinBase
 {
 public:
+	HWND& m_hWnd;
 	CComControl() : CComControlBase(m_hWnd) {}
 
 	virtual HWND CreateControlWindow(
@@ -1628,6 +1629,7 @@ class CComCompositeControl :
 	public CComControl< T, CAxDialogImpl< T > >
 {
 public:
+	HWND& m_hWnd;
 	CComCompositeControl()
 	{
 		m_hbrBackground = NULL;
@@ -1657,7 +1659,7 @@ public:
 			m_hbrBackground = NULL;
 		}
 		OLE_COLOR clr;
-		HRESULT hr = GetAmbientBackColor(clr);
+		HRESULT hr = CComControlBase::GetAmbientBackColor(clr);
 		if (SUCCEEDED(hr))
 		{
 			COLORREF rgb;
@@ -1689,7 +1691,7 @@ public:
 		if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &contrastMode, 0) && 
 			(contrastMode.dwFlags & HCF_HIGHCONTRASTON) != 0)
 
-			return DefWindowProc();
+			return CWindowImplBaseT<>::DefWindowProc();
 
 		HDC dc = (HDC) w;
 		LOGBRUSH lb;
@@ -1706,7 +1708,7 @@ public:
 		if (m_hWnd != NULL)
 		{
 			SetBackgroundColorFromAmbient();
-			ShowWindow(SW_SHOWNOACTIVATE);
+			CWindow::ShowWindow(SW_SHOWNOACTIVATE);
 		}
 		return m_hWnd;
 	}
@@ -1739,7 +1741,7 @@ public:
 			return FALSE;
 		// find a direct child of the dialog from the window that has focus
 		HWND hWndCtl = ::GetFocus();
-		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
+		if (CWindow::IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
 		{
 			do
 			{
@@ -1768,7 +1770,7 @@ public:
 				{
 					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
 					if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
-						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
+						hWndFirstOrLast = CWindow::GetNextDlgTabItem(hWndFirstOrLast, TRUE);
 					if (hWndFirstOrLast == hWndCtl)
 						return FALSE;
 				}
@@ -1782,7 +1784,7 @@ public:
 				{
 					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
 					if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)	// going forward
-						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
+						hWndFirstOrLast = CWindow::GetNextDlgTabItem(hWndFirstOrLast, TRUE);
 					if (hWndFirstOrLast == hWndCtl)
 						return FALSE;
 				}
@@ -1849,11 +1851,11 @@ public:
 		if (bRet)
 		{
 			HWND hWndCtlNewFocus = ::GetFocus();
-			if (IsChild(hWndCtlNewFocus))
+			if (CWindow::IsChild(hWndCtlNewFocus))
 				m_hWndFocus = hWndCtlNewFocus;
 			else
 				m_hWndFocus = NULL;
-			if (IsChild(hWndCtlNewFocus) && ::GetParent(hWndCtlNewFocus) != m_hWnd)
+			if (CWindow::IsChild(hWndCtlNewFocus) && ::GetParent(hWndCtlNewFocus) != m_hWnd)
 			{
 				do
 				{
@@ -1862,14 +1864,14 @@ public:
 				while (::GetParent(hWndCtlNewFocus) != m_hWnd);
 			}
 
-			if (IsChild(hWndCtlNewFocus)  && IsChild(hWndCtl) && hWndCtl != hWndCtlNewFocus)
+			if (CWindow::IsChild(hWndCtlNewFocus) && CWindow::IsChild(hWndCtl) && hWndCtl != hWndCtlNewFocus)
 			{
 				CComPtr<IUnknown> spUnknown;
 				HRESULT hr = AtlAxGetControl(hWndCtl, &spUnknown);
 				if (SUCCEEDED(hr))
 				{
 					CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
-					hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
+					hr = spUnknown->QueryInterface(IID_IOleInPlaceObject, (void**)&spIOleInPlaceObject);
 					if (SUCCEEDED(hr))
 						spIOleInPlaceObject->UIDeactivate();
 				}
@@ -1900,7 +1902,7 @@ public:
 				if (SUCCEEDED(hr))
 				{
 					CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
-					hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
+					hr = spUnknown->QueryInterface(IID_IOleInPlaceObject, (void**)&spIOleInPlaceObject);
 					if (SUCCEEDED(hr))
 						spIOleInPlaceObject->UIDeactivate();
 				}
@@ -2025,14 +2027,14 @@ public:
 					if (SUCCEEDED(hr))
 					{
 						CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
-						hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
+						hr = spUnknown->QueryInterface(IID_IOleInPlaceObject, (void**)&spIOleInPlaceObject);
 						if (SUCCEEDED(hr))
 							spIOleInPlaceObject->UIDeactivate();
 					}
 				}
 			}
 		}
-		if (IsChild(hWndFocus))
+		if (CWindow::IsChild(hWndFocus))
 			m_hWndFocus = hWndFocus;
 		else
 			m_hWndFocus = NULL;
@@ -2058,6 +2060,7 @@ public:
 	END_SINK_MAP()
 
 	HWND m_hWndFocus;
+	unsigned m_bInPlaceActive:1;
 };
 #endif //_ATL_NO_HOSTING
 
@@ -2141,7 +2144,7 @@ public:
 			// If you've declared m_nAppearance as something other than
 			// 'short', you'll need to typedef AppearanceType to that type
 			// in your derived class T.
-			pT->m_nAppearance = static_cast<T::AppearanceType>(pQACont->dwAppearance);
+			pT->m_nAppearance = static_cast<typename T::AppearanceType>(pQACont->dwAppearance);
 		}
 		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
 	}
@@ -2899,7 +2902,7 @@ public:
 
 		//---- get current value of property ----
 		IDispatch *pdisp = NULL;
-		pT->QueryInterface(__uuidof(IDispatch), (void **)&pdisp);
+		pT->QueryInterface(IID_IDispatch, (void **)&pdisp);
 		if (! pdisp)
 			return S_FALSE;
 		HRESULT hr = CComDispatchDriver::GetProperty(pdisp, dispID, &var);
@@ -3399,7 +3402,7 @@ public:
 		}
 
 		CComPtr<IOleControlSite> spCtlSite;
-		hRet = pT->InternalGetSite(__uuidof(IOleControlSite), (void**)&spCtlSite);
+		hRet = pT->InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
 		if (SUCCEEDED(hRet))
 		{
 			if (spCtlSite != NULL)
@@ -3945,11 +3948,11 @@ END_COM_MAP()
 		m_dwTotalRead = 0;
 		m_dwAvailableToRead = 0;
 		HRESULT hr = S_OK;
-		CComQIPtr<IServiceProvider, &__uuidof(IServiceProvider)> spServiceProvider(pUnkContainer);
+		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
 		CComPtr<IBindHost>	spBindHost;
 		CComPtr<IStream>	spStream;
 		if (spServiceProvider)
-			spServiceProvider->QueryService(SID_IBindHost, __uuidof(IBindHost), (void**)&spBindHost);
+			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);
 
 		if (spBindHost == NULL)
 		{
@@ -3965,7 +3968,7 @@ END_COM_MAP()
 				m_spMoniker.Release();
 
 			if (SUCCEEDED(hr))
-				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, __uuidof(IStream), (void**)&spStream);
+				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
 		}
 		else
 		{
@@ -3983,7 +3986,7 @@ END_COM_MAP()
 
 			if (SUCCEEDED(hr))
 			{
-				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), __uuidof(IStream), (void**)&spStream);
+				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), IID_IStream, (void**)&spStream);
 				ATLTRACE(atlTraceControls,2,_T("Bound"));
 			}
 		}
@@ -4141,7 +4144,7 @@ END_COM_MAP()
 	}
 
 
-template < class T, class InterfaceName, const IID* piid = &_ATL_IIDOF(InterfaceName), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
+template < class T, class InterfaceName, const IID* piid = &__uuidof(InterfaceName), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
 WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
 class ATL_NO_VTABLE CStockPropImpl : 
 	public IDispatchImpl< InterfaceName, piid, plibid, wMajor, wMinor, tihclass >
@@ -4159,14 +4162,14 @@ public:
 			pT->m_pFont = 0;
 			if (pFontDisp)
 			{
-				CComQIPtr<IFont, &__uuidof(IFont)> p(pFontDisp);
+				CComQIPtr<IFont, &IID_IFont> p(pFontDisp);
 				if (p)
 				{
 					CComPtr<IFont> pFont;
 					p->Clone(&pFont);
 					if (pFont)
 					{
-						pFont->QueryInterface(__uuidof(IFontDisp), (void**) &pT->m_pFont);
+						pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
 					}
 				}
 			}
@@ -4232,7 +4235,7 @@ public:
 			pT->m_pPicture = 0;
 			if (pPicture)
 			{
-				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
+				CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
 				if (p)
 				{
 					ULARGE_INTEGER l;
@@ -4249,7 +4252,7 @@ public:
 								LARGE_INTEGER l;
 								l.QuadPart = 0;
 								spStream->Seek(l, STREAM_SEEK_SET, NULL);
-								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pPicture);
+								OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
 							}
 							spStream.Release();
 						}
@@ -4319,7 +4322,7 @@ public:
 			pT->m_pMouseIcon = 0;
 			if (pPicture)
 			{
-				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
+				CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
 				if (p)
 				{
 					ULARGE_INTEGER l;
@@ -4336,7 +4339,7 @@ public:
 								LARGE_INTEGER l;
 								l.QuadPart = 0;
 								spStream->Seek(l, STREAM_SEEK_SET, NULL);
-								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pMouseIcon);
+								OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
 							}
 							spStream.Release();
 						}
diff --git a/include/atldb.h b/include/atldb.h
index 451740a..32d91b2 100644
--- a/include/atldb.h
+++ b/include/atldb.h
@@ -1537,7 +1537,7 @@ public:
 	HRESULT FinalConstruct()
 	{
 		HRESULT hr = ::CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, NULL,
-			CLSCTX_INPROC_SERVER, __uuidof(IDataConvert), (void**)&m_spConvert);
+			CLSCTX_INPROC_SERVER, IID_IDataConvert, (void**)&m_spConvert);
 
 		if (FAILED(hr))
 			return hr;
@@ -1547,7 +1547,7 @@ public:
 		DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0}}};
 		CComPtr<IDCInfo> spIDCInfo;
 
-		hr = m_spConvert->QueryInterface(&spIDCInfo);
+		hr = m_spConvert->QueryInterface(IID_IDCInfo, (void**)&spIDCInfo);
 		if (hr == S_OK)
 		{
 			V_UI4(&rgInfo->vData) = 0x200;  // OLEDB Version 02.00
@@ -1596,11 +1596,11 @@ ATLPREFAST_SUPPRESS(6387)
 		{
 			ATLASSUME(pSession != NULL);
 			CComPtr<IObjectWithSite> spCreator;
-			hr = pSession->QueryInterface(__uuidof(IObjectWithSite), (void**)&spCreator);
+			hr = pSession->QueryInterface(IID_IObjectWithSite, (void**)&spCreator);
 			if (SUCCEEDED(hr))
 			{
 				CComPtr<IUnknown> spOuterUnk;
-				hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
+				hr = pT->QueryInterface(IID_IUnknown, (void**)&spOuterUnk);
 				if (SUCCEEDED(hr))
 				{
 					hr = spCreator->SetSite(spOuterUnk);
@@ -2685,35 +2685,35 @@ public:
 		const GUID* ppGuid[1];
 		ppGuid[0] = &DBPROPSET_ROWSET;
 
-		if (InlineIsEqualGUID(riid, __uuidof(IRowsetChange)))
+		if (InlineIsEqualGUID(riid, IID_IRowsetChange))
 		{
 			if(!propset.AddProperty(DBPROP_IRowsetChange, true))
 			{
 				return E_FAIL;
 			}
 		}
-		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetUpdate)))
+		else if (InlineIsEqualGUID(riid, IID_IRowsetUpdate))
 		{
 			if(!propset.AddProperty(DBPROP_IRowsetUpdate, true))
 			{
 				return E_FAIL;
 			}
 		}
-		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetLocate)))
+		else if (InlineIsEqualGUID(riid, IID_IRowsetLocate))
 		{
 			if(!propset.AddProperty(DBPROP_IRowsetLocate, true))
 			{
 				return E_FAIL;
 			}
 		}
-		else if (InlineIsEqualGUID(riid, __uuidof(IConnectionPointContainer)))
+		else if (InlineIsEqualGUID(riid, IID_IConnectionPointContainer))
 		{
 			if(!propset.AddProperty(DBPROP_IConnectionPointContainer, true))
 			{
 				return E_FAIL;
 			}
 		}
-		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetScroll)))
+		else if (InlineIsEqualGUID(riid, IID_IRowsetScroll))
 		{
 			if(!propset.AddProperty(DBPROP_IRowsetScroll, true))
 			{
@@ -4187,62 +4187,62 @@ EXIT:
 		HRESULT	hr = S_OK;
 		DBPROP* pProp = &(pPropSet->rgProperties[0]);
 
-		if(InlineIsEqualGUID(*piid, __uuidof(IAccessor)))
+		if(InlineIsEqualGUID(*piid, IID_IAccessor))
 			pProp->dwPropertyID = DBPROP_IAccessor;
-		else if(InlineIsEqualGUID(*piid,__uuidof(IColumnsInfo)))
+		else if(InlineIsEqualGUID(*piid,IID_IColumnsInfo))
 			pProp->dwPropertyID = DBPROP_IColumnsInfo;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowset)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowset))
 			pProp->dwPropertyID = DBPROP_IRowset;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetInfo)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetInfo))
 			pProp->dwPropertyID = DBPROP_IRowsetInfo;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetLocate)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetLocate))
 			pProp->dwPropertyID = DBPROP_IRowsetLocate;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IColumnsRowset)))
+		else if(InlineIsEqualGUID(*piid , IID_IColumnsRowset))
 			pProp->dwPropertyID = DBPROP_IColumnsRowset;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetResynch)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetResynch))
 			pProp->dwPropertyID = DBPROP_IRowsetResynch;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetScroll)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetScroll))
 			pProp->dwPropertyID = DBPROP_IRowsetScroll;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetChange)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetChange))
 			pProp->dwPropertyID = DBPROP_IRowsetChange;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetUpdate)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetUpdate))
 			pProp->dwPropertyID = DBPROP_IRowsetUpdate;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIdentity)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetIdentity))
 			pProp->dwPropertyID = DBPROP_IRowsetIdentity;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IConnectionPointContainer)))
+		else if(InlineIsEqualGUID(*piid , IID_IConnectionPointContainer))
 			pProp->dwPropertyID = DBPROP_IConnectionPointContainer;
-		else if(InlineIsEqualGUID(*piid , __uuidof(ISupportErrorInfo)))
+		else if(InlineIsEqualGUID(*piid , IID_ISupportErrorInfo))
 			pProp->dwPropertyID = DBPROP_ISupportErrorInfo;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIndex)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetIndex))
 			pProp->dwPropertyID = DBPROP_IRowsetIndex;
 	#if( OLEDBVER >= 0x0200 && 0 /* These interfaces are defined nowhere */ )
-		else if(InlineIsEqualGUID(*piid , __uuidof(IProvideMoniker)))
+		else if(InlineIsEqualGUID(*piid , IID_IProvideMoniker))
 			pProp->dwPropertyID = DBPROP_IProvideMoniker;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNotify)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetNotify))
 			pProp->dwPropertyID = DBPROP_IRowsetNotify;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IReadData)))
+		else if(InlineIsEqualGUID(*piid , IID_IReadData))
 			pProp->dwPropertyID = DBPROP_IReadData;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetExactScroll)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetExactScroll))
 			pProp->dwPropertyID = DBPROP_IRowsetExactScroll;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNextRowset)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetNextRowset))
 			pProp->dwPropertyID = DBPROP_IRowsetNextRowset;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNewRowAfter)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetNewRowAfter))
 			pProp->dwPropertyID = DBPROP_IRowsetNewRowAfter;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWithParameters)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetWithParameters))
 			pProp->dwPropertyID = DBPROP_IRowsetWithParameters;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetFind)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetFind))
 			pProp->dwPropertyID = DBPROP_IRowsetFind;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetAsynch)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetAsynch))
 			pProp->dwPropertyID = DBPROP_IRowsetAsynch;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetKeys)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetKeys))
 			pProp->dwPropertyID = DBPROP_IRowsetKeys;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchAll)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchAll))
 			pProp->dwPropertyID = DBPROP_IRowsetWatchAll;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchNotify)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchNotify))
 			pProp->dwPropertyID = DBPROP_IRowsetWatchNotify;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchRegion)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetWatchRegion))
 			pProp->dwPropertyID = DBPROP_IRowsetWatchRegion;
-		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetCopyRows)))
+		else if(InlineIsEqualGUID(*piid , IID_IRowsetCopyRows))
 			pProp->dwPropertyID = DBPROP_IRowsetCopyRows;
 	#endif //#if( OLEDBVER >= 0x0200 )
 		else
@@ -5262,7 +5262,7 @@ public:
 		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
 			return DB_E_NOAGGREGATION;
 		CComPtr<IUnknown> spUnk;
-		hr = pUnkThis->QueryInterface(__uuidof(IUnknown), (void**)&spUnk);
+		hr = pUnkThis->QueryInterface(IID_IUnknown, (void**)&spUnk);
 		if (FAILED(hr))
 			return hr;
 
@@ -5285,7 +5285,7 @@ public:
 		if (FAILED(hrProps))
 			return hrProps;
 
-		CComQIPtr<IObjectWithSite> spSite = spUnk;
+		CComQIPtr<IObjectWithSite, &IID_IObjectWithSite> spSite = spUnk;
 		ATLASSERT(spSite != NULL);
 		hr = spSite->SetSite(pUnkSession);
 		if (FAILED(hr))
@@ -5328,7 +5328,7 @@ ATLPREFAST_SUPPRESS(6387)
 			return hr;
 		pSchemaRowset = &(pPolyObj->m_contained);
 		CComPtr<IUnknown> spOuterUnk;
-		(pT->GetUnknown())->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
+		(pT->GetUnknown())->QueryInterface(IID_IUnknown, (void**)&spOuterUnk);
 		SchemaRowsetClass* myPT = (SchemaRowsetClass*) pSchemaRowset;
 		hr = InternalCreateSchemaRowset(pUnkOuter, cRestrictions, rgRestrictions,
 										riid, cPropertySets, rgPropertySets, ppRowset,
@@ -5541,7 +5541,7 @@ ATLPREFAST_SUPPRESS(6387)
 		ATLASSUME(pCommand != NULL);
 		// Ref the created COM object and Auto release it on failure
 		CComPtr<IUnknown> spUnk;
-		hr = pCommand->QueryInterface(&spUnk);
+		hr = pCommand->QueryInterface(IID_IUnknown, (void**)&spUnk);
 		if (FAILED(hr))
 		{
 			delete pCommand; // must hand delete as it is not ref'd
@@ -5549,7 +5549,7 @@ ATLPREFAST_SUPPRESS(6387)
 		}
 		ATLASSERT(pCommand->m_contained.m_spUnkSite == NULL);
 		CComPtr<IUnknown> spOuterUnk;
-		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
+		hr = pT->QueryInterface(IID_IUnknown, (void**)&spOuterUnk);
 		if (SUCCEEDED(hr))
 		{
 			hr = pCommand->m_contained.SetSite(spOuterUnk);
@@ -5613,7 +5613,7 @@ ATLPREFAST_SUPPRESS(6387)
 			return hr;
 		// Ref the created COM object and Auto release it on failure
 		CComPtr<IUnknown> spUnk;
-		hr = pPolyObj->QueryInterface(&spUnk);
+		hr = pPolyObj->QueryInterface(IID_IUnknown, (void**)&spUnk);
 		if (FAILED(hr))
 		{
 			delete pPolyObj; // must hand delete as it is not ref'd
@@ -5641,7 +5641,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (FAILED(hrProps))
 			return hrProps;
 		CComPtr<IUnknown> spOuterUnk;
-		hr = ((SessionClass*)this)->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
+		hr = ((SessionClass*)this)->QueryInterface(IID_IUnknown, (void**)&spOuterUnk);
 		if (FAILED(hr))
 		{
 			return hr;
@@ -5717,7 +5717,7 @@ public:
 	{
 		HRESULT hr = E_FAIL;
 		CComPtr<ICommandText> spText;
-		if (SUCCEEDED(hr = pUnkThis->QueryInterface(__uuidof(ICommandText), (void**)&spText)))
+		if (SUCCEEDED(hr = pUnkThis->QueryInterface(IID_ICommandText, (void**)&spText)))
 		{
 			LPOLESTR szCommand;
 			hr = spText->GetCommandText(NULL, &szCommand);
@@ -5964,9 +5964,9 @@ public:
 			// the data source object, we use the IObjectWithSite interface to
 			// get the session object and then the GetDataSource method to get
 			// the data source object itself.
-			if (FAILED(pSite->GetSite(__uuidof(IGetDataSource), (void**)&spDataSource)))
+			if (FAILED(pSite->GetSite(IID_IGetDataSource, (void**)&spDataSource)))
 				return DB_E_BADCONVERTFLAG;
-			if (FAILED(spDataSource->GetDataSource(__uuidof(IDBProperties),
+			if (FAILED(spDataSource->GetDataSource(IID_IDBProperties,
 				(IUnknown**)&spProps)))
 				return DB_E_BADCONVERTFLAG;
 			if (FAILED(spProps->GetProperties(1, &set, &ulPropSet, &pPropSet)))
@@ -6208,7 +6208,7 @@ ATLPREFAST_SUPPRESS(6387)
 			return hr;
 		// Ref the created COM object and Auto release it on failure
 		CComPtr<IUnknown> spUnk;
-		hr = pPolyObj->QueryInterface(&spUnk);
+		hr = pPolyObj->QueryInterface(IID_IUnknown, (void**)&spUnk);
 		if (FAILED(hr))
 		{
 			delete pPolyObj; // must hand delete as it is not ref'd
@@ -6220,7 +6220,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (FAILED(hr = pRowsetObj->FInit(pT)))
 			return hr;
 		CComPtr<IUnknown> spOuterUnk;
-		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
+		hr = pT->QueryInterface(IID_IUnknown, (void**)&spOuterUnk);
 		if (FAILED(hr))
 		{
 			return hr;
@@ -6403,8 +6403,8 @@ public:
 				// Get a pointer into the session
 				CComPtr<IGetDataSource> spDataSource;
 				CComPtr<IDBProperties> spProps;
-				if( SUCCEEDED( pT->GetSite( __uuidof(IGetDataSource), (void**)&spDataSource ) ) &&
-					SUCCEEDED( spDataSource->GetDataSource( __uuidof(IDBProperties), (IUnknown**)&spProps ) ) )
+				if( SUCCEEDED( pT->GetSite( IID_IGetDataSource, (void**)&spDataSource ) ) &&
+					SUCCEEDED( spDataSource->GetDataSource( IID_IDBProperties, (IUnknown**)&spProps ) ) )
 				{
 					CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
 					if(!set.AddPropertyID(DBPROP_SQLSUPPORT))
@@ -7034,8 +7034,8 @@ public:
 #define BEGIN_PROVIDER_COLUMN_MAP(theClass) \
 	typedef theClass _Class; \
 	template <class T> \
-	_Ret_count_x_(*pcCols) static ATL::ATLCOLUMNINFO* GetColumnInfo( \
-		_In_opt_ _Post_bytecount_x_(sizeof(T)) T* pv, \
+	static ATL::ATLCOLUMNINFO* GetColumnInfo( \
+		_In_opt_ T* pv, \
 		_Out_ DBORDINAL* pcCols) \
 	{ \
 	UNREFERENCED_PARAMETER(pv); \
@@ -7189,7 +7189,7 @@ public:
 
 template <class T>
 inline void SendColumnSetFailureNotification(
-	_Inout_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
+	_Inout_ T* pT,
 	_In_ HROW hNotifyRow,
 	_In_ typename T::_BindType* pBinding,
 	_In_ CAtlArray<DBORDINAL>& rgColumns)
@@ -7201,7 +7201,7 @@ inline void SendColumnSetFailureNotification(
 
 template <class T, class RowClass>
 inline void SendRowsFirstChangeFailureNotification(
-	_Inout_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
+	_Inout_ T* pT,
 	_In_ RowClass* pRow,
 	_In_ HROW *phNotifyRow,
 	_In_ bool bDeferred)
@@ -7221,7 +7221,7 @@ inline void SendRowsFirstChangeFailureNotification(
 
 template <class T, class RowClass, class MapClass>
 HRESULT TransferData(
-	_In_ _Prepost_bytecount_x_(sizeof(T)) T* pT,
+	_In_ T* pT,
 	_In_ bool bReading,
 	_In_opt_ void* pData,
 	_In_ RowClass* pRow,
@@ -9942,7 +9942,7 @@ public:
 		CComPtr<IInternalConnection> pConn;
 		if (m_spUnkSite != NULL)
 		{
-			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
+			if (SUCCEEDED(m_spUnkSite->QueryInterface(IID_IInternalConnection, (void**)&pConn)))
 				pConn->ReleaseConnection();
 		}
 	}
@@ -9956,7 +9956,7 @@ public:
 		CComPtr<IInternalConnection> pConn;
 		if (pCreator != NULL)
 		{
-			hr = pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn);
+			hr = pCreator->QueryInterface(IID_IInternalConnection, (void**)&pConn);
 			if (SUCCEEDED(hr))
 				hr = pConn->AddConnection();
 		}
@@ -9977,7 +9977,7 @@ public:
 		CComPtr<IInternalConnection> pConn;
 		if (m_spUnkSite != NULL)
 		{
-			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
+			if (SUCCEEDED(m_spUnkSite->QueryInterface(IID_IInternalConnection, (void**)&pConn)))
 				pConn->ReleaseConnection();
 		}
 	}
@@ -10005,7 +10005,7 @@ public:
 		CComPtr<IInternalConnection> pConn;
 		if (pCreator != NULL)
 		{
-			if (SUCCEEDED(pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
+			if (SUCCEEDED(pCreator->QueryInterface(IID_IInternalConnection, (void**)&pConn)))
 				hr = pConn->AddConnection();
 		}
 		return hr;
@@ -10238,7 +10238,7 @@ public:
 
 template <class T, class ReentrantEventSync = CComSharedMutex>
 class IRowsetNotifyCP :
-	public IConnectionPointImpl<T, &__uuidof(IRowsetNotify), CComDynamicUnkArray>,
+	public IConnectionPointImpl<T, &IID_IRowsetNotify, CComDynamicUnkArray>,
 	public ReentrantEventSync
 {
 public:
@@ -10583,7 +10583,7 @@ public:
 		return hr;
 	}
 
-	_Ret_count_x_(*pcCols) static ATLCOLUMNINFO* GetColumnInfo(
+	static ATLCOLUMNINFO* GetColumnInfo(
 		_In_opt_ _Pre_opt_bytecount_x_(sizeof(T)) T* pv,
 		_Out_ DBORDINAL* pcCols)
 	{
@@ -10730,7 +10730,7 @@ public:
 			}
 
 			// Obtain the IErrorRecord Interface
-			hr = spIErrorInfo->QueryInterface(&spIErrorRecords);
+			hr = spIErrorInfo->QueryInterface(IID_IErrorRecords, (void**)&spIErrorRecords);
 			if( SUCCEEDED(hr))
 			{
 				hr = spIErrorRecords->AddErrorRecord(&errorinfo, 0, NULL, spCrtErrInfo, 0);
@@ -10847,7 +10847,7 @@ public:
 		spErrorInfo->SetHelpContext(pT->GetErrorHelpContext(rInfo));
 		spErrorInfo->SetHelpFile(pT->GetErrorHelpFile(rInfo));
 		spErrorInfo->SetSource(pT->GetErrorSource(rInfo));
-		return spErrorInfo->QueryInterface(__uuidof(IErrorInfo), (void**)ppErrorInfo);
+		return spErrorInfo->QueryInterface(IID_IErrorInfo, (void**)ppErrorInfo);
 	}
 
 	STDMETHOD(GetErrorParameters)(
@@ -11067,11 +11067,11 @@ HRESULT InitFromRowset(
 	_Inout_ IUnknown* pSession,
 	_Out_ LONG* pcRowsAffected)
 {
-	CComQIPtr<IOpenRowset> spOpenRowset = pSession;
+	CComQIPtr<IOpenRowset, &IID_IOpenRowset> spOpenRowset = pSession;
 	if (spOpenRowset == NULL)
 		return E_FAIL;
 	CComPtr<IColumnsInfo> spColInfo;
-	HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, __uuidof(IColumnsInfo), 0, NULL, (IUnknown**)&spColInfo);
+	HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, IID_IColumnsInfo, 0, NULL, (IUnknown**)&spColInfo);
 	if (FAILED(hr))
 		return hr;
 	LPOLESTR szColumns = NULL;
diff --git a/include/atldbcli.h b/include/atldbcli.h
index 13be255..b7dc091 100644
--- a/include/atldbcli.h
+++ b/include/atldbcli.h
@@ -505,7 +505,7 @@ public:
 		ATLENSURE_RETURN(pUnk);
 		ATLENSURE_RETURN(pcRecords);
 		CComPtr<ISupportErrorInfo> spSupportErrorInfo;
-		HRESULT hr = pUnk->QueryInterface(&spSupportErrorInfo);
+		HRESULT hr = pUnk->QueryInterface(IID_ISupportErrorInfo, (void**)&spSupportErrorInfo);
 		if (FAILED(hr))
 			return hr;
 
@@ -526,7 +526,7 @@ public:
 		if (hr == S_FALSE)
 			return E_FAIL;
 
-		hr = m_spErrorInfo->QueryInterface(__uuidof(IErrorRecords), (void**)&m_spErrorRecords);
+		hr = m_spErrorInfo->QueryInterface(IID_IErrorRecords, (void**)&m_spErrorRecords);
 		if (FAILED(hr))
 		{
 			// Well we got the IErrorInfo so we'll just treat that as
@@ -599,7 +599,7 @@ ATLPREFAST_SUPPRESS(6387)
 	{
 		return m_spErrorRecords->GetCustomErrorObject(ulRecordNum, riid, ppObject);
 	}
-ATLPREFAST_UNSUPPRESS();
+ATLPREFAST_UNSUPPRESS()
 
 	// Get the IErrorInfo interface for the passed record number
 	HRESULT GetErrorInfo(
@@ -643,7 +643,7 @@ inline void AtlTraceErrorRecords(_In_ HRESULT hrErr = S_OK)
 	LCID lcLocale = GetSystemDefaultLCID();
 
 	hr = ErrorInfo.GetErrorRecords(&cRecords);
-	if (FAILED(hr) && ErrorInfo.m_spErrorInfo == NULL)
+	if (FAILED(hr) || ErrorInfo.m_spErrorInfo == NULL)
 	{
 		ATLTRACE(atlTraceDBClient, 0, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr);
 	}
@@ -1040,7 +1040,7 @@ public:
 	{
 		return nSize;
 	}
-	_Ret_count_x_(nSize) virtual BYTE* GetBuffer() const throw()
+	virtual BYTE* GetBuffer() const throw()
 	{
 		return (BYTE*)m_rgBuffer;
 	}
@@ -1084,7 +1084,7 @@ public:
 	{
 		return m_nSize;
 	}
-	_Ret_count_x_(m_nSize) virtual BYTE* GetBuffer() const throw()
+	virtual BYTE* GetBuffer() const throw()
 	{
 		return m_pBuffer;
 	}
@@ -1152,7 +1152,7 @@ public:
 		if (m_nAccessors > 0)
 		{
 			CComPtr<IAccessor> spAccessor;
-			hr = pUnk->QueryInterface(__uuidof(IAccessor), (void**)&spAccessor);
+			hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 			if (SUCCEEDED(hr))
 			{
 				ATLENSURE_RETURN(m_pAccessorInfo != NULL);
@@ -1346,7 +1346,7 @@ public:
 				break;
 
 				case DBTYPE_HCHAPTER:
-					CComQIPtr<IChapteredRowset> spChapteredRowset = pRowset;
+					CComQIPtr<IChapteredRowset, &IID_IChapteredRowset> spChapteredRowset = pRowset;
 					if (spChapteredRowset != NULL)
 						spChapteredRowset->ReleaseChapter(*(HCHAPTER*)pValue, NULL);
 				break;
@@ -1365,3548 +1365,3546 @@ public:
 	BYTE*               m_pBuffer;
 };
 
-class CXMLAccessor;
 
-///////////////////////////////////////////////////////////////////////////
-// class CRowset
+enum DBBLOBHANDLINGENUM
+{
+	DBBLOBHANDLING_DEFAULT,
+	DBBLOBHANDLING_NOSTREAMS,
+	DBBLOBHANDLING_SKIP
+};
 
-template <class TAccessor = CAccessorBase>
-class CRowset
+///////////////////////////////////////////////////////////////////////////
+// CDynamicAccessor
+class CDynamicAccessor :
+	public CAccessorBase
 {
-// Constructors and Destructors
 public:
-	CRowset()
+	CDynamicAccessor(
+		_In_ DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT,
+		_In_ DBLENGTH nBlobSize = 8000)
 	{
-		m_pXMLAccessor = NULL;
-		m_pAccessor = NULL;
-		m_hRow      = 0;
-	}
-	CRowset(_In_opt_ IRowset* pRowset)
+		ATLASSERT( eBlobHandling == DBBLOBHANDLING_DEFAULT ||
+				   eBlobHandling == DBBLOBHANDLING_NOSTREAMS ||
+				   eBlobHandling == DBBLOBHANDLING_SKIP );
+
+		m_nColumns        = 0;
+		m_pColumnInfo     = NULL;
+		m_pStringsBuffer  = NULL;
+		m_eBlobHandling   = eBlobHandling;
+		m_nBlobSize       = nBlobSize;
+		m_pfClientOwnedMemRef = NULL;
+	};
+
+	~CDynamicAccessor()
 	{
-		m_pXMLAccessor = NULL;
-		m_pAccessor = NULL;
-		m_hRow      = 0;
-		m_spRowset  = pRowset;
+		Close();
 	}
-	~CRowset()
+
+	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
 	{
-		Close();
+		FreeRecordMemory( (IRowset*) pUnk );
+		return CAccessorBase::ReleaseAccessors(pUnk);
 	}
 
-	HRESULT GetXMLColumnInfo(_Inout_ CSimpleStringW& strOutput) throw()
+	bool SetBlobHandling(_In_ DBBLOBHANDLINGENUM eBlobHandling)
 	{
-		ATLASSUME(m_spRowset != NULL);
-		HRESULT hr;
-		if( m_pXMLAccessor == NULL )
+		switch( eBlobHandling )
 		{
-			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
-			if( m_pXMLAccessor == NULL )
-				return E_OUTOFMEMORY;
-			hr = m_pXMLAccessor->BindColumns( m_spRowset );
-			if( FAILED(hr) )
-			{
-				delete m_pXMLAccessor;
-				m_pXMLAccessor = NULL;
-				return hr;
-			}
+		case DBBLOBHANDLING_DEFAULT:
+		case DBBLOBHANDLING_NOSTREAMS:
+		case DBBLOBHANDLING_SKIP:
+			m_eBlobHandling = eBlobHandling;
+			return true;
+		default:
+			ATLASSERT( FALSE ); // invalid blob handling mode!!!
+			return false;
 		}
+	}
 
-		ATLASSUME( m_pXMLAccessor != NULL );
+	const DBBLOBHANDLINGENUM GetBlobHandling() const
+	{
+		return m_eBlobHandling;
+	}
 
-		return m_pXMLAccessor->GetXMLColumnData( strOutput );
+	void SetBlobSizeLimit(_In_ DBLENGTH nBlobSize)
+	{
+		m_nBlobSize = nBlobSize;
 	}
 
-	HRESULT GetXMLRow(
-		_Inout_ CSimpleStringW& strOutput,
-		_In_ bool bAppend = false) throw()
+	const DBLENGTH GetBlobSizeLimit() const
 	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_hRow != 0);
+		return m_nBlobSize;
+	}
 
-		HRESULT hr;
-		if( m_pXMLAccessor == NULL )
-		{
-			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
-			if( m_pXMLAccessor == NULL )
-				return E_OUTOFMEMORY;
-			hr = m_pXMLAccessor->BindColumns( m_spRowset );
-			if( FAILED(hr) )
-			{
-				delete m_pXMLAccessor;
-				m_pXMLAccessor = NULL;
-				return hr;
-			}
-		}
+//	void FreeRecordMemory(int , IRowset* ) throw() {}
 
-		ATLASSUME( m_pXMLAccessor != NULL );
+	void Close() throw()
+	{
+		CoTaskMemFree(m_pColumnInfo);
+		m_pColumnInfo = NULL;
 
-		hr = m_spRowset->GetData(m_hRow, m_pXMLAccessor->GetHAccessor(0), m_pXMLAccessor->GetBuffer());
-		if( FAILED(hr) )
-			return hr;
+		// Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
+		// if necessary
+		CoTaskMemFree(m_pStringsBuffer);
+		m_pStringsBuffer = NULL;
 
-		hr = m_pXMLAccessor->GetXMLRowData( strOutput, bAppend );
+		delete [] m_pBuffer;
+		m_pBuffer = NULL;
 
-		m_pXMLAccessor->FreeRecordMemory( GetInterface() );
-		return hr;
+		delete [] m_pfClientOwnedMemRef;
+		m_pfClientOwnedMemRef = NULL;
+
+		m_nColumns = 0;
+
+		CAccessorBase::Close();
 	}
 
-	// Release any retrieved row handles and then release the rowset
-	void Close() throw()
+	bool GetColumnType(
+		_In_ DBORDINAL nColumn,
+		_Out_ DBTYPE* pType) const throw()
 	{
-		if( m_pXMLAccessor != NULL )
+		if (TranslateColumnNo(nColumn))
 		{
-			if (m_spRowset != NULL)
-				m_pXMLAccessor->ReleaseAccessors( m_spRowset );
-			delete m_pXMLAccessor;
-			m_pXMLAccessor = NULL;
+			ATLENSURE_RETURN_VAL(pType, false);
+			*pType = m_pColumnInfo[nColumn].wType;
+			return true;
 		}
-		if (m_spRowset != NULL)
+		else
+			return false;
+	}
+
+	bool GetColumnFlags(
+		_In_ DBORDINAL nColumn,
+		_Out_ DBCOLUMNFLAGS* pFlags) const throw()
+	{
+		if (TranslateColumnNo(nColumn))
 		{
-			m_pAccessor->FreeRecordMemory(m_spRowset);
-			ReleaseRows();
-			m_spRowset.Release();
-			m_spRowsetChange.Release();
+			ATLENSURE_RETURN_VAL(pFlags, false);
+			*pFlags = m_pColumnInfo[nColumn].dwFlags;
+			return true;
 		}
+		else
+			return false;
 	}
-	// Addref the current row
-	HRESULT AddRefRows() throw()
+	bool GetOrdinal(
+		_In_z_ const CHAR* pColumnName,
+		_Out_ DBORDINAL* pOrdinal) const throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			ATLENSURE_RETURN_VAL(pOrdinal, false);
+			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
+			return true;
+		}
+		else
+			return false;
 	}
-	// Release the current row
-	HRESULT ReleaseRows() throw()
+	bool GetOrdinal(
+		_In_z_ const WCHAR* pColumnName,
+		_Out_ DBORDINAL* pOrdinal) const throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		HRESULT hr = S_OK;
-
-		if (m_hRow != 0)
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
-			m_hRow = 0;
+			ATLENSURE_RETURN_VAL(pOrdinal, false);
+			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
+			return true;
 		}
-		return hr;
+		else
+			return false;
 	}
 
-	CRowset<>* GetRowsetBase() throw()
+	void* GetValue(_In_ DBORDINAL nColumn) const throw()
 	{
-		return (CRowset<>*)this;
+		if (TranslateColumnNo(nColumn))
+			return _GetDataPtr(nColumn);
+		else
+			return NULL;
 	}
 
-	// Compare two bookmarks with each other
-	HRESULT Compare(
-		_In_ const CBookmarkBase& bookmark1,
-		_In_ const CBookmarkBase& bookmark2,
-		_Out_ DBCOMPARE* pComparison) const throw()
+	void* GetValue(_In_z_ const CHAR* pColumnName) const throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		CComPtr<IRowsetLocate> spLocate;
-		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
-		if (FAILED(hr))
-			return hr;
-
-		return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
-			bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+			return _GetDataPtr(nColumn);
+		else
+			return NULL;    // Not Found
 	}
 
-	// Compare the passed hRow with the current row
-	HRESULT IsSameRow(_In_ HROW hRow) const throw()
+	void* GetValue(_In_z_ const WCHAR* pColumnName) const throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		if (m_hRow == hRow)
-			return S_OK;
-
-		CComPtr<IRowsetIdentity> spRowsetIdentity;
-		HRESULT hr = m_spRowset.QueryInterface(&spRowsetIdentity);
-		if (FAILED(hr))
-			return hr;
-
-		return spRowsetIdentity->IsSameRow(m_hRow, hRow);
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+			return _GetDataPtr(nColumn);
+		else
+			return NULL;    // Not Found
 	}
 
-	// Move to the previous record
-	HRESULT MovePrev() throw()
+	template <class ctype>
+	void _GetValue(
+		_In_ DBORDINAL nColumn,
+		_Out_ ctype* pData) const throw()
 	{
-		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		return MoveNext(-2);
+		ATLASSUME(pData != NULL);
+		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
+		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
+		*pData = *pBuffer;
 	}
-
-	// Move to the next record
-	HRESULT MoveNext() throw()
+	template <class ctype>
+	void _SetValue(
+		_In_ DBORDINAL nColumn,
+		_In_ const ctype& data) throw()
 	{
-		return MoveNext(0);
+		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
+		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
+		*pBuffer = (ctype)data;
 	}
-
-	// Move lSkip records forward or backward
-	HRESULT MoveNext(
-		_In_ LONG lSkip,
-		_In_ bool bForward = true) throw()
+	template <class ctype>
+	bool GetValue(
+		_In_ DBORDINAL nColumn,
+		_Out_ ctype* pData) const throw()
 	{
-		HRESULT hr;
-		DBCOUNTITEM ulRowsFetched = 0;
-
-		// Check the data was opened successfully and the accessor
-		// has been set.
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		// Release a row if one is already around
-		ReleaseRows();
-
-		// Get the row handle
-		HROW* phRow = &m_hRow;
-		hr = m_spRowset->GetNextRows(0, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
-		if (hr != S_OK)
-			return hr;
-
-		// Get the data
-		hr = GetData();
-		if (FAILED(hr))
+		ATLENSURE_RETURN_VAL(pData, false);
+		if (TranslateColumnNo(nColumn))
 		{
-			ATLTRACE(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
-			ReleaseRows();
+			_GetValue(nColumn, pData);
+			return true;
 		}
-		return hr;
+		return false;
 	}
-
-	// Move to the first record
-	HRESULT MoveFirst() throw()
+	template <class ctype>
+	bool SetValue(
+		_In_ DBORDINAL nColumn,
+		_In_ const ctype& data) throw()
 	{
-		HRESULT hr;
-
-		// Check the data was opened successfully and the accessor
-		// has been set.
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		// Release a row if one is already around
-		ReleaseRows();
-
-		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		hr = m_spRowset->RestartPosition(NULL);
-		if (FAILED(hr))
-			return hr;
-
-		// Get the data
-		return MoveNext();
+		if (TranslateColumnNo(nColumn))
+		{
+			_SetValue(nColumn, data);
+			return true;
+		}
+		return false;
 	}
-
-	// Move to the last record
-	HRESULT MoveLast() throw()
+	template <class ctype>
+	bool GetValue(
+		_In_z_ const CHAR *pColumnName,
+		_Out_ ctype* pData) const throw()
 	{
-		// Check the data was opened successfully and the accessor
-		// has been set.
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-
-		// Release a row if one is already around
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-
-		HRESULT hr;
-		DBCOUNTITEM ulRowsFetched = 0;
-		HROW* phRow = &m_hRow;
-
-		// Restart the rowset position and then move backwards
-
-		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		m_spRowset->RestartPosition(NULL);
-		hr = m_spRowset->GetNextRows(NULL, -1, 1, &ulRowsFetched, &phRow);
-		if (hr != S_OK)
-			return hr;
-
-		// Get the data
-		hr = GetData();
-		if (FAILED(hr))
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
+		ATLENSURE_RETURN_VAL(pData, false);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			ATLTRACE(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
-			ReleaseRows();
+			_GetValue(nColumn, pData);
+			return true;
 		}
-
-		return S_OK;
+		return false;
 	}
-	// Move to the passed bookmark
-	HRESULT MoveToBookmark(
-		_In_ const CBookmarkBase& bookmark,
-		_In_ LONG lSkip = 0) throw()
+	template <class ctype>
+	bool GetValue(
+		_In_z_ const WCHAR *pColumnName,
+		_Out_ ctype* pData) const throw()
 	{
-		// Check the data was opened successfully and the accessor
-		// has been set.
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-
-		CComPtr<IRowsetLocate> spLocate;
-		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
-		if (FAILED(hr))
-			return hr;
-
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		// Release a row if one is already around
-		ReleaseRows();
-
-		DBCOUNTITEM ulRowsFetched = 0;
-		HROW* phRow = &m_hRow;
-		hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
-			lSkip, 1, &ulRowsFetched, &phRow);
-		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
-		if (hr != S_OK)
-			return hr;
-
-		// Get the data
-		hr = GetData();
-		if (FAILED(hr))
+		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
+		ATLENSURE_RETURN_VAL(pData, false);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			ATLTRACE(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
-			ReleaseRows();
+			_GetValue(nColumn, pData);
+			return true;
 		}
-
-		return S_OK;
+		return false;
 	}
-
-	// Get the data for the current record
-	HRESULT GetData() throw()
+	template <class ctype>
+	bool SetValue(
+		_In_z_ const CHAR *pColumnName,
+		_In_ const ctype& data) throw()
 	{
-		HRESULT hr = S_OK;
-		ATLASSUME(m_pAccessor != NULL);
-
-		ULONG nAccessors = m_pAccessor->GetNumAccessors();
-		for (ULONG i=0; i<nAccessors; i++)
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			if (m_pAccessor->IsAutoAccessor(i))
-			{
-				hr = GetData(i);
-				if (FAILED(hr))
-					return hr;
-			}
+			_SetValue(nColumn, data);
+			return true;
 		}
-		return hr;
+		return false;
 	}
-
-	// Get the data for the passed accessor. Use for a non-auto accessor
-	HRESULT GetData(_In_ int nAccessor) throw()
+	template <class ctype>
+	bool SetValue(
+		_In_z_ const WCHAR *pColumnName,
+		_In_ const ctype& data) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-		ATLASSUME(m_hRow != 0);
-
-		// Note that we are using the specified buffer if it has been set,
-		// otherwise we use the accessor for the data.
-		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			_SetValue(nColumn, data);
+			return true;
+		}
+		return false;
 	}
-
-	// Get the data for the passed accessor. Use for a non-auto accessor
-	HRESULT GetDataHere(
-		_In_ int nAccessor,
-		_Out_ void* pBuffer) throw()
+	bool GetLength(
+		_In_ DBORDINAL nColumn,
+		_Out_ DBLENGTH* pLength) const
 	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-		ATLASSUME(m_hRow != 0);
-
-		// Note that we are using the specified buffer if it has been set,
-		// otherwise we use the accessor for the data.
-		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
+		ATLENSURE(pLength != NULL);
+		if (TranslateColumnNo(nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
+			return true;
+		}
+		else
+			return false;
 	}
-
-	HRESULT GetDataHere(_Out_ void* pBuffer) throw()
+	bool SetLength(
+		_In_ DBORDINAL nColumn,
+		_In_ DBLENGTH nLength) throw()
 	{
-		HRESULT hr = S_OK;
-
-		ULONG nAccessors = m_pAccessor->GetNumAccessors();
-		for (ULONG i=0; i<nAccessors; i++)
+		if (TranslateColumnNo(nColumn))
 		{
-			hr = GetDataHere(i, pBuffer);
-			if (FAILED(hr))
-				return hr;
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
+			return true;
 		}
-		return hr;
+		else
+			return false;
 	}
-
-	// Insert the current record
-	HRESULT Insert(
-		_In_ int nAccessor = 0,
-		_In_ bool bGetHRow = false) throw()
+	bool GetLength(
+		_In_z_ const CHAR* pColumnName,
+		_Out_ DBLENGTH* pLength) const
 	{
-		ATLASSUME(m_pAccessor != NULL);
-		HRESULT hr;
-		if (m_spRowsetChange != NULL)
+		ATLENSURE(pColumnName != NULL);
+		ATLENSURE(pLength != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			HROW* pHRow;
-			if (bGetHRow)
-			{
-				ReleaseRows();
-				pHRow = &m_hRow;
-			}
-			else
-				pHRow = NULL;
-
-			hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
-					m_pAccessor->GetBuffer(), pHRow);
-
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
+			return true;
 		}
 		else
-			hr = E_NOINTERFACE;
-
-		return hr;
+			return false;
 	}
-
-	// Delete the current record
-	HRESULT Delete() const throw()
+	bool GetLength(
+		_In_z_ const WCHAR* pColumnName,
+		_Out_ DBLENGTH* pLength) const
 	{
-		ATLASSUME(m_pAccessor != NULL);
-		HRESULT hr;
-		if (m_spRowsetChange != NULL)
-			hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
+		ATLENSURE(pColumnName != NULL);
+		ATLENSURE(pLength != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
+			return true;
+		}
 		else
-			hr = E_NOINTERFACE;
-
-		return hr;
+			return false;
 	}
-
-	// Update the current record
-	HRESULT SetData() const throw()
+	bool SetLength(
+		_In_z_ const CHAR* pColumnName,
+		_In_ DBLENGTH nLength) throw()
 	{
-		ATLASSUME(m_pAccessor != NULL);
-		HRESULT hr = S_OK;
-
-		ULONG nAccessors = m_pAccessor->GetNumAccessors();
-		for (ULONG i=0; i<nAccessors; i++)
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			hr = SetData(i);
-			if (FAILED(hr))
-				return hr;
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
+			return true;
 		}
-		return hr;
+		else
+			return false;
 	}
-
-	// Update the current record with the data in the passed accessor
-	HRESULT SetData(_In_ int nAccessor) const throw()
+	bool SetLength(
+		_In_z_ const WCHAR* pColumnName,
+		_In_ DBLENGTH nLength) throw()
 	{
-		ATLASSUME(m_pAccessor != NULL);
-		HRESULT hr;
-		if (m_spRowsetChange != NULL)
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
-				m_pAccessor->GetBuffer());
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
+			return true;
 		}
 		else
-			hr = E_NOINTERFACE;
-
-		return hr;
+			return false;
 	}
-
-	// Get the data most recently fetched from or transmitted to the data source.
-	// Does not get values based on pending changes.
-	HRESULT GetOriginalData() throw()
+	bool GetStatus(
+		_In_ DBORDINAL nColumn,
+		_Out_ DBSTATUS* pStatus) const
 	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_pAccessor != NULL);
-
-		HRESULT hr = S_OK;
-		CComPtr<IRowsetUpdate> spRowsetUpdate;
-		hr = m_spRowset->QueryInterface(&spRowsetUpdate);
-		if (FAILED(hr))
-			return hr;
-
-		ULONG nAccessors = m_pAccessor->GetNumAccessors();
-		for (ULONG i = 0; i < nAccessors; i++)
+		ATLENSURE(pStatus != NULL);
+		if (TranslateColumnNo(nColumn))
 		{
-			hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
-			if (FAILED(hr))
-				return hr;
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
+			return true;
 		}
-		return hr;
+		else
+			return false;
 	}
-
-	// Get the status of the current row
-	HRESULT GetRowStatus(_Out_ DBPENDINGSTATUS* pStatus) const throw()
+	bool SetStatus(
+		_In_ DBORDINAL nColumn,
+		_In_ DBSTATUS status) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSERT(pStatus != NULL);
-
-		CComPtr<IRowsetUpdate> spRowsetUpdate;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
-		if (FAILED(hr))
-			return hr;
-
-		return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
+		if (TranslateColumnNo(nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
+			return true;
+		}
+		else
+			return false;
 	}
-
-	// Undo any changes made to the current row since it was last fetched or Update
-	// was called for it
-	HRESULT Undo(
-		_In_opt_ DBCOUNTITEM* pcRows = NULL,
-		_Out_opt_ HROW* phRow = NULL,
-		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
+	bool GetStatus(
+		_In_z_ const CHAR* pColumnName,
+		_Out_ DBSTATUS* pStatus) const
 	{
-		ATLASSUME(m_spRowset != NULL);
-
-		CComPtr<IRowsetUpdate> spRowsetUpdate;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
-		if (FAILED(hr))
-			return hr;
-
-		CComHeapPtr<HROW> sprgRows;
-		CComHeapPtr<DBROWSTATUS> spRowStatus;
-
-		if (phRow != NULL)
-			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
+		ATLENSURE(pColumnName != NULL);
+		ATLENSURE(pStatus != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
+			return true;
+		}
 		else
-			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);
-
-		if (phRow != NULL && sprgRows != NULL)
-			*phRow = *sprgRows;
-
-		if (pStatus != NULL && spRowStatus != NULL)
-			*pStatus = *spRowStatus;
-
-		return hr;
+			return false;
 	}
-
-	// Transmits any pending changes made to a row since it was last fetched or Update was
-	// called for it. Also see SetData.
-	HRESULT Update(
-		_In_opt_ DBCOUNTITEM* pcRows = NULL,
-		_Out_opt_ HROW* phRow = NULL,
-		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
+	bool GetStatus(
+		_In_z_ const WCHAR* pColumnName,
+		_Out_ DBSTATUS* pStatus) const
 	{
-		ATLASSUME(m_spRowset != NULL);
-
-		CComPtr<IRowsetUpdate> spRowsetUpdate;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
-		if (FAILED(hr))
-			return hr;
-
-		CComHeapPtr<HROW>           sprgRows;
-		CComHeapPtr<DBROWSTATUS>    spRowStatus;
-
-		if (phRow != NULL)
-			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
+		ATLENSURE(pColumnName != NULL);
+		ATLENSURE(pStatus != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
+			return true;
+		}
 		else
-			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);
-
-		if (phRow != NULL && sprgRows != NULL)
-			*phRow = *sprgRows;
-
-		if (pStatus != NULL && spRowStatus != NULL)
-			*pStatus = *spRowStatus;
-
-		return hr;
+			return false;
 	}
-	// Transmits any pending changes to all rows made since it was last fetched or Update was
-	// alled for it.  Differs from Update in that it will do every row (even if we don't hold
-	// the handle for it).
-	HRESULT UpdateAll(
-		_In_opt_ DBCOUNTITEM* pcRows = NULL,
-		_Deref_opt_out_ HROW** pphRow = NULL,
-		_Deref_opt_out_ DBROWSTATUS** ppStatus = NULL) throw()
+	bool SetStatus(
+		_In_z_ const CHAR* pColumnName,
+		_In_ DBSTATUS status) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-
-		CComPtr<IRowsetUpdate> spRowsetUpdate;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
-		if (FAILED(hr))
-			return hr;
-
-		// Create some temporary variables to help with debugging.
-		DBCOUNTITEM		cRowsReturned = 0;
-		CComHeapPtr<HROW>			sprgRows;
-		CComHeapPtr<DBROWSTATUS>	spRowStatus;
-
-		// Passing zero for the 2nd parameter tells the provider to update ALL pending rows.
-		// The 3rd parameter, prghRows is ignored.
-		hr =  spRowsetUpdate->Update(NULL, 0, NULL, &cRowsReturned, &sprgRows, &spRowStatus);
-
-		// NOTE, the user must CoTaskMemFree *pphRow and *ppStatus after return, if they
-		// are non-NULL.  Otherwise, we'll CoTaskMemFree if they are NULL.
-		if (pcRows != NULL)
-			*pcRows = cRowsReturned;
-
-		if (pphRow != NULL)
-			*pphRow = sprgRows.Detach();
-
-		if (ppStatus != NULL)
-			*ppStatus = spRowStatus.Detach();
-
-		return hr;
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
+		{
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
+			return true;
+		}
+		else
+			return false;
 	}
-
-	// Get the approximate position of the row corresponding to the passed bookmark
-	HRESULT GetApproximatePosition(
-		_In_ const CBookmarkBase* pBookmark,
-		_Out_opt_ DBCOUNTITEM* pPosition,
-		_Out_opt_ DBCOUNTITEM* pcRows) throw()
+	bool SetStatus(
+		_In_z_ const WCHAR* pColumnName,
+		_In_ DBSTATUS status) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-
-		CComPtr<IRowsetScroll> spRowsetScroll;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
-		if (SUCCEEDED(hr))
+		ATLASSERT(pColumnName != NULL);
+		DBORDINAL nColumn;
+		if (GetInternalColumnNo(pColumnName, &nColumn))
 		{
-			if (pBookmark != NULL)
-				hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
-						pPosition, pcRows);
-			else
-				hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);
-
+			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
+			return true;
 		}
+		else
+			return false;
+	}
+
+	// Returns true if a bookmark is available
+	HRESULT GetBookmark(_Inout_ CBookmark<>* pBookmark) const throw()
+	{
+		ATLENSURE_RETURN(pBookmark);
+		HRESULT hr;
+		if (m_pColumnInfo->iOrdinal == 0)
+			hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
+		else
+			hr = E_FAIL;
 		return hr;
+	}
 
+	DBORDINAL GetColumnCount() const throw()
+	{
+		return m_nColumns;
 	}
-	// Move to a fractional position in the rowset
-	HRESULT MoveToRatio(
-		_In_ DBCOUNTITEM nNumerator,
-		_In_ DBCOUNTITEM nDenominator,
-		_In_ bool bForward = true) throw()
+
+	LPOLESTR GetColumnName(_In_ DBORDINAL nColumn) const throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		DBCOUNTITEM nRowsFetched;
+		if (TranslateColumnNo(nColumn))
+			return m_pColumnInfo[nColumn].pwszName;
+		else
+			return NULL;
+	}
 
-		CComPtr<IRowsetScroll> spRowsetScroll;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
-		if (FAILED(hr))
-			return hr;
+	ATL_DEPRECATED("CDynamicAccessor::GetColumnInfo must be passed an array of string buffers too.")
+	HRESULT GetColumnInfo(
+		_Inout_ IRowset* pRowset,
+		_In_opt_ DBORDINAL* pColumns,
+		_Deref_opt_out_ DBCOLUMNINFO** ppColumnInfo);
 
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-		HROW* phRow = &m_hRow;
-		hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
-			&nRowsFetched, &phRow);
-		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
-		if (hr == S_OK)
-			hr = GetData();
+ATLPREFAST_SUPPRESS(6387)
+	HRESULT GetColumnInfo(
+		_Inout_ IRowset* pRowset,
+		_Out_ DBORDINAL* pColumns,
+		_Deref_out_  DBCOLUMNINFO** ppColumnInfo,
+		_Deref_out_z_ OLECHAR** ppStringsBuffer) throw()
+	{
+		CComPtr<IColumnsInfo> spColumnsInfo;
+		HRESULT hr = pRowset->QueryInterface(IID_IColumnsInfo, (void**)&spColumnsInfo);
+		if (SUCCEEDED(hr))
+			hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);
 
 		return hr;
 	}
-
-	HRESULT FindNextRow(
-		_In_ DBCOMPAREOP op,
-		_In_ BYTE* pData,
-		_In_ DBTYPE wType,
-		_In_ DBLENGTH nLength,
-		_In_ BYTE bPrecision,
-		_In_ BYTE bScale,
-		_In_ BOOL bSkipCurrent = TRUE,
-		_In_opt_ CBookmarkBase* pBookmark = NULL) throw()
+ATLPREFAST_UNSUPPRESS()
+	
+	HRESULT AddBindEntry(_In_ const DBCOLUMNINFO& info) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
-		DBBINDING   binding;
-		HRESULT     hr;
-		HACCESSOR   hAccessor;
-		DBCOUNTITEM ulRowsFetched = 0;
-		HROW*       phRow = &m_hRow;
-		DBLENGTH    cbBookmark;
-		BYTE*       pBookmarkBuffer;
-		CComQIPtr<IAccessor, &__uuidof(IAccessor)>        spAccessor(m_spRowset);
-		CComQIPtr<IRowsetFind, &__uuidof(IRowsetFind)>    spRowsetFind(m_spRowset);
-
-		if (spAccessor == NULL || spRowsetFind == NULL)
-			return E_NOINTERFACE;
-
-		TAccessor::Bind(&binding, 1, wType, nLength, bPrecision, bScale, DBPARAMIO_NOTPARAM, 0);
-		hr = CAccessorBase::BindEntries(&binding, 1, &hAccessor, nLength, spAccessor);
-		if (FAILED(hr))
-			return hr;
-
-		if (pBookmark == NULL)
-		{
-			cbBookmark = 0;
-			pBookmarkBuffer = NULL;
-		}
-		else
+		if ((m_nColumns + 1 < m_nColumns))
 		{
-			cbBookmark = pBookmark->GetSize();
-			pBookmarkBuffer = pBookmark->GetBuffer();
+			return E_OUTOFMEMORY;
 		}
+		DBCOLUMNINFO* pTempInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemRecalloc(m_pColumnInfo, (m_nColumns + 1), sizeof(DBCOLUMNINFO));
+		if (pTempInfo == NULL)
+			return E_OUTOFMEMORY;
+		m_pColumnInfo = pTempInfo;
+		m_pColumnInfo[m_nColumns] = info;
+		m_nColumns++;
 
-		hr = spRowsetFind->FindNextRow(DB_NULL_HCHAPTER, hAccessor, pData, op, cbBookmark, pBookmarkBuffer,
-					bSkipCurrent, 1,  &ulRowsFetched, &phRow);
-		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
-		if (hr != S_OK)
-			return hr;
-
-		// Get the data
-		hr = GetData();
-		spAccessor->ReleaseAccessor(hAccessor, NULL);
-		if (FAILED(hr))
-		{
-			ATLTRACE(_T("ATL: GetData from FindNextRows failed - HRESULT = 0x%X\n"),hr);
-			ReleaseRows();
-		}
 		return S_OK;
 	}
 
-// Implementation
-	static const IID& GetIID() throw()
+	bool NoBindOnNullRowset() const throw()
 	{
-		return __uuidof(IRowset);
+		return true;
 	}
 
-	IRowset* GetInterface() const throw()
+// Implementation
+	// Free's any columns in the current record that need to be freed.
+	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
+	void FreeRecordMemory(_Inout_ IRowset* pRowset) throw()
 	{
-		return m_spRowset;
-	}
+		ULONG i;
 
-	IRowset** GetInterfacePtr() throw()
-	{
-		return &m_spRowset;
-	}
+		for (i = 0; i < m_nColumns; i++)
+		{
+			if( m_pfClientOwnedMemRef != NULL && m_pfClientOwnedMemRef[i] == true )
+			{
+				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
+				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
+				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+				if( *(DBSTATUS*)( m_pBuffer + nOffset ) != DBSTATUS_S_ISNULL )
+				{
+					void* pRef = _GetDataPtr(i);
 
-	void SetupOptionalRowsetInterfaces() throw()
-	{
-		// Cache IRowsetChange if available
-		if (m_spRowset != NULL)
-			m_spRowset->QueryInterface(&m_spRowsetChange);
+					if( pRef != NULL && *(void**)pRef != NULL )
+					{
+						CoTaskMemFree( *(void**)_GetDataPtr(i) );
+						*(void**)pRef = NULL;
+					}
+				}
+			}
+			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN || m_pColumnInfo[i].wType == DBTYPE_IDISPATCH )
+			{
+				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
+				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
+				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
+				if( *(DBSTATUS*)( m_pBuffer + nOffset ) == DBSTATUS_S_OK )
+					CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
+			}
+			else
+			{
+				CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
+			}
+		}
 	}
-
-	HRESULT BindFinished() const throw()
+	void ClearRecordMemory() throw()
 	{
-		return S_OK;
+		for (ULONG i = 0; i < m_nColumns; i++)
+		{
+			memset((BYTE*)_GetDataPtr(i), 0, m_pColumnInfo[i].ulColumnSize);
+		}
 	}
 
-	void SetAccessor(_In_opt_ TAccessor* pAccessor) throw()
+	void* _GetDataPtr(_In_ DBORDINAL nColumn) const throw()
 	{
-		m_pAccessor = pAccessor;
+		return m_pBuffer + (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
 	}
+	bool GetInternalColumnNo(
+		_In_z_ const CHAR* pColumnName,
+		_Out_ DBORDINAL* pColumn) const
+	{
+		ATLENSURE(pColumnName != NULL);
+		ATLENSURE(pColumn != NULL);
+		ULONG       i;
+		size_t      nSize = (lstrlenA(pColumnName) + 1) * sizeof(OLECHAR);
+		CComBSTR	bstrColumnName(pColumnName);
 
-	CComPtr<IRowset>        m_spRowset;
-	CComPtr<IRowsetChange>  m_spRowsetChange;
-	TAccessor*				m_pAccessor;
-	HROW                    m_hRow;
-	CXMLAccessor* m_pXMLAccessor;
-};
-
-///////////////////////////////////////////////////////////////////////////
-// class CBulkRowset
-
-template <class TAccessor>
-class CBulkRowset : 
-	public CRowset<TAccessor>
-{
-public:
-	CBulkRowset()
-	{
-		// Default the number of rows to bulk fetch to 10
-		m_nRows = 10;
-		m_hr    = S_OK;
-		m_phRow = NULL;
+		// Search through the columns trying to find a match
+		for (i = 0; i < m_nColumns; i++)
+		{
+			ATLASSUME(m_pColumnInfo != NULL);
+			if (m_pColumnInfo[i].pwszName != NULL &&
+				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
+			{
+				break;
+			}
+		}
+		if (i < m_nColumns && pColumn)
+		{
+			*pColumn = i;
+			return true;
+		}
+		else
+		{
+			return false;   // Not Found
+		}
 	}
-
-	~CBulkRowset()
+	bool GetInternalColumnNo(
+		_In_z_ const WCHAR* pColumnName,
+		_Out_ DBORDINAL* pColumn) const
 	{
-		Close();
-	}
+		ATLENSURE(pColumnName != NULL);
+		ATLASSERT(pColumn != NULL);
+		ULONG       i;
+		size_t      nSize = (wcslen(pColumnName) + 1) * sizeof(OLECHAR);
+		CComBSTR	bstrColumnName(pColumnName);
 
-	void Close() throw()
-	{
-		if (m_spRowset != NULL)
+		// Search through the columns trying to find a match
+		for (i = 0; i < m_nColumns; i++)
 		{
-			m_pAccessor->FreeRecordMemory(m_spRowset);
-			ReleaseRows();
+			ATLASSUME(m_pColumnInfo != NULL);
+			if (m_pColumnInfo[i].pwszName != NULL &&
+				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
+				break;
 		}
-		CRowset<TAccessor>::Close();
 
-		delete [] m_phRow;
-		m_phRow = NULL;
-
-		m_hr = S_OK;
-	}
-	// Set the number of row handles that will be retrieved in each
-	// bulk row fetch. The default is 10 and this function must be called
-	// before Open if you wish to change it.
-	void SetRows(_In_ DBROWCOUNT nRows) throw()
-	{
-		if (nRows == 0)
-			nRows = 10;
-		if (nRows != m_nRows)
+		if (i < m_nColumns && pColumn)
 		{
-			// This function must be called before the memory is allocated
-			// during binding or between a Close() and a Open()
-			delete m_phRow;
-			m_phRow = NULL;
-			m_nRows = nRows;
+			*pColumn = i;
+			return true;
 		}
+
+		return false;   // Not Found
 	}
-	// AddRef all the currently retrieved row handles
-	HRESULT AddRefRows() throw()
-	{
-		ATLASSUME(m_spRowset != NULL);
-		return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
-	}
-	// Release all the currently retrieved row handles
-	HRESULT ReleaseRows() throw()
-	{
-		ATLASSUME(m_spRowset != NULL);
-		// We're going to Release the rows so reset the current row position
-		m_nCurrentRow = 0;
-		m_hRow        = 0;
-		DBCOUNTITEM nCurrentRows = m_nCurrentRows;
-		m_nCurrentRows = 0;
-		return m_spRowset->ReleaseRows(nCurrentRows, m_phRow, NULL, NULL, NULL);
-	}
-	// Move to the first record
-	HRESULT MoveFirst() throw()
+
+	// Set up the binding structure pointed to by pBindings based upon
+	// the other passed parameters.
+	static void BindEx(
+		_Inout_ DBBINDING* pBinding,
+		_In_ DBORDINAL nOrdinal,
+		_In_ DBTYPE wType,
+		_In_ DBLENGTH nLength,
+		_In_ BYTE nPrecision,
+		_In_ BYTE nScale,
+		_In_ DBPARAMIO eParamIO,
+		_In_ DBBYTEOFFSET nDataOffset,
+		_In_ DBBYTEOFFSET nLengthOffset,
+		_In_ DBBYTEOFFSET nStatusOffset,
+		_In_opt_ DBOBJECT* pdbobject,
+		_In_ DBMEMOWNER dwMemOwner,
+		_In_ bool fSkipData = false )
 	{
-		ATLASSUME(m_spRowset != NULL);
+		ATLENSURE(pBinding != NULL);
 
-		m_hr = S_OK;
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		HRESULT hr = m_spRowset->RestartPosition(NULL);
-		if (FAILED(hr))
-			return hr;
+		pBinding->dwMemOwner    = dwMemOwner;
 
-		// Get the data
-		return MoveNext(0);
-	}
-	// Move to the last record
-	HRESULT MoveLast() throw()
-	{
-		m_hr = S_OK;
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-		m_hr = S_OK;
-		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		return CRowset<TAccessor>::MoveLast();
-	}
-	// Move to the next record
-	HRESULT MoveNext() throw()
-	{
-		return MoveNext(0);
-	}
-	// Move to the previous record
-	HRESULT MovePrev() throw()
-	{
-		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
-		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
-		return MoveNext(-2);
-	}
-	// Move lSkip records forward or backward
-	HRESULT MoveNext(
-		_In_ DBROWOFFSET lSkip,
-		_In_ bool bForward = true) throw()
-	{
-		ATLASSUME(m_spRowset != NULL);
-		ATLASSUME(m_phRow    != NULL);
+		pBinding->pObject       = pdbobject;
 
-		m_pAccessor->FreeRecordMemory(m_spRowset);
+		pBinding->eParamIO      = eParamIO;
+		pBinding->iOrdinal      = nOrdinal;
+		pBinding->wType         = wType;
+		pBinding->bPrecision    = nPrecision;
+		pBinding->bScale        = nScale;
+		pBinding->dwFlags       = 0;
 
-		// Calculate the record index in the buffer
-		DBROWOFFSET nNewRow = m_nCurrentRow + lSkip + (bForward ? 1 : -1);
+		pBinding->obValue       = 0;
+		pBinding->obLength      = 0;
+		pBinding->obStatus      = 0;
+		pBinding->pTypeInfo     = NULL;
+		pBinding->pBindExt      = NULL;
+		pBinding->cbMaxLen      = nLength;
 
-		bool bFetchNewRows = false;
-		// Is the row in the buffer?
-		// else adjust the skip value
-		if (m_nCurrentRows == 0)
+		pBinding->dwPart = 0;
+
+		if ( ! fSkipData ) // skip column data
 		{
-			//lSkip = 0;
-			bFetchNewRows = true;
+			pBinding->dwPart |= DBPART_VALUE;
+			pBinding->obValue = nDataOffset;
 		}
-		else if (nNewRow >= (DBROWOFFSET)m_nCurrentRows)
+		if (nLengthOffset != 0) // skip length
 		{
-			bFetchNewRows = true;
-			lSkip = nNewRow - m_nCurrentRows + (bForward ? 0 : (2 - m_nRows));
+			pBinding->dwPart |= DBPART_LENGTH;
+			pBinding->obLength = nLengthOffset;
 		}
-		else if (nNewRow < 0)
+		if (nStatusOffset != 0) // skip status
 		{
-			lSkip = nNewRow - (m_nCurrentRows - m_nCurrentRow) + (bForward ? 0 : (2 - m_nRows));
-			bFetchNewRows = true;
+			pBinding->dwPart |= DBPART_STATUS;
+			pBinding->obStatus = nStatusOffset;
 		}
+	}
 
-		if (bFetchNewRows)
-		{
-			nNewRow = 0;
-			// If we've reached the end of the buffer and we had a non S_OK HRESULT from
-			// the last call to GetNextRows then return that HRESULT now.
-			if (m_hr != S_OK && m_hr != DB_S_ROWLIMITEXCEEDED)
-				return m_hr;
+	HRESULT GetRowsetProperties(
+		_Inout_ IUnknown* pUnk,
+		_In_ DBPROPID* prgPropertyIDs,
+		_Out_cap_(nPropCount) BOOL* pbValues,
+		_In_ ULONG nPropCount) throw()
+	{
+		ULONG t;
 
-			// We've finished with these rows so we need some more
-			// First release any HROWs that we have
-			ReleaseRows();
+		ATLENSURE_RETURN(pUnk != NULL);
+		ATLENSURE_RETURN(pbValues != NULL);
+		ATLASSERT(prgPropertyIDs != NULL);
+		ATLASSERT(nPropCount > 0);
 
-			// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
-			// DBPROP_CANSCROLLBACKWARDS properties have not been set and the lSkip offset is negative.
-			m_hr = m_spRowset->GetNextRows(NULL, lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
+		CComPtr<IRowsetInfo> spRowsetInfo;
+		HRESULT hr = pUnk->QueryInterface(IID_IRowsetInfo, (void**)&spRowsetInfo);
 
-			// If we have an error HRESULT or we haven't retrieved any rows then return
-			// the HRESULT now.
-			if (FAILED(m_hr) || m_nCurrentRows == 0)
-				return m_hr;
-			if (!bForward)
-				nNewRow = m_nCurrentRows - 1;
-		}
+		for( t = 0; t < nPropCount; t++ )
+			pbValues[t] = FALSE;
 
-		// Get the data for the current row
-		m_hRow = m_phRow[m_nCurrentRow = nNewRow];
-		return GetData();
-	}
-	// Move to the passed bookmark
-	HRESULT MoveToBookmark(
-		_In_ const CBookmarkBase& bookmark,
-		_In_ DBCOUNTITEM lSkip = 0) throw()
-	{
-		ATLASSUME(m_spRowset != NULL);
-		CComPtr<IRowsetLocate> spLocate;
-		HRESULT hr = m_spRowset->QueryInterface(&spLocate);
 		if (FAILED(hr))
-			return hr;
+			ATLASSERT(0); // unable to retrieve IRowsetInfo interface
+		else
+		{
+			DBPROPIDSET            rgPropertyIDSets[1];
+			ULONG                  cPropSets        = 0;
+			CComHeapPtr<DBPROPSET> rgPropSets;
 
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-		m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
-			lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
-		if( (m_hr != S_OK || m_nCurrentRows == 0 ) && m_hr != DB_S_ENDOFROWSET)
-			return m_hr;
+			// Set up the Property ID Set.
+			rgPropertyIDSets[0].rgPropertyIDs       = prgPropertyIDs;
+			rgPropertyIDSets[0].cPropertyIDs        = nPropCount;
+			rgPropertyIDSets[0].guidPropertySet     = DBPROPSET_ROWSET;
 
-		// Get the data
-		m_hRow = m_phRow[m_nCurrentRow];
-		return GetData();
+			hr = spRowsetInfo->GetProperties(	1,					// cPropertyIDSets
+												rgPropertyIDSets,	// rgPropertyIDSets
+												&cPropSets,         // pcPropSets
+												&rgPropSets );      // prgPropSets
+
+			if( SUCCEEDED(hr) )
+			{
+				for( t = 0; t < __min(rgPropSets[0].cProperties, nPropCount); t++ )
+					pbValues[t] = V_BOOL(&rgPropSets[0].rgProperties[t].vValue);
+
+				if( rgPropSets[0].rgProperties )
+					CoTaskMemFree(rgPropSets[0].rgProperties);
+			}
+		}
+
+		return hr;
 	}
-	// Move to a fractional position in the rowset
-	HRESULT MoveToRatio(
-		_In_ DBCOUNTITEM nNumerator,
-		_In_ DBCOUNTITEM nDenominator) throw()
+
+	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
 	{
-		ATLASSUME(m_spRowset != NULL);
+		IID iidStreamToUse = IID_ISequentialStream;
+		bool fIStreamSupportTested = false;
 
-		CComPtr<IRowsetScroll> spRowsetScroll;
-		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
+		ATLENSURE_RETURN(pUnk != NULL);
+		CComPtr<IAccessor> spAccessor;
+		HRESULT hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
-		m_pAccessor->FreeRecordMemory(m_spRowset);
-		ReleaseRows();
-		m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
-		if (m_hr != S_OK || m_nCurrentRows == 0)
-			return m_hr;
+		ULONG   i;
+		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
 
-		// Get the data
-		m_hRow = m_phRow[m_nCurrentRow];
-		return GetData();
-	}
-	// Insert the current record
-	HRESULT Insert(
-		_In_ int nAccessor = 0,
-		_In_ bool bGetHRow = false) throw()
-	{
-		ReleaseRows();
-		return CRowset< TAccessor >::Insert(nAccessor, bGetHRow);
-	}
+		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
+		// we get it ourselves
+		if (m_pColumnInfo == NULL)
+		{
+			CComPtr<IColumnsInfo> spColumnsInfo;
+			hr = pUnk->QueryInterface(IID_IColumnsInfo, (void**)&spColumnsInfo);
+			if (FAILED(hr))
+				return hr;
 
-// Implementation
-	HRESULT BindFinished() throw()
-	{
-		// No rows in the buffer yet
-		m_nCurrentRows = 0;
-		// Cause MoveNext to automatically perform a new bulk fetch the first time
-		m_nCurrentRow  = 0;
-		m_hr = S_OK;
+			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
+			if (FAILED(hr))
+				return hr;
 
-		// Do not allocate if the buffer has been allocated by a previous call to BindFinished.
-		if (m_phRow == NULL)
-		{
-			ATLTRY(m_phRow = new HROW[m_nRows]);
-			if (m_phRow == NULL)
-				return E_OUTOFMEMORY;
+			m_bOverride = false;
 		}
+		else
+			m_bOverride = true;
 
-		return S_OK;
-	}
-
-	HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
-	HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
-	DBROWCOUNT   m_nRows;        // Number of rows that will fit in the buffer
-	DBCOUNTITEM  m_nCurrentRows; // Number of rows currently in the buffer
-	DBCOUNTITEM  m_nCurrentRow;
-};
+		DBBINDING* pBinding = NULL;
+		ATLTRY( pBinding = new DBBINDING[m_nColumns] );
+		if( pBinding == NULL )
+			return E_OUTOFMEMORY;
 
-/////////////////////////////////////////////////////////////////////////////
-// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer
-template <class T>
-class CVBufHelper
-{
-public:
-	virtual T* operator()(_In_opt_ T* pCurrent)
-	{
-		return pCurrent;
-	}
-};
+		CAutoVectorPtr<DBBINDING> spBinding(pBinding);
 
-template <class T>
-class CVirtualBuffer
-{
-protected:
-	CVirtualBuffer()
-	{
-	}
-	T* m_pTop;
-	int m_nMaxElements;
-public:
-	T* m_pBase;
-	T* m_pCurrent;
-	explicit CVirtualBuffer(_In_ int nMaxElements)
-	{
-		//in case of overflow throw exception
-		ATLENSURE(nMaxElements>=0);
+		ATLASSUME(m_pfClientOwnedMemRef == NULL);
+		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
+		if( m_pfClientOwnedMemRef == NULL )
+		{
+			return E_OUTOFMEMORY;
+		}
 
-		ATLENSURE(nMaxElements <=size_t(-1)/sizeof(T)); //overflow check
-		m_nMaxElements = nMaxElements;
- 		m_pBase = (T*) VirtualAlloc(NULL,sizeof(T)*nMaxElements,	MEM_RESERVE, PAGE_READWRITE);
-		if(m_pBase == NULL)
+#ifdef _DEBUG
+		ATLTRACE( "CDynamicAccessor::BindColumns\n" );
+		ATLTRACE( "Number of columns: %d\n", m_nColumns );
+		ATLTRACE( "Blob Handling Mode: " );
+		switch( m_eBlobHandling )
 		{
-			_AtlRaiseException((DWORD)STATUS_NO_MEMORY);
+		case DBBLOBHANDLING_DEFAULT:
+			ATLTRACE( "DBBLOBHANDLING_DEFAULT\n" );
+			break;
+		case DBBLOBHANDLING_NOSTREAMS:
+			ATLTRACE( "DBBLOBHANDLING_NOSTREAMS\n" );
+			break;
+		case DBBLOBHANDLING_SKIP:
+			ATLTRACE( "DBBLOBHANDLING_SKIP\n" );
+			break;
+		default:
+			ATLTRACE( "IVALID HANDLING MODE!!!\n" );
 		}
-		m_pTop = m_pCurrent = m_pBase;
-		// Commit first page - chances are this is all that will be used
-		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
-	}
-	~CVirtualBuffer()
-	{
-		VirtualFree(m_pBase, 0, MEM_RELEASE);
-	}
-	int Except(_In_ LPEXCEPTION_POINTERS lpEP)
-	{
-		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
-		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
-			return EXCEPTION_CONTINUE_SEARCH;
-		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
+#endif
+		DBBINDING* pCurrent = pBinding;
+		DBOBJECT*  pObject;
 
-		// The address is out of this buffer arrange means AV is not conflicted with this buffer.
-		BYTE* pTmp = reinterpret_cast<BYTE*>(m_pBase);
-		if ((pAddress < pTmp) || (pAddress >= pTmp + (sizeof(T) * m_nMaxElements)))
-			return EXCEPTION_CONTINUE_SEARCH;
+		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);
 
-		VirtualAlloc(pAddress, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
-		return EXCEPTION_CONTINUE_EXECUTION;
-	}
-	bool Seek(_In_ int nElement)
-	{
-		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
-		if(nElement < 0 || nElement >= m_nMaxElements)
-			return false;
-		m_pCurrent = &m_pBase[nElement];
-		return true;
-	}
+		for (i = 0; i < m_nColumns; i++)
+		{
+			// If it's a BLOB or the column size is large enough for us to treat it as
+			// a BLOB then we also need to set up the DBOBJECT structure.
+			m_pfClientOwnedMemRef[i] = false;
+			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize && m_pColumnInfo[i].wType != DBTYPE_IUNKNOWN )
+			{
+				if( m_eBlobHandling == DBBLOBHANDLING_SKIP )
+				{
+					// Calculate the column data offset
+					nDataOffset = 0;
+					// Calculate the column length offset
+					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+					// Calculate the column status offset
+					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+					//If ulColumnSize is not zeroed, GetLength and GetStatus will not access the correct offset in buffer.
+					//As they add ulColumnSize to skip the data.
+					m_pColumnInfo[i].ulColumnSize = 0;
+					ATLTRACE( "%d. Column ordinal %d: Binding length and status ONLY\n", i, m_pColumnInfo[i].iOrdinal );
 
-#define ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()							\
-	__pragma(warning(push))												\
-	/* we never return EXCEPTION_EXECUTE_HANDLER in Except */			\
-	/* hence, we can safely ignore this warning about the handler */	\
-	/* being empty */													\
-	__pragma(warning(disable:6322))										\
-	__try																\
-	{																	\
-		/**/
-# define ATL_DBCLI_END_VBUF_GUARDED_REGION()							\
-	} /* try { */														\
-	__except(Except(GetExceptionInformation()))							\
-	{																	\
-		/*EMPTY*/														\
-	}																	\
-	__pragma(warning(pop))												\
-		/**/
+					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED, true );
+					pCurrent++;
+				}
+				else if( m_eBlobHandling == DBBLOBHANDLING_NOSTREAMS )
+				{
+					// get the value by reference
+					m_pColumnInfo[i].wType |= DBTYPE_BYREF;
+					m_pColumnInfo[i].ulColumnSize   = sizeof(WCHAR*);
+					m_pfClientOwnedMemRef[i] = true;
 
-	void SetAt(
-		_In_ int nElement,
-		_In_ const T& Element)
-	{
-		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
+					// Calculate the column data offset
+					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+					// Calculate the column length offset
+					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+					// Calculate the column status offset
+					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
 
-		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-			T* p = &m_pBase[nElement];
-			*p = Element;
-			m_pTop = p++ > m_pTop ? p : m_pTop;
-		ATL_DBCLI_END_VBUF_GUARDED_REGION()
-	}
-	template <class Q>
-	void WriteBulk(_In_ Q& helper)
-	{
-		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-			m_pCurrent = helper(m_pBase);
-			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
-		ATL_DBCLI_END_VBUF_GUARDED_REGION()
-	}
-	void Write(_In_ const T& Element)
-	{
-		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-			*m_pCurrent = Element;
-			m_pCurrent++;
-			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
-		ATL_DBCLI_END_VBUF_GUARDED_REGION()
-	}
-	T& Read()
-	{
-		return *m_pCurrent;
-	}
-	_Ret_opt_z_ operator BSTR()
-	{
-		BSTR bstrTemp = NULL ;
-		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
-				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
-		ATL_DBCLI_END_VBUF_GUARDED_REGION()
-		return bstrTemp;
-	}
-	const T& operator[](_In_ int nElement) const
-	{
-		if(nElement < 0 || nElement >= m_nMaxElements)
-			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
+					ATLTRACE( "%d. Column ordinal %d: Binding by reference in provider allocated, consumer owned memory\n", i, m_pColumnInfo[i].iOrdinal );
 
-		return m_pBase[nElement];
-	}
-	operator T*()
-	{
-		return m_pBase;
-	}
+					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
+					pCurrent++;
 
-};
+				}
+				else // if( m_eBlobHandling == DBBLOBHANDLING_DEFAULT )
+				{
+					// we will try to bind blobs as streams
+					// if we have not tested if the rowset supports streams, do it now
+					if( ! fIStreamSupportTested )
+					{
+						ATLTRACE( "Testing streams support... " );
 
+						DBPROPID rgPropertyIDs[2] = { DBPROP_ISequentialStream, DBPROP_IStream };
+						BOOL     rgStreamsSupported[2] = {FALSE, FALSE};
 
-typedef CVirtualBuffer<BYTE> CVirtualBytes;
+						// check if the rowset supports IStream* interfaces
+						hr = GetRowsetProperties( pUnk, rgPropertyIDs, rgStreamsSupported, 2 );
+						ATLASSERT( SUCCEEDED( hr ) );
 
-///////////////////////////////////////////////////////////////////////////
-// class CArrayRowset
-//
-// Allows you to access a rowset with an array syntax. TAccessor must be a
-// CAccessor<> type class
+						if( rgStreamsSupported[0] )
+						{
+							iidStreamToUse = IID_ISequentialStream;
 
-template <class TAccessor>
-class CArrayRowset :
-	public CVirtualBuffer<typename TAccessor::DataClass>,
-	protected CBulkRowset<TAccessor>
-{
-public:
-	CArrayRowset(_In_ int nMax = 100000) :
-		CVirtualBuffer<TAccessor::DataClass>(nMax)
-	{
-		m_nRowsRead = 0;
-	}
-	typename TAccessor::DataClass& operator[](_In_ int nRow)
-	{
-		ATLASSERT(nRow >= 0);
-		if( nRow < 0 )
-			AtlThrow(E_INVALIDARG);
+							ATLTRACE( "ISequentialStream is supported\n" );
+						}
+						else if( rgStreamsSupported[1] )
+						{
+							iidStreamToUse = IID_IStream;
 
-		HRESULT hr = S_OK;
-		TAccessor::DataClass* pCurrent = m_pBase + m_nRowsRead;
+							ATLTRACE( "IStream is supported\n" );
+						}
+						else
+						{
 
-		// Retrieve the row if we haven't retrieved it already
-		while ((ULONG)nRow >= m_nRowsRead)
+							ATLTRACE( "neither ISequentialStream nor IStream are supported!\n" );
+
+							ATLASSERT(FALSE); // the stream interfaces are not supported!!!
+						}
+
+						fIStreamSupportTested = true;
+					}
+
+					pObject = NULL;
+					ATLTRY(pObject = new DBOBJECT);
+					if (pObject == NULL)
+					{
+						for( ULONG t = 0; t < i; t++ )
+							delete pBinding[t].pObject;
+
+						delete [] m_pfClientOwnedMemRef;
+						m_pfClientOwnedMemRef = NULL;
+
+						return E_OUTOFMEMORY;
+					}
+					pObject->dwFlags = STGM_READ;
+					pObject->iid     = iidStreamToUse;
+					m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
+					m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
+
+					// Calculate the column data offset
+					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+					// Calculate the column length offset
+					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+					// Calculate the column status offset
+					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+
+#ifdef _DEBUG
+					if( iidStreamToUse == IID_ISequentialStream )
+						ATLTRACE( "%d. Column ordinal %d: Binding as an ISequentialStream object\n", i, m_pColumnInfo[i].iOrdinal );
+					else
+						ATLTRACE( "%d. Column ordinal %d: Binding as an IStream object\n", i, m_pColumnInfo[i].iOrdinal );
+#endif
+					Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
+					pCurrent++;
+
+				}
+			}
+			// else if it's a COM object
+			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
+			{
+				pObject = NULL;
+				ATLTRY(pObject = new DBOBJECT);
+				if (pObject == NULL)
+				{
+					for( ULONG t = 0; t < i; t++ )
+						delete pBinding[t].pObject;
+
+					delete [] m_pfClientOwnedMemRef;
+					m_pfClientOwnedMemRef = NULL;
+
+					return E_OUTOFMEMORY;
+				}
+				pObject->dwFlags = STGM_READ;
+				pObject->iid     = IID_IUnknown; // iidPersistToUse;
+				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
+				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
+
+				// Calculate the column data offset
+				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+
+				// Calculate the column length offset
+				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+
+				// Calculate the column status offset
+				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+
+				ATLTRACE( "%d. Column ordinal %d: Binding a COM object\n", i, m_pColumnInfo[i].iOrdinal );
+
+				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
+				pCurrent++;
+
+			}
+			// else if it's not a BLOB or COM object
+			else
+			{
+				pObject = NULL;
+
+				// Calculate the size needed if it's a string
+				// including the NULL terminator.
+				if (m_pColumnInfo[i].wType == DBTYPE_STR)
+					m_pColumnInfo[i].ulColumnSize += 1;
+
+				if (m_pColumnInfo[i].wType == DBTYPE_WSTR)
+					m_pColumnInfo[i].ulColumnSize = m_pColumnInfo[i].ulColumnSize*2 + 2;
+
+				// Calculate the column data offset
+				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+
+				// Calculate the column length offset
+				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+
+				// Calculate the column status offset
+				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+
+				ATLTRACE( "%d. Column ordinal %d: Binding as native data type\n", i, m_pColumnInfo[i].iOrdinal );
+
+				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
+				pCurrent++;
+			}
+
+			// Note that, as we're not using this for anything else, we're using the
+			// pTypeInfo element to store the offset to our data.
+			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
+		}
+		// Allocate the accessor memory if we haven't done so yet
+		if (m_pAccessorInfo == NULL)
 		{
-			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
-			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-				// Get the row
-				hr = MoveNext();
-				if (hr != S_OK)
-					break;
-			ATL_DBCLI_END_VBUF_GUARDED_REGION()
-			m_nRowsRead++;
-			pCurrent++;
+			hr = AllocateAccessorMemory(1); // We only have one accessor
+			if (FAILED(hr))
+			{
+				for( ULONG t = 0; t < m_nColumns; t++ )
+					delete pBinding[t].pObject;
+
+				delete [] m_pfClientOwnedMemRef;
+				m_pfClientOwnedMemRef = NULL;
+
+				return hr;
+			}
+			m_pAccessorInfo->bAutoAccessor = true;
 		}
 
-		if(hr != S_OK)
+		// Allocate enough memory for the data buffer and tell the rowset
+		// Note that the rowset will free the memory in its destructor.
+		m_pBuffer = NULL;
+		ATLTRY(m_pBuffer = new BYTE[nOffset]);
+		if (m_pBuffer == NULL)
 		{
-			ATLASSERT(hr != DB_S_ENDOFROWSET);	// if you're getting this assertion, then
-												// most likely you are trying to access an
-												// out of bounds element of CArrayRowset
-												// (ex. table[100].data where table has only
-												// 50 records)
-			AtlThrow(hr);
+			for( ULONG t = 0; t < m_nColumns; t++ )
+				delete pBinding[t].pObject;
+
+			delete [] m_pfClientOwnedMemRef;
+			m_pfClientOwnedMemRef = NULL;
+
+			return E_OUTOFMEMORY;
 		}
+		memset(m_pBuffer, 0, nOffset);
+		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
+				nOffset, spAccessor);
 
-		return *(m_pBase + nRow);
+		if( FAILED(hr))
+		{
+			delete [] m_pfClientOwnedMemRef;
+			m_pfClientOwnedMemRef = NULL;
+		}
+
+		return hr;
 	}
 
-	HRESULT Snapshot() throw()
+	// Translate the column number to the index into the column info array
+	bool TranslateColumnNo(_Inout_ DBORDINAL& nColumn) const throw()
 	{
-		HRESULT hr = S_FALSE;
-		ATLASSUME(m_nRowsRead == 0);
-		ATLASSUME(m_spRowset != NULL);
-		TAccessor::DataClass* pCurrent = m_pBase;
-		m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
-		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-			hr = MoveFirst();
-		ATL_DBCLI_END_VBUF_GUARDED_REGION()
-		if (FAILED(hr))
-			return hr;
-		do
+		ATLASSUME(m_pColumnInfo != NULL);
+		// If the user has overriden the binding then we need to search
+		// through the column info for the ordinal number
+		if (m_bOverride)
 		{
-			m_nRowsRead++;
-			pCurrent++;
-			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
-			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
-				hr = MoveNext();
-			ATL_DBCLI_END_VBUF_GUARDED_REGION()
-		} while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);
+			for (ULONG i = 0; i < m_nColumns; i++)
+			{
+				if (m_pColumnInfo[i].iOrdinal == nColumn)
+				{
+					nColumn = i;
+					return true;
+				}
+			}
+			return false;
+		}
+		else
+		{
+			// Note that m_pColumnInfo->iOrdinal will be zero if have bound
+			// a bookmark as the first entry, otherwise it will be 1.
+			// If the column is out of range then return false
+			if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
+				return false;
 
-		return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
+			// otherwise translate the column to an index into our internal
+			// binding entries array
+			nColumn -= m_pColumnInfo->iOrdinal;
+			return true;
+		}
 	}
-	ULONG   m_nRowsRead;
-};
-
-#undef ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION
-#undef ATL_DBCLI_END_VBUF_GUARDED_REGION
 
-// Used when you don't need any parameters or output columns
-class CNoAccessor
-{
-public:
-	// We don't need any typedef's here as the default
-	// global typedef is not to have any parameters and
-	// output columns.
-	HRESULT BindColumns(_In_opt_ IUnknown*) throw()
-	{
-		return S_OK;
-	}
-	HRESULT BindParameters(
-		_In_opt_ HACCESSOR*,
-		_In_opt_ ICommand*,
-		_Deref_opt_out_ void**) throw()
-	{
-		return S_OK;
-	}
-	void Close() throw()
-	{
-	}
-	HRESULT ReleaseAccessors(_In_opt_ IUnknown*) throw()
-	{
-		return S_OK;
-	}
-	void FreeRecordMemory(_Inout_opt_ IRowset* /*pRowset*/) throw()
-	{
-	}
-	void FreeRecordMemory(_In_ int /*nAccessor*/, _Inout_opt_ IRowset* /*pRowset*/) throw()
-	{
-	}
-	HRESULT GetColumnInfo(
-		_In_opt_ IRowset*,
-		_In_opt_ DBORDINAL*,
-		_In_opt_ DBCOLUMNINFO**) throw()
-	{
-		return E_FAIL;
-	}
-	ULONG GetNumAccessors() const throw()
-	{
-		return 0;
-	}
-	bool IsAutoAccessor(_In_ ULONG /*nAccessor*/) const throw()
-	{
-		return false;
-	}
-	HACCESSOR GetHAccessor(_In_ ULONG /*nAccessor*/) const throw()
-	{
-		return 0;
-	}
-	BYTE* GetBuffer() const throw()
-	{
-		ATLASSERT(FALSE);
-		return NULL;
-	}
-	static void Bind(
-		_In_opt_ DBBINDING*,
-		_In_ DBORDINAL,
-		_In_ DBTYPE,
-		_In_ DBLENGTH,
-		_In_ BYTE,
-		_In_ BYTE,
-		_In_ DBPARAMIO,
-		_In_ DBBYTEOFFSET,
-		_In_ DBBYTEOFFSET = 0,
-		_In_ DBBYTEOFFSET = 0,
-		_In_opt_ DBOBJECT* = NULL) throw()
-	{
-		ATLASSERT(FALSE);
-	}
-	bool NoBindOnNullRowset() const throw()
+	static size_t GetAlignment(_In_ DBTYPE bType) throw()
 	{
-		return false;
-	}
-};
+		if( bType & DBTYPE_BYREF )
+			return __alignof(void*);
 
-// Used when a rowset will not be returned from the command
-template <class TAccessor = CAccessorBase>
-class CNoRowset
-{
-public:
-	HRESULT BindFinished() throw()
-	{
-		return S_OK;
-	}
-	void Close() throw()
-	{
-	}
-	static const IID& GetIID() throw()
-	{
-		return IID_NULL;
-	}
-	IRowset* GetInterface() const throw()
-	{
-		return NULL;
-	}
-	IRowset** GetInterfacePtr() throw()
-	{
-		return NULL;
-	}
-	void SetAccessor(_In_opt_ void*) throw()
-	{
-	}
-	void SetupOptionalRowsetInterfaces() throw()
-	{
-	}
-};
+		if( bType & DBTYPE_ARRAY )
+			return __alignof(SAFEARRAY*);
 
-// Used with SQL Server 2000, a rowset will not be returned from the command, but instead
-// we get an ISequentialStream object and use it to read the data.
-template <class TAccessor = CAccessorBase>
-class CStreamRowset
-{
-public:
-	// Constructors & destructors
-	CStreamRowset()
-	{
-		m_spStream = NULL;
-	}
+		if( bType & DBTYPE_VECTOR )
+			return __alignof(DBVECTOR);
 
-	~CStreamRowset()
-	{
-		Close();
-	}
+		switch( bType )
+		{
+		case DBTYPE_I2:
+			return __alignof(signed short);
+			break;
 
-	// Methods
-	void Close()
-	{
-		if (m_spStream != NULL)
-			m_spStream.Release();
-	}
+		case DBTYPE_I4:
+			return __alignof(signed int);
+			break;
 
-	// Implementation
-	static const IID& GetIID()
-	{
-		return IID_ISequentialStream;
-	}
-	ISequentialStream* GetInterface() const
-	{
-		return m_spStream;
-	}
-	ISequentialStream** GetInterfacePtr()
-	{
-		return &m_spStream;
-	}
+		case DBTYPE_R4:
+			return __alignof(float);
+			break;
 
-	HRESULT BindFinished() throw()
-	{
-		return S_OK;
-	}
-	void SetAccessor(_In_opt_ void*) throw()
-	{
-	}
-	void SetupOptionalRowsetInterfaces() throw()
-	{
-	}
+		case DBTYPE_R8:
+			return __alignof(double);
+			break;
 
-	CComPtr<ISequentialStream> m_spStream;
-};
+		case DBTYPE_CY:
+			return __alignof(__int64);
+			break;
 
+		case DBTYPE_DATE:
+			return __alignof(DATE);
+			break;
 
-///////////////////////////////////////////////////////////////////////////
-// class CAccessor
-// T is the class that contains the data that will be accessed.
-ATLPREFAST_SUPPRESS(6387)
-template <class T>
-class CAccessor :
-	public CAccessorBase,
-	public T
-{
-public:
-	typedef T DataClass;
+		case DBTYPE_BSTR:
+			return __alignof(BSTR*);
+			break;
 
-// Implementation
-	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
-	{
-		FreeRecordMemory( (IRowset*) pUnk );
-		return CAccessorBase::ReleaseAccessors(pUnk);
-	}
+		case DBTYPE_IDISPATCH:
+			return __alignof(IDispatch*);
+			break;
 
-	// Free's any columns in the current record that need to be freed.
-	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
-	void FreeRecordMemory(
-		_In_ int nAccessor,
-		_In_opt_ IRowset* /* pRowset */) throw()
-	{
-		(nAccessor);
-		__if_exists(_GetBindEntries)
-		{
-			DBORDINAL nColumns;
+		case DBTYPE_ERROR:
+			return __alignof(SCODE);
+			break;
 
-			// Passing in m_pBuffer tells the column entry maps to free the
-			// memory for the types if appropriate
-			_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL, m_pBuffer);
-		}
-	}
-	void FreeRecordMemory(_Inout_opt_ IRowset* pRowset) throw()
-	{
-		for (ULONG i = 0; i < GetNumAccessors(); i++)
-			FreeRecordMemory(i, pRowset);
-	}
+		case DBTYPE_BOOL:
+			return __alignof(VARIANT_BOOL);
+			break;
 
-	HRESULT GetColumnInfo(
-		_In_opt_ IRowset*,
-		_In_opt_ DBORDINAL*,
-		_Deref_out_opt_ DBCOLUMNINFO** ppColumnInfo) throw()
-	{
-		ATLASSERT(ppColumnInfo != NULL);
-		*ppColumnInfo = NULL;
+		case DBTYPE_VARIANT:
+			return __alignof(VARIANT);
+			break;
 
-		return E_FAIL;
-	}
+		case DBTYPE_IUNKNOWN:
+			return __alignof(IUnknown*);
+			break;
 
-	void ClearRecordMemory() throw()
-	{
-		__if_exists(_GetBindEntries)
-		{
-			for (ULONG i = 0; i < _OutputColumnsClass::_GetNumAccessors(); i++)
-			{
-				DBORDINAL nColumns;
-				_GetBindEntries(NULL, &nColumns, NULL, i, NULL, m_pBuffer, true);
-			}
-		}
-	}
+		case DBTYPE_DECIMAL:
+			return __alignof(DECIMAL);
+			break;
 
-	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
-	{
-		HRESULT hr;
-		ULONG   nAccessors;
-		DBLENGTH  nSize;
-		nAccessors = _OutputColumnsClass::_GetNumAccessors();
+		case DBTYPE_UI1:
+			return __alignof(unsigned char);
+			break;
 
-		SetBuffer((BYTE*)(T*)this);
-		ClearRecordMemory();
+		case DBTYPE_I1:
+			return __alignof(signed char);
+			break;
 
-		nSize = sizeof(T);
-		hr = BindAccessors(nAccessors, nSize, pUnk);
-		return hr;
-	}
-	HRESULT BindAccessors(
-		_In_ ULONG nAccessors,
-		_In_ DBLENGTH nSize,
-		_Inout_ IUnknown* pUnk) throw()
-	{
-		ATLENSURE_RETURN(pUnk != NULL);
-		HRESULT hr;
+		case DBTYPE_UI2:
+			return __alignof(unsigned short);
+			break;
 
-		CComPtr<IAccessor> spAccessor;
-		hr = pUnk->QueryInterface(&spAccessor);
-		if (SUCCEEDED(hr))
-		{
-			// Allocate the accessor memory if we haven't done so yet
-			if (m_pAccessorInfo == NULL)
-			{
-				hr = AllocateAccessorMemory(nAccessors);
-				if (FAILED(hr))
-					return hr;
-			}
+		case DBTYPE_UI4:
+			return __alignof(unsigned int);
+			break;
 
-			for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
-				hr = BindAccessor(spAccessor, i, nSize);
-		}
+		case DBTYPE_I8:
+			return __alignof(signed char);
+			break;
 
-		return hr;
-	}
+		case DBTYPE_UI8:
+			return __alignof(unsigned char);
+			break;
 
-	HRESULT BindAccessor(
-		_Inout_ IAccessor* pAccessor,
-		_In_ ULONG nAccessor,
-		_In_ DBLENGTH nSize) throw()
-	{
-		CAutoVectorPtr<DBBINDING>	spBindings;
-		CAutoVectorPtr<LPOLESTR>	spColumnNames;
-		DBORDINAL					nColumns = 0;
-		bool						bAuto = false;
-		HRESULT						hr;
-		CComHeapPtr<DBCOLUMNINFO>	spColumnInfo;
-		DBORDINAL					nColumnInfoCount = 0;
-		CComHeapPtr<OLECHAR>		spStringsBuffer;
+		case DBTYPE_GUID:
+			return __alignof(GUID);
+			break;
 
-		// First time just get the number of entries by passing in &nColumns
-		_OutputColumnsClass::_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL);
+		case DBTYPE_BYTES:
+			return __alignof(BYTE);
+			break;
 
-		ATLASSERT(nColumns > 0);
+		case DBTYPE_STR:
+			return __alignof(char);
+			break;
 
-		// Allocate the binding structures
-		if( !spBindings.Allocate(nColumns) )
-			return E_OUTOFMEMORY;
+		case DBTYPE_WSTR:
+			return __alignof(short);
+			break;
 
-		for( ULONG i = 0; i < nColumns; i++ )
-			spBindings[i].pObject = NULL;
+		case DBTYPE_NUMERIC:
+			return __alignof(DB_NUMERIC);
+			break;
 
-		// Allocate the column names strings array
-		if( !spColumnNames.Allocate(nColumns) )
-			return E_OUTOFMEMORY;
+		case DBTYPE_DBDATE:
+			return __alignof(DBDATE);
+			break;
 
-		// Now get the bind entries
-		hr = _OutputColumnsClass::_GetBindEntries(spColumnNames, &nColumns, spBindings, nAccessor, &bAuto);
-		if (SUCCEEDED(hr))
-		{
-			// translate the columns names to oridinals if necessary
-			for( ULONG i = 0; i < nColumns; i++ )
-				if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
-				{
-					// if necessary, get the column information
-					if( spColumnInfo == NULL )
-					{
-						if( FAILED( GetColumnNames( pAccessor, &spColumnInfo, &spStringsBuffer, &nColumnInfoCount ) ) )
-						{
-							ATLASSERT( FALSE ); // unable to get columns information
-							return E_FAIL;
-						}
-					}
-					if( ! GetOridinalColumnNo(spColumnNames[i], spBindings[i].iOrdinal, spColumnInfo, nColumnInfoCount ) )
-					{
-						ATLASSERT(FALSE); // unable to match column name to an oridinal !!!
-						return E_FAIL;
-					}
-				}
+		case DBTYPE_DBTIME:
+			return __alignof(DBTIME);
+			break;
 
-			m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
-			hr = BindEntries(spBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
-		}
-		else
-		{
-			// free any DBBINDING::pObject's
-			for( ULONG i = 0; i < nColumns; i++ )
-				delete spBindings[i].pObject;
+		case DBTYPE_DBTIMESTAMP:
+			return __alignof(DBTIMESTAMP);
+			break;
 
+		default:
+			return __alignof(__int64);
 		}
-		return hr;
 	}
 
-	HRESULT BindParameters(
-		_In_ HACCESSOR* pHAccessor,
-		_Inout_ ICommand* pCommand,
-		_Deref_out_ void** ppParameterBuffer) throw()
+	inline static DBBYTEOFFSET AlignAndIncrementOffset(
+		_Inout_ DBBYTEOFFSET& nOffset,
+		_In_ DBLENGTH nSize,
+		_In_ size_t nAlign) throw()
 	{
-		HRESULT				hr = S_OK;
-		ATLENSURE_RETURN(ppParameterBuffer);
-
-		// In the static accessor case, the parameter buffer will be T plus the size of CAccessorBase
-		*ppParameterBuffer = static_cast<T*>(this);
+		DBBYTEOFFSET nResult;
 
-		// Only bind the parameters if we haven't already done it
-		if (*pHAccessor == NULL)
-		{
-			DBORDINAL					nColumns = 0;
-			CAutoVectorPtr<DBBINDING>	spBinding;
-			CAutoVectorPtr<LPOLESTR>	spColumnNames;
+		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
+		nResult = nOffset;
+		nOffset += nSize;
 
-			CComHeapPtr<DBPARAMINFO>	spParameterInfo;
-			DB_UPARAMS					nParameterInfoCount = 0;
-			CComHeapPtr<OLECHAR>		spStringsBuffer;
+		return nResult;
+	}
 
-			_ParamClass::_GetParamEntries(NULL, &nColumns, NULL);
+	inline static void IncrementAndAlignOffset(
+		_Inout_ DBBYTEOFFSET& nOffset,
+		_In_ DBLENGTH nSize,
+		_In_ size_t nAlign) throw()
+	{
+		nOffset += nSize;
+		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
+	}
 
-			// Allocate the DBPARAMINFO array
-			if( !spBinding.Allocate(nColumns) )
-				return E_OUTOFMEMORY;
+	typedef CDynamicAccessor _OutputColumnsClass;
+	static bool HasOutputColumns() throw()
+	{
+		return true;
+	}
 
-			// Allocate the column names strings array
-			if( !spColumnNames.Allocate(nColumns) )
-				return E_OUTOFMEMORY;
+	DBORDINAL           m_nColumns;
+	bool*				m_pfClientOwnedMemRef;
+	DBCOLUMNINFO*       m_pColumnInfo;
+	OLECHAR*            m_pStringsBuffer;
+	bool                m_bOverride;
 
-			hr = _ParamClass::_GetParamEntries(spColumnNames, &nColumns, spBinding);
-			if (SUCCEEDED(hr))
-			{
-				for( ULONG i = 0; i < nColumns; i++ )
-				{
-					// For bindings in parameter accessors, consumer-owned memory must always be used.
-					spBinding[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
+	protected:
+	DBBLOBHANDLINGENUM  m_eBlobHandling;
+	DBLENGTH            m_nBlobSize;
+};
+	
+template< typename BaseType >
+inline void strcpyT(
+	_Out_z_cap_(maxCount) BaseType *strDest,
+	_In_ size_t maxCount,
+	_In_z_ const BaseType *strSource)
+{
+	return NULL;
+}
 
-					// translate the columns names to oridinals if necessary
-					if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
-					{
-						// if necessary, get the column information
-						if( spParameterInfo == NULL )
-						{
-							if( FAILED( GetParameterNames( pCommand, &spParameterInfo, &spStringsBuffer, &nParameterInfoCount ) ) )
-							{
-								ATLASSERT( FALSE ); // unable to get columns information
-								return E_FAIL;
-							}
-						}
-						if( ! GetOridinalParameterNo(spColumnNames[i], spBinding[i].iOrdinal, spParameterInfo, nParameterInfoCount ) )
-						{
-							ATLASSERT(FALSE); // unable to match parameter name to an oridinal !!!
-							return E_FAIL;
-						}
-					}
-				}
+template< typename BaseType >
+inline size_t strlenT(_In_z_ const BaseType *string)
+{
+	return NULL;
+}
 
-				// Get the IAccessor from the passed ICommand
-				ATLENSURE_RETURN(pCommand != NULL);
-				CComPtr<IAccessor> spAccessor;
-				hr = pCommand->QueryInterface(&spAccessor);
-				if (SUCCEEDED(hr))
-				{
-					hr = BindEntries(spBinding, nColumns, pHAccessor, sizeof(T), spAccessor);
-				}
-			}
-		}
-		return hr;
-	}
-
-protected:
-	bool GetOridinalColumnNo(
-		_In_z_ LPCOLESTR pOleColumnName,
-		_Out_ DBORDINAL& nColumn,
-		_In_count_(nColumns) DBCOLUMNINFO* pColumnInfo,
-		_In_ DBORDINAL nColumns) throw()
-	{
-		ATLASSERT(pOleColumnName != NULL);
-		ATLASSERT(pColumnInfo != NULL);
-
-		if( pOleColumnName == NULL || pColumnInfo == NULL )
-			return false;
-
-		// Search through the columns trying to find a match
-		for (ULONG i = 0; i < nColumns; i++)
-		{
-			if (pColumnInfo[i].pwszName != NULL && wcscmp(pColumnInfo[i].pwszName, pOleColumnName) == 0)
-			{
-				nColumn = pColumnInfo[i].iOrdinal;
-				return true;
-			}
-		}
-		return false;   // Not Found
-	}
-	
-	HRESULT GetColumnNames(
-		_Inout_ IAccessor* pAccessor,
-		_Deref_out_ DBCOLUMNINFO** ppColumnInfo,
-		_Deref_out_z_ OLECHAR** ppStringsBuffer,
-		_Out_ DBORDINAL* pnColumns) throw()
-	{
-		ATLASSERT( ppColumnInfo != NULL );
-		ATLASSERT( ppStringsBuffer != NULL );
-		ATLASSERT( pnColumns != NULL );
-		ATLASSERT( pAccessor != NULL );
+template<>
+inline void strcpyT<CHAR>(
+	_Out_z_cap_(maxCount) CHAR *strDest,
+	_In_ size_t maxCount,
+	_In_z_ const CHAR *strSource)
+{
+	Checked::strcpy_s( strDest, maxCount, strSource);
+}
 
-		if( ppColumnInfo == NULL || ppStringsBuffer == NULL || pnColumns == NULL || pAccessor == NULL )
-			return E_FAIL;
+template<>
+inline size_t strlenT<CHAR>(_In_z_ const CHAR *string)
+{
+	return strlen( string );
+}
 
-		CComPtr<IColumnsInfo> spColumnsInfo;
-		HRESULT hr = pAccessor->QueryInterface(&spColumnsInfo);
-		if (FAILED(hr))
-			return hr;
+template<>
+inline void strcpyT<WCHAR>(
+	_Out_z_cap_(maxCount) WCHAR *strDest,
+	_In_ size_t maxCount,
+	_In_z_ const WCHAR *strSource)
+{
+	Checked::wcscpy_s( strDest, maxCount, strSource);
+}
 
-		hr = spColumnsInfo->GetColumnInfo(pnColumns, ppColumnInfo, ppStringsBuffer);
-		if (FAILED(hr))
-			return hr;
+template<>
+inline size_t strlenT<WCHAR>(_In_z_ const WCHAR *string)
+{
+	return wcslen( string );
+}
 
-		return S_OK;
-	}
-	
-	bool GetOridinalParameterNo(
-		_In_z_ LPCOLESTR pOleParameterName,
-		_Out_ DB_UPARAMS& nParameter,
-		_In_count_(nParameters) DBPARAMINFO* pParameterInfo,
-		_In_ DB_UPARAMS nParameters) throw()
+template< typename BaseType, DBTYPEENUM OleDbType >
+class CDynamicStringAccessorT :
+	public CDynamicAccessor
+{
+public:
+	explicit CDynamicStringAccessorT(_In_ DBLENGTH nBlobSize = 8000)
+		: CDynamicAccessor( DBBLOBHANDLING_DEFAULT, nBlobSize )
 	{
-		ATLASSERT(pOleParameterName != NULL);
-		ATLASSERT(pParameterInfo != NULL);
-
-		if( pOleParameterName == NULL || pParameterInfo == NULL )
-			return false;
-
-		// Search through the columns trying to find a match
-		for (ULONG i = 0; i < nParameters; i++)
-		{
-			if (pParameterInfo[i].pwszName != NULL && wcscmp(pParameterInfo[i].pwszName, pOleParameterName) == 0)
-			{
-				nParameter = pParameterInfo[i].iOrdinal;
-				return true;
-			}
-		}
-		return false;   // Not Found
 	}
 
-	HRESULT GetParameterNames(
-		_Inout_ ICommand* pCmd,
-		_Deref_out_ DBPARAMINFO** ppParameterInfo,
-		_Deref_out_z_ OLECHAR** ppStringsBuffer,
-		_Out_ DB_UPARAMS* pnParameters) throw()
+	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
 	{
-		ATLASSERT( ppParameterInfo != NULL );
-		ATLASSERT( ppStringsBuffer != NULL );
-		ATLASSERT( pnParameters != NULL );
-		ATLASSERT( pCmd != NULL );
-
-		if( ppParameterInfo == NULL || ppStringsBuffer == NULL || pnParameters == NULL || pCmd == NULL )
-			return E_FAIL;
-
-		CComPtr<ICommandWithParameters> spCommandWithParameters;
-		HRESULT hr = pCmd->QueryInterface(&spCommandWithParameters);
-		if (FAILED(hr))
-			return hr;
-
-		hr = spCommandWithParameters->GetParameterInfo(pnParameters, ppParameterInfo, ppStringsBuffer);
+		ATLENSURE_RETURN(pUnk != NULL);
+		CComPtr<IAccessor> spAccessor;
+		HRESULT hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
-		return S_OK;
-	}
-};
-ATLPREFAST_UNSUPPRESS()
+		ULONG   i;
+		DBBYTEOFFSET nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
+		DBLENGTH nLength;
 
-enum DBBLOBHANDLINGENUM
-{
-	DBBLOBHANDLING_DEFAULT,
-	DBBLOBHANDLING_NOSTREAMS,
-	DBBLOBHANDLING_SKIP
-};
+		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
+		// we get it ourselves
+		if (m_pColumnInfo == NULL)
+		{
+			CComPtr<IColumnsInfo> spColumnsInfo;
+			hr = pUnk->QueryInterface(IID_IColumnsInfo, (void**)&spColumnsInfo);
+			if (FAILED(hr))
+				return hr;
 
-///////////////////////////////////////////////////////////////////////////
-// CDynamicAccessor
-class CDynamicAccessor :
-	public CAccessorBase
-{
-public:
-	CDynamicAccessor(
-		_In_ DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT,
-		_In_ DBLENGTH nBlobSize = 8000)
-	{
-		ATLASSERT( eBlobHandling == DBBLOBHANDLING_DEFAULT ||
-				   eBlobHandling == DBBLOBHANDLING_NOSTREAMS ||
-				   eBlobHandling == DBBLOBHANDLING_SKIP );
+			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
+			if (FAILED(hr))
+				return hr;
 
-		m_nColumns        = 0;
-		m_pColumnInfo     = NULL;
-		m_pStringsBuffer  = NULL;
-		m_eBlobHandling   = eBlobHandling;
-		m_nBlobSize       = nBlobSize;
-		m_pfClientOwnedMemRef = NULL;
-	};
+			m_bOverride = false;
+		}
+		else
+			m_bOverride = true;
 
-	~CDynamicAccessor()
-	{
-		Close();
-	}
+		DBBINDING* pBinding = NULL;
+		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
+		if (pBinding == NULL)
+			return E_OUTOFMEMORY;
 
-	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
-	{
-		FreeRecordMemory( (IRowset*) pUnk );
-		return CAccessorBase::ReleaseAccessors(pUnk);
-	}
+		::ATL::CAutoVectorPtr<DBBINDING> spBinding(pBinding);
 
-	bool SetBlobHandling(_In_ DBBLOBHANDLINGENUM eBlobHandling)
-	{
-		switch( eBlobHandling )
+		ATLASSUME(m_pfClientOwnedMemRef == NULL);
+		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
+		if( m_pfClientOwnedMemRef == NULL )
 		{
-		case DBBLOBHANDLING_DEFAULT:
-		case DBBLOBHANDLING_NOSTREAMS:
-		case DBBLOBHANDLING_SKIP:
-			m_eBlobHandling = eBlobHandling;
-			return true;
-		default:
-			ATLASSERT( FALSE ); // invalid blob handling mode!!!
-			return false;
+			return E_OUTOFMEMORY;
 		}
-	}
-
-	const DBBLOBHANDLINGENUM GetBlobHandling() const
-	{
-		return m_eBlobHandling;
-	}
-
-	void SetBlobSizeLimit(_In_ DBLENGTH nBlobSize)
-	{
-		m_nBlobSize = nBlobSize;
-	}
-
-	const DBLENGTH GetBlobSizeLimit() const
-	{
-		return m_nBlobSize;
-	}
 
-//	void FreeRecordMemory(int , IRowset* ) throw() {}
-
-	void Close() throw()
-	{
-		CoTaskMemFree(m_pColumnInfo);
-		m_pColumnInfo = NULL;
-
-		// Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
-		// if necessary
-		CoTaskMemFree(m_pStringsBuffer);
-		m_pStringsBuffer = NULL;
-
-		delete [] m_pBuffer;
-		m_pBuffer = NULL;
-
-		delete [] m_pfClientOwnedMemRef;
-		m_pfClientOwnedMemRef = NULL;
-
-		m_nColumns = 0;
+		DBBINDING* pCurrent = pBinding;
 
-		CAccessorBase::Close();
-	}
+		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);
 
-	bool GetColumnType(
-		_In_ DBORDINAL nColumn,
-		_Out_ DBTYPE* pType) const throw()
-	{
-		if (TranslateColumnNo(nColumn))
+		for (i = 0; i < m_nColumns; i++)
 		{
-			ATLENSURE_RETURN_VAL(pType, false);
-			*pType = m_pColumnInfo[nColumn].wType;
-			return true;
+			m_pfClientOwnedMemRef[i] = false;
+
+			// If it's a IPersist* object or the column size is large enough for us to treat it as
+			// a BLOB then we will request references (in client owned memory) to a string
+			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
+			{
+				m_pColumnInfo[i].wType      = OleDbType | DBTYPE_BYREF;
+				m_pColumnInfo[i].ulColumnSize   = sizeof(BaseType*);
+				m_pfClientOwnedMemRef[i] = true;
+			}
+			else // We're treating everything as a string so add 1 for the NULL byte.
+			{
+				switch (m_pColumnInfo[i].wType)
+				{
+				case DBTYPE_BOOL:
+					nLength = 2;
+					break;
+				case DBTYPE_BYTES:
+					nLength = m_pColumnInfo[i].ulColumnSize * 2;
+					break;
+				case DBTYPE_BSTR:
+					nLength = m_pColumnInfo[i].ulColumnSize;
+					break;
+				case DBTYPE_STR:
+					nLength = m_pColumnInfo[i].ulColumnSize;
+					break;
+				case DBTYPE_WSTR:
+					nLength = m_pColumnInfo[i].ulColumnSize;
+					break;
+				case DBTYPE_I1:
+					nLength = 5;
+					break;
+				case DBTYPE_I2:
+					nLength = 7;
+					break;
+				case DBTYPE_I4:
+					nLength = 12;
+					break;
+				case DBTYPE_I8:
+					nLength = 22;
+					break;
+				case DBTYPE_UI1:
+					nLength = 4;
+					break;
+				case DBTYPE_UI2:
+					nLength = 6;
+					break;
+				case DBTYPE_UI4:
+					nLength = 11;
+					break;
+				case DBTYPE_UI8:
+					nLength = 21;
+					break;
+				case DBTYPE_R4:
+					nLength = 13;
+					break;
+				case DBTYPE_R8:
+					nLength = 23;		// maybe 9
+					break;
+				case DBTYPE_DECIMAL:
+					nLength = 23;
+					break;
+				case DBTYPE_NUMERIC:
+					nLength = 23;
+					break;
+				case DBTYPE_VARIANT:
+					nLength = 20;
+					break;
+				case DBTYPE_IDISPATCH:
+					nLength = 32;
+					break;
+				case DBTYPE_IUNKNOWN:
+					nLength = 32;
+					break;
+				case DBTYPE_GUID:
+					nLength = 38;
+					break;
+				case DBTYPE_ARRAY:
+					nLength = 32;
+					break;
+				case DBTYPE_VECTOR:
+					nLength = 32;
+					break;
+				case DBTYPE_DATE:
+					nLength = 32;
+					break;
+				case DBTYPE_DBDATE:
+					nLength = 32;
+					break;
+				case DBTYPE_DBTIME:
+					nLength = 32;
+					break;
+				case DBTYPE_DBTIMESTAMP:
+					nLength = 32;
+					break;
+				case DBTYPE_FILETIME:
+					nLength = 32;
+					break;
+				case DBTYPE_PROPVARIANT:
+					nLength = 32;
+					break;
+				case DBTYPE_VARNUMERIC:
+					nLength = 32;
+					break;
+				case DBTYPE_CY:
+					nLength = 32;
+					break;
+				default:
+					ATLASSERT(FALSE); // unhandled column type
+					nLength = 32;
+				}
+				m_pColumnInfo[i].ulColumnSize = (nLength + 1) * sizeof(BaseType);
+				m_pColumnInfo[i].wType = OleDbType;
+			}
+
+			// Calculate the column data offset
+			nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( OleDbType ) );
+
+			// Calculate the column length offset
+			nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+
+			// Calculate the column status offset
+			nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+
+			BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
+				m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
+				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
+
+			pCurrent++;
+
+			// Note that, as we're not using this for anything else, we're using the
+			// pTypeInfo element to store the offset to our data.
+			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
 		}
-		else
-			return false;
-	}
 
-	bool GetColumnFlags(
-		_In_ DBORDINAL nColumn,
-		_Out_ DBCOLUMNFLAGS* pFlags) const throw()
-	{
-		if (TranslateColumnNo(nColumn))
+		// Allocate the accessor memory if we haven't done so yet
+		if (m_pAccessorInfo == NULL)
 		{
-			ATLENSURE_RETURN_VAL(pFlags, false);
-			*pFlags = m_pColumnInfo[nColumn].dwFlags;
-			return true;
+			hr = AllocateAccessorMemory(1); // We only have one accessor
+			if (FAILED(hr))
+			{
+				delete [] m_pfClientOwnedMemRef;
+				m_pfClientOwnedMemRef = NULL;
+				return hr;
+			}
+			m_pAccessorInfo->bAutoAccessor = true;
 		}
-		else
-			return false;
-	}
-	bool GetOrdinal(
-		_In_z_ const CHAR* pColumnName,
-		_Out_ DBORDINAL* pOrdinal) const throw()
-	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+
+		// Allocate enough memory for the data buffer and tell the rowset
+		// Note that the rowset will free the memory in its destructor.
+		m_pBuffer = NULL;
+		ATLTRY(m_pBuffer = new BYTE[nOffset]);
+		if (m_pBuffer == NULL)
 		{
-			ATLENSURE_RETURN_VAL(pOrdinal, false);
-			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
-			return true;
+			delete [] m_pfClientOwnedMemRef;
+			m_pfClientOwnedMemRef = NULL;
+			return E_OUTOFMEMORY;
 		}
-		else
-			return false;
-	}
-	bool GetOrdinal(
-		_In_z_ const WCHAR* pColumnName,
-		_Out_ DBORDINAL* pOrdinal) const throw()
-	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+
+		memset(m_pBuffer, 0, nOffset);
+		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
+				nOffset, spAccessor);
+
+		if( FAILED(hr) )
 		{
-			ATLENSURE_RETURN_VAL(pOrdinal, false);
-			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
-			return true;
+			delete [] m_pfClientOwnedMemRef;
+			m_pfClientOwnedMemRef = NULL;
 		}
-		else
-			return false;
+
+		return hr;
 	}
 
-	void* GetValue(_In_ DBORDINAL nColumn) const throw()
+	BaseType* GetString(_In_ DBORDINAL nColumn) const throw()
 	{
 		if (TranslateColumnNo(nColumn))
-			return _GetDataPtr(nColumn);
+		{
+			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
+				return *(BaseType**)_GetDataPtr(nColumn);
+			else
+				return (BaseType*)_GetDataPtr(nColumn);
+		}
 		else
 			return NULL;
 	}
 
-	void* GetValue(_In_z_ const CHAR* pColumnName) const throw()
+	BaseType* GetString(_In_z_ const CHAR* pColumnName) const throw()
 	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
+		ATLASSERT(pColumnName != NULL);
 		DBORDINAL nColumn;
 		if (GetInternalColumnNo(pColumnName, &nColumn))
-			return _GetDataPtr(nColumn);
+		{
+			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
+				return *(BaseType**)_GetDataPtr(nColumn);
+			else
+				return (BaseType*)_GetDataPtr(nColumn);
+		}
 		else
 			return NULL;    // Not Found
 	}
 
-	void* GetValue(_In_z_ const WCHAR* pColumnName) const throw()
+	BaseType* GetString(_In_z_ const WCHAR* pColumnName) const throw()
 	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, NULL);
+		ATLASSERT(pColumnName != NULL);
 		DBORDINAL nColumn;
 		if (GetInternalColumnNo(pColumnName, &nColumn))
-			return _GetDataPtr(nColumn);
+		{
+			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
+				return *(BaseType**)_GetDataPtr(nColumn);
+			else
+				return (BaseType*)_GetDataPtr(nColumn);
+		}
 		else
 			return NULL;    // Not Found
 	}
 
-	template <class ctype>
-	void _GetValue(
+	void _SetLength(
 		_In_ DBORDINAL nColumn,
-		_Out_ ctype* pData) const throw()
+		_In_ DBLENGTH nLength) throw()
 	{
-		ATLASSUME(pData != NULL);
-		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
-		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
-		*pData = *pBuffer;
+		DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+		IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
+		*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
 	}
-	template <class ctype>
-	void _SetValue(
+
+	HRESULT _SetString(
 		_In_ DBORDINAL nColumn,
-		_In_ const ctype& data) throw()
+		_In_z_ BaseType* data) throw()
 	{
-		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
-		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
-		*pBuffer = (ctype)data;
-	}
-	template <class ctype>
-	bool GetValue(
-		_In_ DBORDINAL nColumn,
-		_Out_ ctype* pData) const throw()
-	{
-		ATLENSURE_RETURN_VAL(pData, false);
-		if (TranslateColumnNo(nColumn))
-		{
-			_GetValue(nColumn, pData);
-			return true;
-		}
-		return false;
-	}
-	template <class ctype>
-	bool SetValue(
-		_In_ DBORDINAL nColumn,
-		_In_ const ctype& data) throw()
-	{
-		if (TranslateColumnNo(nColumn))
-		{
-			_SetValue(nColumn, data);
-			return true;
-		}
-		return false;
-	}
-	template <class ctype>
-	bool GetValue(
-		_In_z_ const CHAR *pColumnName,
-		_Out_ ctype* pData) const throw()
-	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
-		ATLENSURE_RETURN_VAL(pData, false);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			_GetValue(nColumn, pData);
-			return true;
-		}
-		return false;
-	}
-	template <class ctype>
-	bool GetValue(
-		_In_z_ const WCHAR *pColumnName,
-		_Out_ ctype* pData) const throw()
-	{
-		ATLENSURE_RETURN_VAL(pColumnName != NULL, false);
-		ATLENSURE_RETURN_VAL(pData, false);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			_GetValue(nColumn, pData);
-			return true;
-		}
-		return false;
-	}
-	template <class ctype>
-	bool SetValue(
-		_In_z_ const CHAR *pColumnName,
-		_In_ const ctype& data) throw()
-	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			_SetValue(nColumn, data);
-			return true;
-		}
-		return false;
-	}
-	template <class ctype>
-	bool SetValue(
-		_In_z_ const WCHAR *pColumnName,
-		_In_ const ctype& data) throw()
-	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+		DBLENGTH stringLen = (DBLENGTH)strlenT<BaseType>( data );
+
+		if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
 		{
-			_SetValue(nColumn, data);
-			return true;
+			BaseType** pBuffer = (BaseType**)_GetDataPtr(nColumn);
+
+
+
+			//in case of overflow throw exception
+			if (stringLen + 1>(size_t(-1)/sizeof(BaseType)))
+			{
+				return(E_FAIL);//arithmetic overflow
+			}
+
+			BaseType* pNewBuffer = (BaseType*)::ATL::AtlCoTaskMemRecalloc( *pBuffer, (stringLen + 1), sizeof(BaseType));
+			if( pNewBuffer == NULL )
+				return E_OUTOFMEMORY;
+
+			*pBuffer = pNewBuffer;
+			strcpyT<BaseType>( pNewBuffer, stringLen+1, data);
+			_SetLength( nColumn, stringLen * sizeof(BaseType) );
 		}
-		return false;
-	}
-	bool GetLength(
-		_In_ DBORDINAL nColumn,
-		_Out_ DBLENGTH* pLength) const
-	{
-		ATLENSURE(pLength != NULL);
-		if (TranslateColumnNo(nColumn))
+		else
 		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
-			return true;
+			BaseType* pBuffer = (BaseType*)_GetDataPtr(nColumn);
+			if( stringLen >= m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) )
+			{
+				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1, data);
+				pBuffer[m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1] = 0;
+				_SetLength( nColumn, m_pColumnInfo[nColumn].ulColumnSize - sizeof(BaseType));
+				return DBSTATUS_S_TRUNCATED;
+			}
+			else
+			{
+				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType), data);
+				_SetLength( nColumn, stringLen * sizeof(BaseType) );
+			}
 		}
-		else
-			return false;
+		return S_OK;
 	}
-	bool SetLength(
+
+	HRESULT SetString(
 		_In_ DBORDINAL nColumn,
-		_In_ DBLENGTH nLength) throw()
+		_In_z_ BaseType* data) throw()
 	{
 		if (TranslateColumnNo(nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
-			return true;
-		}
-		else
-			return false;
-	}
-	bool GetLength(
-		_In_z_ const CHAR* pColumnName,
-		_Out_ DBLENGTH* pLength) const
-	{
-		ATLENSURE(pColumnName != NULL);
-		ATLENSURE(pLength != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
-			return true;
-		}
-		else
-			return false;
-	}
-	bool GetLength(
-		_In_z_ const WCHAR* pColumnName,
-		_Out_ DBLENGTH* pLength) const
-	{
-		ATLENSURE(pColumnName != NULL);
-		ATLENSURE(pLength != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
-			return true;
-		}
+			return _SetString(nColumn, data);
 		else
-			return false;
+			return DB_S_ERRORSOCCURRED;
 	}
-	bool SetLength(
+	HRESULT SetString(
 		_In_z_ const CHAR* pColumnName,
-		_In_ DBLENGTH nLength) throw()
+		_In_z_ BaseType* data) throw()
 	{
 		ATLASSERT(pColumnName != NULL);
 		DBORDINAL nColumn;
 		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
-			return true;
-		}
+			return _SetString(nColumn, data);
 		else
-			return false;
+			return DB_S_ERRORSOCCURRED;
 	}
-	bool SetLength(
+	HRESULT SetString(
 		_In_z_ const WCHAR* pColumnName,
-		_In_ DBLENGTH nLength) throw()
+		_In_z_ BaseType* data) throw()
 	{
 		ATLASSERT(pColumnName != NULL);
 		DBORDINAL nColumn;
 		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
-			return true;
-		}
-		else
-			return false;
-	}
-	bool GetStatus(
-		_In_ DBORDINAL nColumn,
-		_Out_ DBSTATUS* pStatus) const
-	{
-		ATLENSURE(pStatus != NULL);
-		if (TranslateColumnNo(nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
-			return true;
-		}
+			return _SetString(nColumn, data);
 		else
-			return false;
+			return DB_S_ERRORSOCCURRED;
 	}
-	bool SetStatus(
-		_In_ DBORDINAL nColumn,
-		_In_ DBSTATUS status) throw()
+};
+
+
+typedef CDynamicStringAccessorT<CHAR, DBTYPE_STR> CDynamicStringAccessorA;
+typedef CDynamicStringAccessorT<WCHAR, DBTYPE_WSTR> CDynamicStringAccessorW;
+
+#ifdef _UNICODE
+typedef CDynamicStringAccessorW CDynamicStringAccessor;
+#else
+typedef CDynamicStringAccessorA CDynamicStringAccessor;
+#endif
+
+class CXMLAccessor :
+	public CDynamicStringAccessorW
+{
+public:
+
+	HRESULT GetXMLColumnData(_Inout_ CSimpleStringW& strOutput) throw()
 	{
-		if (TranslateColumnNo(nColumn))
+		_ATLTRY
 		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
-			return true;
-		}
-		else
-			return false;
-	}
-	bool GetStatus(
-		_In_z_ const CHAR* pColumnName,
-		_Out_ DBSTATUS* pStatus) const
-	{
-		ATLENSURE(pColumnName != NULL);
-		ATLENSURE(pStatus != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
-			return true;
+			strOutput = L"<columninfo>\n";
+			DBTYPE wType;
+			DBORDINAL nColumns = m_nColumns;
+			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
+			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
+			{
+				--nColumns;
+			}
+			for (ULONG i=1; i <= nColumns; i++)
+			{
+				strOutput += L"<column type=\"";
+				if( !GetColumnType(i, &wType) )
+					return E_FAIL;
+
+				wType &= ~DBTYPE_BYREF;
+				wType &= ~DBTYPE_ARRAY;
+				wType &= ~DBTYPE_VECTOR;
+
+				switch (wType)
+				{
+				case DBTYPE_BOOL:
+					strOutput += L"BOOL";
+					break;
+				case DBTYPE_STR:
+				case DBTYPE_WSTR:
+					strOutput += L"STRING";
+					break;
+				case DBTYPE_I1:
+					strOutput += L"I1";
+					break;
+				case DBTYPE_I2:
+					strOutput += L"I2";
+					break;
+				case DBTYPE_I4:
+					strOutput += L"I4";
+					break;
+				case DBTYPE_I8:
+					strOutput += L"I8";
+					break;
+				case DBTYPE_UI1:
+					strOutput += L"UI1";
+					break;
+				case DBTYPE_UI2:
+					strOutput += L"UI2";
+					break;
+				case DBTYPE_UI4:
+					strOutput += L"UI4";
+					break;
+				case DBTYPE_UI8:
+					strOutput += L"UI8";
+					break;
+				case DBTYPE_R4:
+					strOutput += L"R4";
+					break;
+				case DBTYPE_R8:
+					strOutput += L"R8";
+					break;
+				case DBTYPE_DECIMAL:
+					strOutput += L"DECIMAL";
+					break;
+				case DBTYPE_NUMERIC:
+					strOutput += L"NUMERIC";
+					break;
+				case DBTYPE_VARIANT:
+					strOutput += L"VARIANT";
+					break;
+				case DBTYPE_IDISPATCH:
+					strOutput += L"DISPATCH";
+					break;
+				case DBTYPE_IUNKNOWN:
+					strOutput += L"IUNKNOWN";
+					break;
+				case DBTYPE_GUID:
+					strOutput += L"GUID";
+					break;
+				case DBTYPE_DBDATE:
+					strOutput += L"DBDATE";
+					break;
+				case DBTYPE_DBTIME:
+					strOutput += L"DBTIME";
+					break;
+				case DBTYPE_DBTIMESTAMP:
+					strOutput += L"DBTIMESTAMP";
+					break;
+				case DBTYPE_FILETIME:
+					strOutput += L"FILETIME";
+					break;
+				case DBTYPE_PROPVARIANT:
+					strOutput += L"PROPVARIANT";
+					break;
+				case DBTYPE_VARNUMERIC:
+					strOutput += L"VARNUMERIC";
+					break;
+				}
+				strOutput += L"\">";
+				strOutput += GetColumnName(i);
+				strOutput += L"</column>\n";
+			}
+			strOutput += L"</columninfo>\n";
+			return S_OK;
 		}
-		else
-			return false;
-	}
-	bool GetStatus(
-		_In_z_ const WCHAR* pColumnName,
-		_Out_ DBSTATUS* pStatus) const
-	{
-		ATLENSURE(pColumnName != NULL);
-		ATLENSURE(pStatus != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+		_ATLCATCH(e)
 		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
-			return true;
+			_ATLDELETEEXCEPTION(e)
+			return E_FAIL;
 		}
-		else
-			return false;
 	}
-	bool SetStatus(
-		_In_z_ const CHAR* pColumnName,
-		_In_ DBSTATUS status) throw()
+
+	HRESULT GetXMLRowData(
+		_Inout_ CSimpleStringW& strOutput,
+		_In_ bool bAppend = false) throw()
 	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+		_ATLTRY
 		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
-			return true;
+			LPOLESTR pszName;
+			if (!bAppend)
+				strOutput.Empty();
+			strOutput += L"<row>";
+			DBORDINAL nColumns = m_nColumns;
+			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
+			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
+			{
+				--nColumns;
+			}
+			for (ULONG i=1; i<=nColumns; i++)
+			{
+				pszName = GetColumnName(i);
+				strOutput += L"<";
+				strOutput += pszName;
+				strOutput += L">";
+				DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
+				if( !GetStatus(i, &dbStatus) )
+					return E_FAIL;
+
+				if (dbStatus!=DBSTATUS_S_ISNULL)
+					strOutput += GetString(i);
+
+				strOutput += L"</";
+				strOutput += pszName;
+				strOutput += L">";
+			}
+			strOutput += L"</row>";
+			return S_OK;
 		}
-		else
-			return false;
-	}
-	bool SetStatus(
-		_In_z_ const WCHAR* pColumnName,
-		_In_ DBSTATUS status) throw()
-	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+		_ATLCATCH(e)
 		{
-			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
-			return true;
+			_ATLDELETEEXCEPTION(e)
+			return E_FAIL;
 		}
-		else
-			return false;
 	}
+};
 
-	// Returns true if a bookmark is available
-	HRESULT GetBookmark(_Inout_ CBookmark<>* pBookmark) const throw()
-	{
-		ATLENSURE_RETURN(pBookmark);
-		HRESULT hr;
-		if (m_pColumnInfo->iOrdinal == 0)
-			hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
-		else
-			hr = E_FAIL;
-		return hr;
-	}
 
-	DBORDINAL GetColumnCount() const throw()
+///////////////////////////////////////////////////////////////////////////
+// class CRowset
+
+template <class TAccessor = CAccessorBase>
+class CRowset
+{
+// Constructors and Destructors
+public:
+	CRowset()
 	{
-		return m_nColumns;
+		m_pXMLAccessor = NULL;
+		m_pAccessor = NULL;
+		m_hRow      = 0;
 	}
-
-	LPOLESTR GetColumnName(_In_ DBORDINAL nColumn) const throw()
+	CRowset(_In_opt_ IRowset* pRowset)
 	{
-		if (TranslateColumnNo(nColumn))
-			return m_pColumnInfo[nColumn].pwszName;
-		else
-			return NULL;
+		m_pXMLAccessor = NULL;
+		m_pAccessor = NULL;
+		m_hRow      = 0;
+		m_spRowset  = pRowset;
 	}
-
-	ATL_DEPRECATED("CDynamicAccessor::GetColumnInfo must be passed an array of string buffers too.")
-	HRESULT GetColumnInfo(
-		_Inout_ IRowset* pRowset,
-		_In_opt_ DBORDINAL* pColumns,
-		_Deref_opt_out_ DBCOLUMNINFO** ppColumnInfo);
-
-ATLPREFAST_SUPPRESS(6387)
-	HRESULT GetColumnInfo(
-		_Inout_ IRowset* pRowset,
-		_Out_ DBORDINAL* pColumns,
-		_Deref_out_  DBCOLUMNINFO** ppColumnInfo,
-		_Deref_out_z_ OLECHAR** ppStringsBuffer) throw()
+	~CRowset()
 	{
-		CComPtr<IColumnsInfo> spColumnsInfo;
-		HRESULT hr = pRowset->QueryInterface(&spColumnsInfo);
-		if (SUCCEEDED(hr))
-			hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);
-
-		return hr;
+		Close();
 	}
-ATLPREFAST_UNSUPPRESS()
-	
-	HRESULT AddBindEntry(_In_ const DBCOLUMNINFO& info) throw()
+
+	HRESULT GetXMLColumnInfo(_Inout_ CSimpleStringW& strOutput) throw()
 	{
-		if ((m_nColumns + 1 < m_nColumns))
-		{
-			return E_OUTOFMEMORY;
+		ATLASSUME(m_spRowset != NULL);
+		HRESULT hr;
+		if( m_pXMLAccessor == NULL )
+		{
+			ATLTRY(m_pXMLAccessor = new CXMLAccessor());
+			if( m_pXMLAccessor == NULL )
+				return E_OUTOFMEMORY;
+			hr = m_pXMLAccessor->BindColumns( m_spRowset );
+			if( FAILED(hr) )
+			{
+				delete m_pXMLAccessor;
+				m_pXMLAccessor = NULL;
+				return hr;
+			}
 		}
-		DBCOLUMNINFO* pTempInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemRecalloc(m_pColumnInfo, (m_nColumns + 1), sizeof(DBCOLUMNINFO));
-		if (pTempInfo == NULL)
-			return E_OUTOFMEMORY;
-		m_pColumnInfo = pTempInfo;
-		m_pColumnInfo[m_nColumns] = info;
-		m_nColumns++;
 
-		return S_OK;
-	}
+		ATLASSUME( m_pXMLAccessor != NULL );
 
-	bool NoBindOnNullRowset() const throw()
-	{
-		return true;
+		return m_pXMLAccessor->GetXMLColumnData( strOutput );
 	}
 
-// Implementation
-	// Free's any columns in the current record that need to be freed.
-	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
-	void FreeRecordMemory(_Inout_ IRowset* pRowset) throw()
+	HRESULT GetXMLRow(
+		_Inout_ CSimpleStringW& strOutput,
+		_In_ bool bAppend = false) throw()
 	{
-		ULONG i;
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_hRow != 0);
 
-		for (i = 0; i < m_nColumns; i++)
+		HRESULT hr;
+		if( m_pXMLAccessor == NULL )
 		{
-			if( m_pfClientOwnedMemRef != NULL && m_pfClientOwnedMemRef[i] == true )
-			{
-				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
-				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
-				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-				if( *(DBSTATUS*)( m_pBuffer + nOffset ) != DBSTATUS_S_ISNULL )
-				{
-					void* pRef = _GetDataPtr(i);
-
-					if( pRef != NULL && *(void**)pRef != NULL )
-					{
-						CoTaskMemFree( *(void**)_GetDataPtr(i) );
-						*(void**)pRef = NULL;
-					}
-				}
-			}
-			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN || m_pColumnInfo[i].wType == DBTYPE_IDISPATCH )
-			{
-				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
-				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
-				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
-				if( *(DBSTATUS*)( m_pBuffer + nOffset ) == DBSTATUS_S_OK )
-					CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
-			}
-			else
+			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
+			if( m_pXMLAccessor == NULL )
+				return E_OUTOFMEMORY;
+			hr = m_pXMLAccessor->BindColumns( m_spRowset );
+			if( FAILED(hr) )
 			{
-				CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
+				delete m_pXMLAccessor;
+				m_pXMLAccessor = NULL;
+				return hr;
 			}
 		}
+
+		ATLASSUME( m_pXMLAccessor != NULL );
+
+		hr = m_spRowset->GetData(m_hRow, m_pXMLAccessor->GetHAccessor(0), m_pXMLAccessor->GetBuffer());
+		if( FAILED(hr) )
+			return hr;
+
+		hr = m_pXMLAccessor->GetXMLRowData( strOutput, bAppend );
+
+		m_pXMLAccessor->FreeRecordMemory( GetInterface() );
+		return hr;
 	}
-	void ClearRecordMemory() throw()
+
+	// Release any retrieved row handles and then release the rowset
+	void Close() throw()
 	{
-		for (ULONG i = 0; i < m_nColumns; i++)
+		if( m_pXMLAccessor != NULL )
 		{
-			memset((BYTE*)_GetDataPtr(i), 0, m_pColumnInfo[i].ulColumnSize);
+			if (m_spRowset != NULL)
+				m_pXMLAccessor->ReleaseAccessors( m_spRowset );
+			delete m_pXMLAccessor;
+			m_pXMLAccessor = NULL;
+		}
+		if (m_spRowset != NULL)
+		{
+			m_pAccessor->FreeRecordMemory(m_spRowset);
+			ReleaseRows();
+			m_spRowset.Release();
+			m_spRowsetChange.Release();
 		}
 	}
-
-	void* _GetDataPtr(_In_ DBORDINAL nColumn) const throw()
+	// Addref the current row
+	HRESULT AddRefRows() throw()
 	{
-		return m_pBuffer + (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
+		ATLASSUME(m_spRowset != NULL);
+		return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
 	}
-	bool GetInternalColumnNo(
-		_In_z_ const CHAR* pColumnName,
-		_Out_ DBORDINAL* pColumn) const
+	// Release the current row
+	HRESULT ReleaseRows() throw()
 	{
-		ATLENSURE(pColumnName != NULL);
-		ATLENSURE(pColumn != NULL);
-		ULONG       i;
-		size_t      nSize = (lstrlenA(pColumnName) + 1) * sizeof(OLECHAR);
-		CComBSTR	bstrColumnName(pColumnName);
+		ATLASSUME(m_spRowset != NULL);
+		HRESULT hr = S_OK;
 
-		// Search through the columns trying to find a match
-		for (i = 0; i < m_nColumns; i++)
-		{
-			ATLASSUME(m_pColumnInfo != NULL);
-			if (m_pColumnInfo[i].pwszName != NULL &&
-				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
-			{
-				break;
-			}
-		}
-		if (i < m_nColumns && pColumn)
-		{
-			*pColumn = i;
-			return true;
-		}
-		else
+		if (m_hRow != 0)
 		{
-			return false;   // Not Found
+			hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
+			m_hRow = 0;
 		}
+		return hr;
 	}
-	bool GetInternalColumnNo(
-		_In_z_ const WCHAR* pColumnName,
-		_Out_ DBORDINAL* pColumn) const
+
+	CRowset<>* GetRowsetBase() throw()
 	{
-		ATLENSURE(pColumnName != NULL);
-		ATLASSERT(pColumn != NULL);
-		ULONG       i;
-		size_t      nSize = (wcslen(pColumnName) + 1) * sizeof(OLECHAR);
-		CComBSTR	bstrColumnName(pColumnName);
+		return (CRowset<>*)this;
+	}
 
-		// Search through the columns trying to find a match
-		for (i = 0; i < m_nColumns; i++)
-		{
-			ATLASSUME(m_pColumnInfo != NULL);
-			if (m_pColumnInfo[i].pwszName != NULL &&
-				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
-				break;
-		}
+	// Compare two bookmarks with each other
+	HRESULT Compare(
+		_In_ const CBookmarkBase& bookmark1,
+		_In_ const CBookmarkBase& bookmark2,
+		_Out_ DBCOMPARE* pComparison) const throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		CComPtr<IRowsetLocate> spLocate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetLocate, (void**)&spLocate);
+		if (FAILED(hr))
+			return hr;
 
-		if (i < m_nColumns && pColumn)
-		{
-			*pColumn = i;
-			return true;
-		}
+		return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
+			bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
+	}
 
-		return false;   // Not Found
+	// Compare the passed hRow with the current row
+	HRESULT IsSameRow(_In_ HROW hRow) const throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		if (m_hRow == hRow)
+			return S_OK;
+
+		CComPtr<IRowsetIdentity> spRowsetIdentity;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetIdentity, (void**)&spRowsetIdentity);
+		if (FAILED(hr))
+			return hr;
+
+		return spRowsetIdentity->IsSameRow(m_hRow, hRow);
 	}
 
-	// Set up the binding structure pointed to by pBindings based upon
-	// the other passed parameters.
-	static void BindEx(
-		_Inout_ DBBINDING* pBinding,
-		_In_ DBORDINAL nOrdinal,
-		_In_ DBTYPE wType,
-		_In_ DBLENGTH nLength,
-		_In_ BYTE nPrecision,
-		_In_ BYTE nScale,
-		_In_ DBPARAMIO eParamIO,
-		_In_ DBBYTEOFFSET nDataOffset,
-		_In_ DBBYTEOFFSET nLengthOffset,
-		_In_ DBBYTEOFFSET nStatusOffset,
-		_In_opt_ DBOBJECT* pdbobject,
-		_In_ DBMEMOWNER dwMemOwner,
-		_In_ bool fSkipData = false )
+	// Move to the previous record
+	HRESULT MovePrev() throw()
 	{
-		ATLENSURE(pBinding != NULL);
+		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		return MoveNext(-2);
+	}
 
-		pBinding->dwMemOwner    = dwMemOwner;
+	// Move to the next record
+	HRESULT MoveNext() throw()
+	{
+		return MoveNext(0);
+	}
 
-		pBinding->pObject       = pdbobject;
+	// Move lSkip records forward or backward
+	HRESULT MoveNext(
+		_In_ LONG lSkip,
+		_In_ bool bForward = true) throw()
+	{
+		HRESULT hr;
+		DBCOUNTITEM ulRowsFetched = 0;
 
-		pBinding->eParamIO      = eParamIO;
-		pBinding->iOrdinal      = nOrdinal;
-		pBinding->wType         = wType;
-		pBinding->bPrecision    = nPrecision;
-		pBinding->bScale        = nScale;
-		pBinding->dwFlags       = 0;
+		// Check the data was opened successfully and the accessor
+		// has been set.
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
 
-		pBinding->obValue       = 0;
-		pBinding->obLength      = 0;
-		pBinding->obStatus      = 0;
-		pBinding->pTypeInfo     = NULL;
-		pBinding->pBindExt      = NULL;
-		pBinding->cbMaxLen      = nLength;
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		// Release a row if one is already around
+		ReleaseRows();
 
-		pBinding->dwPart = 0;
+		// Get the row handle
+		HROW* phRow = &m_hRow;
+		hr = m_spRowset->GetNextRows(0, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
+		if (hr != S_OK)
+			return hr;
 
-		if ( ! fSkipData ) // skip column data
-		{
-			pBinding->dwPart |= DBPART_VALUE;
-			pBinding->obValue = nDataOffset;
-		}
-		if (nLengthOffset != 0) // skip length
+		// Get the data
+		hr = GetData();
+		if (FAILED(hr))
 		{
-			pBinding->dwPart |= DBPART_LENGTH;
-			pBinding->obLength = nLengthOffset;
+			ATLTRACE(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
+			ReleaseRows();
 		}
-		if (nStatusOffset != 0) // skip status
+		return hr;
+	}
+
+	// Move to the first record
+	HRESULT MoveFirst() throw()
+	{
+		HRESULT hr;
+
+		// Check the data was opened successfully and the accessor
+		// has been set.
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
+
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		// Release a row if one is already around
+		ReleaseRows();
+
+		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		hr = m_spRowset->RestartPosition(0);
+		if (FAILED(hr))
+			return hr;
+
+		// Get the data
+		return MoveNext();
+	}
+
+	// Move to the last record
+	HRESULT MoveLast() throw()
+	{
+		// Check the data was opened successfully and the accessor
+		// has been set.
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
+
+		// Release a row if one is already around
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+
+		HRESULT hr;
+		DBCOUNTITEM ulRowsFetched = 0;
+		HROW* phRow = &m_hRow;
+
+		// Restart the rowset position and then move backwards
+
+		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		m_spRowset->RestartPosition(0);
+		hr = m_spRowset->GetNextRows(0, -1, 1, &ulRowsFetched, &phRow);
+		if (hr != S_OK)
+			return hr;
+
+		// Get the data
+		hr = GetData();
+		if (FAILED(hr))
 		{
-			pBinding->dwPart |= DBPART_STATUS;
-			pBinding->obStatus = nStatusOffset;
+			ATLTRACE(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
+			ReleaseRows();
 		}
-	}
 
-	HRESULT GetRowsetProperties(
-		_Inout_ IUnknown* pUnk,
-		_In_ DBPROPID* prgPropertyIDs,
-		_Out_cap_(nPropCount) BOOL* pbValues,
-		_In_ ULONG nPropCount) throw()
+		return S_OK;
+	}
+	// Move to the passed bookmark
+	HRESULT MoveToBookmark(
+		_In_ const CBookmarkBase& bookmark,
+		_In_ LONG lSkip = 0) throw()
 	{
-		ULONG t;
+		// Check the data was opened successfully and the accessor
+		// has been set.
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
 
-		ATLENSURE_RETURN(pUnk != NULL);
-		ATLENSURE_RETURN(pbValues != NULL);
-		ATLASSERT(prgPropertyIDs != NULL);
-		ATLASSERT(nPropCount > 0);
+		CComPtr<IRowsetLocate> spLocate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetLocate, (void**)&spLocate);
+		if (FAILED(hr))
+			return hr;
 
-		CComPtr<IRowsetInfo> spRowsetInfo;
-		HRESULT hr = pUnk->QueryInterface(&spRowsetInfo);
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		// Release a row if one is already around
+		ReleaseRows();
 
-		for( t = 0; t < nPropCount; t++ )
-			pbValues[t] = FALSE;
+		DBCOUNTITEM ulRowsFetched = 0;
+		HROW* phRow = &m_hRow;
+		hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
+			lSkip, 1, &ulRowsFetched, &phRow);
+		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
+		if (hr != S_OK)
+			return hr;
 
+		// Get the data
+		hr = GetData();
 		if (FAILED(hr))
-			ATLASSERT(0); // unable to retrieve IRowsetInfo interface
-		else
 		{
-			DBPROPIDSET            rgPropertyIDSets[1];
-			ULONG                  cPropSets        = 0;
-			CComHeapPtr<DBPROPSET> rgPropSets;
+			ATLTRACE(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
+			ReleaseRows();
+		}
 
-			// Set up the Property ID Set.
-			rgPropertyIDSets[0].rgPropertyIDs       = prgPropertyIDs;
-			rgPropertyIDSets[0].cPropertyIDs        = nPropCount;
-			rgPropertyIDSets[0].guidPropertySet     = DBPROPSET_ROWSET;
+		return S_OK;
+	}
 
-			hr = spRowsetInfo->GetProperties(	1,					// cPropertyIDSets
-												rgPropertyIDSets,	// rgPropertyIDSets
-												&cPropSets,         // pcPropSets
-												&rgPropSets );      // prgPropSets
+	// Get the data for the current record
+	HRESULT GetData() throw()
+	{
+		HRESULT hr = S_OK;
+		ATLASSUME(m_pAccessor != NULL);
 
-			if( SUCCEEDED(hr) )
+		ULONG nAccessors = m_pAccessor->GetNumAccessors();
+		for (ULONG i=0; i<nAccessors; i++)
+		{
+			if (m_pAccessor->IsAutoAccessor(i))
 			{
-				for( t = 0; t < __min(rgPropSets[0].cProperties, nPropCount); t++ )
-					pbValues[t] = V_BOOL(&rgPropSets[0].rgProperties[t].vValue);
-
-				if( rgPropSets[0].rgProperties )
-					CoTaskMemFree(rgPropSets[0].rgProperties);
+				hr = GetData(i);
+				if (FAILED(hr))
+					return hr;
 			}
 		}
-
 		return hr;
 	}
 
-	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
+	// Get the data for the passed accessor. Use for a non-auto accessor
+	HRESULT GetData(_In_ int nAccessor) throw()
 	{
-		IID iidStreamToUse = __uuidof(ISequentialStream);
-		bool fIStreamSupportTested = false;
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
+		ATLASSUME(m_hRow != 0);
 
-		ATLENSURE_RETURN(pUnk != NULL);
-		CComPtr<IAccessor> spAccessor;
-		HRESULT hr = pUnk->QueryInterface(&spAccessor);
-		if (FAILED(hr))
-			return hr;
+		// Note that we are using the specified buffer if it has been set,
+		// otherwise we use the accessor for the data.
+		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
+	}
 
-		ULONG   i;
-		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
+	// Get the data for the passed accessor. Use for a non-auto accessor
+	HRESULT GetDataHere(
+		_In_ int nAccessor,
+		_Out_ void* pBuffer) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
+		ATLASSUME(m_hRow != 0);
 
-		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
-		// we get it ourselves
-		if (m_pColumnInfo == NULL)
+		// Note that we are using the specified buffer if it has been set,
+		// otherwise we use the accessor for the data.
+		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
+	}
+
+	HRESULT GetDataHere(_Out_ void* pBuffer) throw()
+	{
+		HRESULT hr = S_OK;
+
+		ULONG nAccessors = m_pAccessor->GetNumAccessors();
+		for (ULONG i=0; i<nAccessors; i++)
 		{
-			CComPtr<IColumnsInfo> spColumnsInfo;
-			hr = pUnk->QueryInterface(&spColumnsInfo);
+			hr = GetDataHere(i, pBuffer);
 			if (FAILED(hr))
 				return hr;
+		}
+		return hr;
+	}
 
-			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
-			if (FAILED(hr))
-				return hr;
+	// Insert the current record
+	HRESULT Insert(
+		_In_ int nAccessor = 0,
+		_In_ bool bGetHRow = false) throw()
+	{
+		ATLASSUME(m_pAccessor != NULL);
+		HRESULT hr;
+		if (m_spRowsetChange != NULL)
+		{
+			HROW* pHRow;
+			if (bGetHRow)
+			{
+				ReleaseRows();
+				pHRow = &m_hRow;
+			}
+			else
+				pHRow = NULL;
+
+			hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
+					m_pAccessor->GetBuffer(), pHRow);
 
-			m_bOverride = false;
 		}
 		else
-			m_bOverride = true;
+			hr = E_NOINTERFACE;
 
-		DBBINDING* pBinding = NULL;
-		ATLTRY( pBinding = new DBBINDING[m_nColumns] );
-		if( pBinding == NULL )
-			return E_OUTOFMEMORY;
+		return hr;
+	}
 
-		CAutoVectorPtr<DBBINDING> spBinding(pBinding);
+	// Delete the current record
+	HRESULT Delete() const throw()
+	{
+		ATLASSUME(m_pAccessor != NULL);
+		HRESULT hr;
+		if (m_spRowsetChange != NULL)
+			hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
+		else
+			hr = E_NOINTERFACE;
 
-		ATLASSUME(m_pfClientOwnedMemRef == NULL);
-		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
-		if( m_pfClientOwnedMemRef == NULL )
+		return hr;
+	}
+
+	// Update the current record
+	HRESULT SetData() const throw()
+	{
+		ATLASSUME(m_pAccessor != NULL);
+		HRESULT hr = S_OK;
+
+		ULONG nAccessors = m_pAccessor->GetNumAccessors();
+		for (ULONG i=0; i<nAccessors; i++)
 		{
-			return E_OUTOFMEMORY;
+			hr = SetData(i);
+			if (FAILED(hr))
+				return hr;
 		}
+		return hr;
+	}
 
-#ifdef _DEBUG
-		ATLTRACE( "CDynamicAccessor::BindColumns\n" );
-		ATLTRACE( "Number of columns: %d\n", m_nColumns );
-		ATLTRACE( "Blob Handling Mode: " );
-		switch( m_eBlobHandling )
+	// Update the current record with the data in the passed accessor
+	HRESULT SetData(_In_ int nAccessor) const throw()
+	{
+		ATLASSUME(m_pAccessor != NULL);
+		HRESULT hr;
+		if (m_spRowsetChange != NULL)
 		{
-		case DBBLOBHANDLING_DEFAULT:
-			ATLTRACE( "DBBLOBHANDLING_DEFAULT\n" );
-			break;
-		case DBBLOBHANDLING_NOSTREAMS:
-			ATLTRACE( "DBBLOBHANDLING_NOSTREAMS\n" );
-			break;
-		case DBBLOBHANDLING_SKIP:
-			ATLTRACE( "DBBLOBHANDLING_SKIP\n" );
-			break;
-		default:
-			ATLTRACE( "IVALID HANDLING MODE!!!\n" );
+			hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
+				m_pAccessor->GetBuffer());
 		}
-#endif
-		DBBINDING* pCurrent = pBinding;
-		DBOBJECT*  pObject;
+		else
+			hr = E_NOINTERFACE;
 
-		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);
+		return hr;
+	}
 
-		for (i = 0; i < m_nColumns; i++)
-		{
-			// If it's a BLOB or the column size is large enough for us to treat it as
-			// a BLOB then we also need to set up the DBOBJECT structure.
-			m_pfClientOwnedMemRef[i] = false;
-			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize && m_pColumnInfo[i].wType != DBTYPE_IUNKNOWN )
-			{
-				if( m_eBlobHandling == DBBLOBHANDLING_SKIP )
-				{
-					// Calculate the column data offset
-					nDataOffset = 0;
-					// Calculate the column length offset
-					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
-					// Calculate the column status offset
-					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
-					//If ulColumnSize is not zeroed, GetLength and GetStatus will not access the correct offset in buffer.
-					//As they add ulColumnSize to skip the data.
-					m_pColumnInfo[i].ulColumnSize = 0;
-					ATLTRACE( "%d. Column ordinal %d: Binding length and status ONLY\n", i, m_pColumnInfo[i].iOrdinal );
+	// Get the data most recently fetched from or transmitted to the data source.
+	// Does not get values based on pending changes.
+	HRESULT GetOriginalData() throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_pAccessor != NULL);
 
-					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED, true );
-					pCurrent++;
-				}
-				else if( m_eBlobHandling == DBBLOBHANDLING_NOSTREAMS )
-				{
-					// get the value by reference
-					m_pColumnInfo[i].wType |= DBTYPE_BYREF;
-					m_pColumnInfo[i].ulColumnSize   = sizeof(WCHAR*);
-					m_pfClientOwnedMemRef[i] = true;
+		HRESULT hr = S_OK;
+		CComPtr<IRowsetUpdate> spRowsetUpdate;
+		hr = m_spRowset->QueryInterface(IID_IRowsetUpdate, (void**)&spRowsetUpdate);
+		if (FAILED(hr))
+			return hr;
 
-					// Calculate the column data offset
-					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
-					// Calculate the column length offset
-					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
-					// Calculate the column status offset
-					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+		ULONG nAccessors = m_pAccessor->GetNumAccessors();
+		for (ULONG i = 0; i < nAccessors; i++)
+		{
+			hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
+			if (FAILED(hr))
+				return hr;
+		}
+		return hr;
+	}
 
-					ATLTRACE( "%d. Column ordinal %d: Binding by reference in provider allocated, consumer owned memory\n", i, m_pColumnInfo[i].iOrdinal );
+	// Get the status of the current row
+	HRESULT GetRowStatus(_Out_ DBPENDINGSTATUS* pStatus) const throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSERT(pStatus != NULL);
 
-					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
-					pCurrent++;
+		CComPtr<IRowsetUpdate> spRowsetUpdate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetUpdate, (void**)&spRowsetUpdate);
+		if (FAILED(hr))
+			return hr;
 
-				}
-				else // if( m_eBlobHandling == DBBLOBHANDLING_DEFAULT )
-				{
-					// we will try to bind blobs as streams
-					// if we have not tested if the rowset supports streams, do it now
-					if( ! fIStreamSupportTested )
-					{
-						ATLTRACE( "Testing streams support... " );
+		return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
+	}
 
-						DBPROPID rgPropertyIDs[2] = { DBPROP_ISequentialStream, DBPROP_IStream };
-						BOOL     rgStreamsSupported[2] = {FALSE, FALSE};
+	// Undo any changes made to the current row since it was last fetched or Update
+	// was called for it
+	HRESULT Undo(
+		_In_opt_ DBCOUNTITEM* pcRows = NULL,
+		_Out_opt_ HROW* phRow = NULL,
+		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
 
-						// check if the rowset supports IStream* interfaces
-						hr = GetRowsetProperties( pUnk, rgPropertyIDs, rgStreamsSupported, 2 );
-						ATLASSERT( SUCCEEDED( hr ) );
+		CComPtr<IRowsetUpdate> spRowsetUpdate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetUpdate, (void**)&spRowsetUpdate);
+		if (FAILED(hr))
+			return hr;
 
-						if( rgStreamsSupported[0] )
-						{
-							iidStreamToUse = __uuidof(ISequentialStream);
+		CComHeapPtr<HROW> sprgRows;
+		CComHeapPtr<DBROWSTATUS> spRowStatus;
 
-							ATLTRACE( "ISequentialStream is supported\n" );
-						}
-						else if( rgStreamsSupported[1] )
-						{
-							iidStreamToUse = __uuidof(IStream);
+		if (phRow != NULL)
+			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
+		else
+			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);
 
-							ATLTRACE( "IStream is supported\n" );
-						}
-						else
-						{
+		if (phRow != NULL && sprgRows != NULL)
+			*phRow = *sprgRows;
 
-							ATLTRACE( "neither ISequentialStream nor IStream are supported!\n" );
+		if (pStatus != NULL && spRowStatus != NULL)
+			*pStatus = *spRowStatus;
 
-							ATLASSERT(FALSE); // the stream interfaces are not supported!!!
-						}
+		return hr;
+	}
 
-						fIStreamSupportTested = true;
-					}
+	// Transmits any pending changes made to a row since it was last fetched or Update was
+	// called for it. Also see SetData.
+	HRESULT Update(
+		_In_opt_ DBCOUNTITEM* pcRows = NULL,
+		_Out_opt_ HROW* phRow = NULL,
+		_Out_opt_ DBROWSTATUS* pStatus = NULL) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
 
-					pObject = NULL;
-					ATLTRY(pObject = new DBOBJECT);
-					if (pObject == NULL)
-					{
-						for( ULONG t = 0; t < i; t++ )
-							delete pBinding[t].pObject;
+		CComPtr<IRowsetUpdate> spRowsetUpdate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetUpdate, (void**)&spRowsetUpdate);
+		if (FAILED(hr))
+			return hr;
 
-						delete [] m_pfClientOwnedMemRef;
-						m_pfClientOwnedMemRef = NULL;
+		CComHeapPtr<HROW>           sprgRows;
+		CComHeapPtr<DBROWSTATUS>    spRowStatus;
 
-						return E_OUTOFMEMORY;
-					}
-					pObject->dwFlags = STGM_READ;
-					pObject->iid     = iidStreamToUse;
-					m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
-					m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
+		if (phRow != NULL)
+			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
+		else
+			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);
 
-					// Calculate the column data offset
-					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
-					// Calculate the column length offset
-					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
-					// Calculate the column status offset
-					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+		if (phRow != NULL && sprgRows != NULL)
+			*phRow = *sprgRows;
 
-#ifdef _DEBUG
-					if( iidStreamToUse == __uuidof(ISequentialStream) )
-						ATLTRACE( "%d. Column ordinal %d: Binding as an ISequentialStream object\n", i, m_pColumnInfo[i].iOrdinal );
-					else
-						ATLTRACE( "%d. Column ordinal %d: Binding as an IStream object\n", i, m_pColumnInfo[i].iOrdinal );
-#endif
-					Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
-					pCurrent++;
+		if (pStatus != NULL && spRowStatus != NULL)
+			*pStatus = *spRowStatus;
 
-				}
-			}
-			// else if it's a COM object
-			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
-			{
-				pObject = NULL;
-				ATLTRY(pObject = new DBOBJECT);
-				if (pObject == NULL)
-				{
-					for( ULONG t = 0; t < i; t++ )
-						delete pBinding[t].pObject;
+		return hr;
+	}
+	// Transmits any pending changes to all rows made since it was last fetched or Update was
+	// alled for it.  Differs from Update in that it will do every row (even if we don't hold
+	// the handle for it).
+	HRESULT UpdateAll(
+		_In_opt_ DBCOUNTITEM* pcRows = NULL,
+		_Deref_opt_out_ HROW** pphRow = NULL,
+		_Deref_opt_out_ DBROWSTATUS** ppStatus = NULL) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
 
-					delete [] m_pfClientOwnedMemRef;
-					m_pfClientOwnedMemRef = NULL;
+		CComPtr<IRowsetUpdate> spRowsetUpdate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetUpdate, (void**)&spRowsetUpdate);
+		if (FAILED(hr))
+			return hr;
 
-					return E_OUTOFMEMORY;
-				}
-				pObject->dwFlags = STGM_READ;
-				pObject->iid     = __uuidof(IUnknown); // iidPersistToUse;
-				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
-				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
+		// Create some temporary variables to help with debugging.
+		DBCOUNTITEM		cRowsReturned = 0;
+		CComHeapPtr<HROW>			sprgRows;
+		CComHeapPtr<DBROWSTATUS>	spRowStatus;
 
-				// Calculate the column data offset
-				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+		// Passing zero for the 2nd parameter tells the provider to update ALL pending rows.
+		// The 3rd parameter, prghRows is ignored.
+		hr =  spRowsetUpdate->Update(NULL, 0, NULL, &cRowsReturned, &sprgRows, &spRowStatus);
 
-				// Calculate the column length offset
-				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+		// NOTE, the user must CoTaskMemFree *pphRow and *ppStatus after return, if they
+		// are non-NULL.  Otherwise, we'll CoTaskMemFree if they are NULL.
+		if (pcRows != NULL)
+			*pcRows = cRowsReturned;
 
-				// Calculate the column status offset
-				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+		if (pphRow != NULL)
+			*pphRow = sprgRows.Detach();
 
-				ATLTRACE( "%d. Column ordinal %d: Binding a COM object\n", i, m_pColumnInfo[i].iOrdinal );
+		if (ppStatus != NULL)
+			*ppStatus = spRowStatus.Detach();
 
-				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
-				pCurrent++;
+		return hr;
+	}
 
-			}
-			// else if it's not a BLOB or COM object
-			else
-			{
-				pObject = NULL;
+	// Get the approximate position of the row corresponding to the passed bookmark
+	HRESULT GetApproximatePosition(
+		_In_ const CBookmarkBase* pBookmark,
+		_Out_opt_ DBCOUNTITEM* pPosition,
+		_Out_opt_ DBCOUNTITEM* pcRows) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
 
-				// Calculate the size needed if it's a string
-				// including the NULL terminator.
-				if (m_pColumnInfo[i].wType == DBTYPE_STR)
-					m_pColumnInfo[i].ulColumnSize += 1;
+		CComPtr<IRowsetScroll> spRowsetScroll;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetScroll, (void**)&spRowsetScroll);
+		if (SUCCEEDED(hr))
+		{
+			if (pBookmark != NULL)
+				hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
+						pPosition, pcRows);
+			else
+				hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);
 
-				if (m_pColumnInfo[i].wType == DBTYPE_WSTR)
-					m_pColumnInfo[i].ulColumnSize = m_pColumnInfo[i].ulColumnSize*2 + 2;
+		}
+		return hr;
 
-				// Calculate the column data offset
-				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
+	}
+	// Move to a fractional position in the rowset
+	HRESULT MoveToRatio(
+		_In_ DBCOUNTITEM nNumerator,
+		_In_ DBCOUNTITEM nDenominator,
+		_In_ bool bForward = true) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		DBCOUNTITEM nRowsFetched;
 
-				// Calculate the column length offset
-				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+		CComPtr<IRowsetScroll> spRowsetScroll;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetScroll, (void**)&spRowsetScroll);
+		if (FAILED(hr))
+			return hr;
 
-				// Calculate the column status offset
-				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+		HROW* phRow = &m_hRow;
+		hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
+			&nRowsFetched, &phRow);
+		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
+		if (hr == S_OK)
+			hr = GetData();
 
-				ATLTRACE( "%d. Column ordinal %d: Binding as native data type\n", i, m_pColumnInfo[i].iOrdinal );
+		return hr;
+	}
 
-				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
-				pCurrent++;
-			}
+	HRESULT FindNextRow(
+		_In_ DBCOMPAREOP op,
+		_In_ BYTE* pData,
+		_In_ DBTYPE wType,
+		_In_ DBLENGTH nLength,
+		_In_ BYTE bPrecision,
+		_In_ BYTE bScale,
+		_In_ BOOL bSkipCurrent = TRUE,
+		_In_opt_ CBookmarkBase* pBookmark = NULL) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		DBBINDING   binding;
+		HRESULT     hr;
+		HACCESSOR   hAccessor;
+		DBCOUNTITEM ulRowsFetched = 0;
+		HROW*       phRow = &m_hRow;
+		DBLENGTH    cbBookmark;
+		BYTE*       pBookmarkBuffer;
+		CComQIPtr<IAccessor, &IID_IAccessor>        spAccessor(m_spRowset);
+		CComQIPtr<IRowsetFind, &IID_IRowsetFind>    spRowsetFind(m_spRowset);
 
-			// Note that, as we're not using this for anything else, we're using the
-			// pTypeInfo element to store the offset to our data.
-			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
-		}
-		// Allocate the accessor memory if we haven't done so yet
-		if (m_pAccessorInfo == NULL)
-		{
-			hr = AllocateAccessorMemory(1); // We only have one accessor
-			if (FAILED(hr))
-			{
-				for( ULONG t = 0; t < m_nColumns; t++ )
-					delete pBinding[t].pObject;
+		if (spAccessor == NULL || spRowsetFind == NULL)
+			return E_NOINTERFACE;
 
-				delete [] m_pfClientOwnedMemRef;
-				m_pfClientOwnedMemRef = NULL;
+		TAccessor::Bind(&binding, 1, wType, nLength, bPrecision, bScale, DBPARAMIO_NOTPARAM, 0);
+		hr = CAccessorBase::BindEntries(&binding, 1, &hAccessor, nLength, spAccessor);
+		if (FAILED(hr))
+			return hr;
 
-				return hr;
-			}
-			m_pAccessorInfo->bAutoAccessor = true;
+		if (pBookmark == NULL)
+		{
+			cbBookmark = 0;
+			pBookmarkBuffer = NULL;
 		}
-
-		// Allocate enough memory for the data buffer and tell the rowset
-		// Note that the rowset will free the memory in its destructor.
-		m_pBuffer = NULL;
-		ATLTRY(m_pBuffer = new BYTE[nOffset]);
-		if (m_pBuffer == NULL)
+		else
 		{
-			for( ULONG t = 0; t < m_nColumns; t++ )
-				delete pBinding[t].pObject;
-
-			delete [] m_pfClientOwnedMemRef;
-			m_pfClientOwnedMemRef = NULL;
-
-			return E_OUTOFMEMORY;
+			cbBookmark = pBookmark->GetSize();
+			pBookmarkBuffer = pBookmark->GetBuffer();
 		}
-		memset(m_pBuffer, 0, nOffset);
-		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
-				nOffset, spAccessor);
 
-		if( FAILED(hr))
+		hr = spRowsetFind->FindNextRow(DB_NULL_HCHAPTER, hAccessor, pData, op, cbBookmark, pBookmarkBuffer,
+					bSkipCurrent, 1,  &ulRowsFetched, &phRow);
+		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
+		if (hr != S_OK)
+			return hr;
+
+		// Get the data
+		hr = GetData();
+		spAccessor->ReleaseAccessor(hAccessor, NULL);
+		if (FAILED(hr))
 		{
-			delete [] m_pfClientOwnedMemRef;
-			m_pfClientOwnedMemRef = NULL;
+			ATLTRACE(_T("ATL: GetData from FindNextRows failed - HRESULT = 0x%X\n"),hr);
+			ReleaseRows();
 		}
+		return S_OK;
+	}
 
-		return hr;
+// Implementation
+	static const IID& GetIID() throw()
+	{
+		return IID_IRowset;
 	}
 
-	// Translate the column number to the index into the column info array
-	bool TranslateColumnNo(_Inout_ DBORDINAL& nColumn) const throw()
+	IRowset* GetInterface() const throw()
 	{
-		ATLASSUME(m_pColumnInfo != NULL);
-		// If the user has overriden the binding then we need to search
-		// through the column info for the ordinal number
-		if (m_bOverride)
-		{
-			for (ULONG i = 0; i < m_nColumns; i++)
-			{
-				if (m_pColumnInfo[i].iOrdinal == nColumn)
-				{
-					nColumn = i;
-					return true;
-				}
-			}
-			return false;
-		}
-		else
-		{
-			// Note that m_pColumnInfo->iOrdinal will be zero if have bound
-			// a bookmark as the first entry, otherwise it will be 1.
-			// If the column is out of range then return false
-			if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
-				return false;
+		return m_spRowset;
+	}
 
-			// otherwise translate the column to an index into our internal
-			// binding entries array
-			nColumn -= m_pColumnInfo->iOrdinal;
-			return true;
-		}
+	IRowset** GetInterfacePtr() throw()
+	{
+		return &m_spRowset;
 	}
 
-	static size_t GetAlignment(_In_ DBTYPE bType) throw()
+	void SetupOptionalRowsetInterfaces() throw()
 	{
-		if( bType & DBTYPE_BYREF )
-			return __alignof(void*);
+		// Cache IRowsetChange if available
+		if (m_spRowset != NULL)
+			m_spRowset->QueryInterface(IID_IRowsetChange, (void**)&m_spRowsetChange );
+	}
 
-		if( bType & DBTYPE_ARRAY )
-			return __alignof(SAFEARRAY*);
+	HRESULT BindFinished() const throw()
+	{
+		return S_OK;
+	}
 
-		if( bType & DBTYPE_VECTOR )
-			return __alignof(DBVECTOR);
+	void SetAccessor(_In_opt_ TAccessor* pAccessor) throw()
+	{
+		m_pAccessor = pAccessor;
+	}
 
-		switch( bType )
-		{
-		case DBTYPE_I2:
-			return __alignof(signed short);
-			break;
+	CComPtr<IRowset>	m_spRowset;
+	CComPtr<IRowsetChange>	m_spRowsetChange;
+	TAccessor*		m_pAccessor;
+	HROW                    m_hRow;
+	CXMLAccessor*		m_pXMLAccessor;
+};
 
-		case DBTYPE_I4:
-			return __alignof(signed int);
-			break;
+///////////////////////////////////////////////////////////////////////////
+// class CBulkRowset
 
-		case DBTYPE_R4:
-			return __alignof(float);
-			break;
+template <class TAccessor>
+class CBulkRowset : 
+	public CRowset<TAccessor>
+{
+public:
+	CBulkRowset()
+	{
+		// Default the number of rows to bulk fetch to 10
+		m_nRows = 10;
+		m_hr    = S_OK;
+		m_phRow = NULL;
+	}
 
-		case DBTYPE_R8:
-			return __alignof(double);
-			break;
+	~CBulkRowset()
+	{
+		Close();
+	}
 
-		case DBTYPE_CY:
-			return __alignof(__int64);
-			break;
+	void Close() throw()
+	{
+		if (m_spRowset != NULL)
+		{
+			m_pAccessor->FreeRecordMemory(m_spRowset);
+			ReleaseRows();
+		}
+		CRowset<TAccessor>::Close();
 
-		case DBTYPE_DATE:
-			return __alignof(DATE);
-			break;
+		delete [] m_phRow;
+		m_phRow = NULL;
 
-		case DBTYPE_BSTR:
-			return __alignof(BSTR*);
-			break;
-
-		case DBTYPE_IDISPATCH:
-			return __alignof(IDispatch*);
-			break;
-
-		case DBTYPE_ERROR:
-			return __alignof(SCODE);
-			break;
-
-		case DBTYPE_BOOL:
-			return __alignof(VARIANT_BOOL);
-			break;
-
-		case DBTYPE_VARIANT:
-			return __alignof(VARIANT);
-			break;
-
-		case DBTYPE_IUNKNOWN:
-			return __alignof(IUnknown*);
-			break;
-
-		case DBTYPE_DECIMAL:
-			return __alignof(DECIMAL);
-			break;
-
-		case DBTYPE_UI1:
-			return __alignof(unsigned char);
-			break;
-
-		case DBTYPE_I1:
-			return __alignof(signed char);
-			break;
-
-		case DBTYPE_UI2:
-			return __alignof(unsigned short);
-			break;
+		m_hr = S_OK;
+	}
+	// Set the number of row handles that will be retrieved in each
+	// bulk row fetch. The default is 10 and this function must be called
+	// before Open if you wish to change it.
+	void SetRows(_In_ DBROWCOUNT nRows) throw()
+	{
+		if (nRows == 0)
+			nRows = 10;
+		if (nRows != m_nRows)
+		{
+			// This function must be called before the memory is allocated
+			// during binding or between a Close() and a Open()
+			delete m_phRow;
+			m_phRow = NULL;
+			m_nRows = nRows;
+		}
+	}
+	// AddRef all the currently retrieved row handles
+	HRESULT AddRefRows() throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
+	}
+	// Release all the currently retrieved row handles
+	HRESULT ReleaseRows() throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		// We're going to Release the rows so reset the current row position
+		m_nCurrentRow = 0;
+		m_hRow        = 0;
+		DBCOUNTITEM nCurrentRows = m_nCurrentRows;
+		m_nCurrentRows = 0;
+		return m_spRowset->ReleaseRows(nCurrentRows, m_phRow, NULL, NULL, NULL);
+	}
+	// Move to the first record
+	HRESULT MoveFirst() throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
 
-		case DBTYPE_UI4:
-			return __alignof(unsigned int);
-			break;
+		m_hr = S_OK;
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		HRESULT hr = m_spRowset->RestartPosition(NULL);
+		if (FAILED(hr))
+			return hr;
 
-		case DBTYPE_I8:
-			return __alignof(signed char);
-			break;
+		// Get the data
+		return MoveNext(0);
+	}
+	// Move to the last record
+	HRESULT MoveLast() throw()
+	{
+		m_hr = S_OK;
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+		m_hr = S_OK;
+		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		return CRowset<TAccessor>::MoveLast();
+	}
+	// Move to the next record
+	HRESULT MoveNext() throw()
+	{
+		return MoveNext(0);
+	}
+	// Move to the previous record
+	HRESULT MovePrev() throw()
+	{
+		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
+		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
+		return MoveNext(-2);
+	}
+	// Move lSkip records forward or backward
+	HRESULT MoveNext(
+		_In_ DBROWOFFSET lSkip,
+		_In_ bool bForward = true) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		ATLASSUME(m_phRow    != NULL);
 
-		case DBTYPE_UI8:
-			return __alignof(unsigned char);
-			break;
+		m_pAccessor->FreeRecordMemory(m_spRowset);
 
-		case DBTYPE_GUID:
-			return __alignof(GUID);
-			break;
+		// Calculate the record index in the buffer
+		DBROWOFFSET nNewRow = m_nCurrentRow + lSkip + (bForward ? 1 : -1);
 
-		case DBTYPE_BYTES:
-			return __alignof(BYTE);
-			break;
+		bool bFetchNewRows = false;
+		// Is the row in the buffer?
+		// else adjust the skip value
+		if (m_nCurrentRows == 0)
+		{
+			//lSkip = 0;
+			bFetchNewRows = true;
+		}
+		else if (nNewRow >= (DBROWOFFSET)m_nCurrentRows)
+		{
+			bFetchNewRows = true;
+			lSkip = nNewRow - m_nCurrentRows + (bForward ? 0 : (2 - m_nRows));
+		}
+		else if (nNewRow < 0)
+		{
+			lSkip = nNewRow - (m_nCurrentRows - m_nCurrentRow) + (bForward ? 0 : (2 - m_nRows));
+			bFetchNewRows = true;
+		}
 
-		case DBTYPE_STR:
-			return __alignof(char);
-			break;
+		if (bFetchNewRows)
+		{
+			nNewRow = 0;
+			// If we've reached the end of the buffer and we had a non S_OK HRESULT from
+			// the last call to GetNextRows then return that HRESULT now.
+			if (m_hr != S_OK && m_hr != DB_S_ROWLIMITEXCEEDED)
+				return m_hr;
 
-		case DBTYPE_WSTR:
-			return __alignof(short);
-			break;
+			// We've finished with these rows so we need some more
+			// First release any HROWs that we have
+			ReleaseRows();
 
-		case DBTYPE_NUMERIC:
-			return __alignof(DB_NUMERIC);
-			break;
+			// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
+			// DBPROP_CANSCROLLBACKWARDS properties have not been set and the lSkip offset is negative.
+			m_hr = m_spRowset->GetNextRows(NULL, lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
 
-		case DBTYPE_DBDATE:
-			return __alignof(DBDATE);
-			break;
+			// If we have an error HRESULT or we haven't retrieved any rows then return
+			// the HRESULT now.
+			if (FAILED(m_hr) || m_nCurrentRows == 0)
+				return m_hr;
+			if (!bForward)
+				nNewRow = m_nCurrentRows - 1;
+		}
 
-		case DBTYPE_DBTIME:
-			return __alignof(DBTIME);
-			break;
+		// Get the data for the current row
+		m_hRow = m_phRow[m_nCurrentRow = nNewRow];
+		return CRowset<TAccessor>::GetData();
+	}
+	// Move to the passed bookmark
+	HRESULT MoveToBookmark(
+		_In_ const CBookmarkBase& bookmark,
+		_In_ DBCOUNTITEM lSkip = 0) throw()
+	{
+		ATLASSUME(m_spRowset != NULL);
+		CComPtr<IRowsetLocate> spLocate;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetLocate, (void**)&spLocate);
+		if (FAILED(hr))
+			return hr;
 
-		case DBTYPE_DBTIMESTAMP:
-			return __alignof(DBTIMESTAMP);
-			break;
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+		m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
+			lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
+		if( (m_hr != S_OK || m_nCurrentRows == 0 ) && m_hr != DB_S_ENDOFROWSET)
+			return m_hr;
 
-		default:
-			return __alignof(__int64);
-		}
+		// Get the data
+		m_hRow = m_phRow[m_nCurrentRow];
+		return CRowset<TAccessor>::GetData();
 	}
-
-	inline static DBBYTEOFFSET AlignAndIncrementOffset(
-		_Inout_ DBBYTEOFFSET& nOffset,
-		_In_ DBLENGTH nSize,
-		_In_ size_t nAlign) throw()
+	// Move to a fractional position in the rowset
+	HRESULT MoveToRatio(
+		_In_ DBCOUNTITEM nNumerator,
+		_In_ DBCOUNTITEM nDenominator) throw()
 	{
-		DBBYTEOFFSET nResult;
+		ATLASSUME(m_spRowset != NULL);
 
-		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
-		nResult = nOffset;
-		nOffset += nSize;
+		CComPtr<IRowsetScroll> spRowsetScroll;
+		HRESULT hr = m_spRowset->QueryInterface(IID_IRowsetScroll, (void**)&spRowsetScroll);
+		if (FAILED(hr))
+			return hr;
 
-		return nResult;
-	}
+		m_pAccessor->FreeRecordMemory(m_spRowset);
+		ReleaseRows();
+		m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
+		if (m_hr != S_OK || m_nCurrentRows == 0)
+			return m_hr;
 
-	inline static void IncrementAndAlignOffset(
-		_Inout_ DBBYTEOFFSET& nOffset,
-		_In_ DBLENGTH nSize,
-		_In_ size_t nAlign) throw()
+		// Get the data
+		m_hRow = m_phRow[m_nCurrentRow];
+		return CRowset<TAccessor>::GetData();
+	}
+	// Insert the current record
+	HRESULT Insert(
+		_In_ int nAccessor = 0,
+		_In_ bool bGetHRow = false) throw()
 	{
-		nOffset += nSize;
-		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
+		ReleaseRows();
+		return CRowset< TAccessor >::Insert(nAccessor, bGetHRow);
 	}
 
-	typedef CDynamicAccessor _OutputColumnsClass;
-	static bool HasOutputColumns() throw()
-	{
-		return true;
-	}
+// Implementation
+	HRESULT BindFinished() throw()
+	{
+		// No rows in the buffer yet
+		m_nCurrentRows = 0;
+		// Cause MoveNext to automatically perform a new bulk fetch the first time
+		m_nCurrentRow  = 0;
+		m_hr = S_OK;
 
-	DBORDINAL           m_nColumns;
-	bool*				m_pfClientOwnedMemRef;
-	DBCOLUMNINFO*       m_pColumnInfo;
-	OLECHAR*            m_pStringsBuffer;
-	bool                m_bOverride;
+		// Do not allocate if the buffer has been allocated by a previous call to BindFinished.
+		if (m_phRow == NULL)
+		{
+			ATLTRY(m_phRow = new HROW[m_nRows]);
+			if (m_phRow == NULL)
+				return E_OUTOFMEMORY;
+		}
 
-	protected:
-	DBBLOBHANDLINGENUM  m_eBlobHandling;
-	DBLENGTH            m_nBlobSize;
+		return S_OK;
+	}
+
+	CComPtr<IRowset>        m_spRowset;
+	TAccessor*		m_pAccessor;
+	HROW                    m_hRow;
+	HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
+	HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
+	DBROWCOUNT   m_nRows;        // Number of rows that will fit in the buffer
+	DBCOUNTITEM  m_nCurrentRows; // Number of rows currently in the buffer
+	DBCOUNTITEM  m_nCurrentRow;
 };
-	
-template< typename BaseType >
-inline void strcpyT(
-	_Out_z_cap_(maxCount) BaseType *strDest,
-	_In_ size_t maxCount,
-	_In_z_ const BaseType *strSource)
-{
-	return NULL;
-}
 
-template< typename BaseType >
-inline size_t strlenT(_In_z_ const BaseType *string)
+/////////////////////////////////////////////////////////////////////////////
+// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer
+template <class T>
+class CVBufHelper
 {
-	return NULL;
-}
+public:
+	virtual T* operator()(_In_opt_ T* pCurrent)
+	{
+		return pCurrent;
+	}
+};
 
-template<>
-inline void strcpyT<CHAR>(
-	_Out_z_cap_(maxCount) CHAR *strDest,
-	_In_ size_t maxCount,
-	_In_z_ const CHAR *strSource)
+template <class T>
+class CVirtualBuffer
 {
-	Checked::strcpy_s( strDest, maxCount, strSource);
-}
+protected:
+	CVirtualBuffer()
+	{
+	}
+	T* m_pTop;
+	int m_nMaxElements;
+public:
+	T* m_pBase;
+	T* m_pCurrent;
+	explicit CVirtualBuffer(_In_ int nMaxElements)
+	{
+		//in case of overflow throw exception
+		ATLENSURE(nMaxElements>=0);
 
-template<>
-inline size_t strlenT<CHAR>(_In_z_ const CHAR *string)
-{
-	return strlen( string );
-}
+		ATLENSURE(nMaxElements <=size_t(-1)/sizeof(T)); //overflow check
+		m_nMaxElements = nMaxElements;
+ 		m_pBase = (T*) VirtualAlloc(NULL,sizeof(T)*nMaxElements,	MEM_RESERVE, PAGE_READWRITE);
+		if(m_pBase == NULL)
+		{
+			_AtlRaiseException((DWORD)STATUS_NO_MEMORY);
+		}
+		m_pTop = m_pCurrent = m_pBase;
+		// Commit first page - chances are this is all that will be used
+		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
+	}
+	~CVirtualBuffer()
+	{
+		VirtualFree(m_pBase, 0, MEM_RELEASE);
+	}
+	int Except(_In_ LPEXCEPTION_POINTERS lpEP)
+	{
+		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
+		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
+			return EXCEPTION_CONTINUE_SEARCH;
+		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
 
-template<>
-inline void strcpyT<WCHAR>(
-	_Out_z_cap_(maxCount) WCHAR *strDest,
-	_In_ size_t maxCount,
-	_In_z_ const WCHAR *strSource)
-{
-	Checked::wcscpy_s( strDest, maxCount, strSource);
-}
+		// The address is out of this buffer arrange means AV is not conflicted with this buffer.
+		BYTE* pTmp = reinterpret_cast<BYTE*>(m_pBase);
+		if ((pAddress < pTmp) || (pAddress >= pTmp + (sizeof(T) * m_nMaxElements)))
+			return EXCEPTION_CONTINUE_SEARCH;
 
-template<>
-inline size_t strlenT<WCHAR>(_In_z_ const WCHAR *string)
-{
-	return wcslen( string );
-}
+		VirtualAlloc(pAddress, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
+		return EXCEPTION_CONTINUE_EXECUTION;
+	}
+	bool Seek(_In_ int nElement)
+	{
+		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
+		if(nElement < 0 || nElement >= m_nMaxElements)
+			return false;
+		m_pCurrent = &m_pBase[nElement];
+		return true;
+	}
 
-template< typename BaseType, DBTYPEENUM OleDbType >
-class CDynamicStringAccessorT :
-	public CDynamicAccessor
-{
-public:
-	explicit CDynamicStringAccessorT(_In_ DBLENGTH nBlobSize = 8000)
-		: CDynamicAccessor( DBBLOBHANDLING_DEFAULT, nBlobSize )
+#define ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()							\
+	__try																\
+	{																	\
+		/**/
+# define ATL_DBCLI_END_VBUF_GUARDED_REGION()							\
+	} /* try { */														\
+	__except(Except(GetExceptionInformation()))							\
+	{																	\
+		/*EMPTY*/														\
+	}																	\
+		/**/
+
+	void SetAt(
+		_In_ int nElement,
+		_In_ const T& Element)
+	{
+		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
+
+		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+			T* p = &m_pBase[nElement];
+			*p = Element;
+			m_pTop = p++ > m_pTop ? p : m_pTop;
+		ATL_DBCLI_END_VBUF_GUARDED_REGION()
+	}
+	template <class Q>
+	void WriteBulk(_In_ Q& helper)
+	{
+		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+			m_pCurrent = helper(m_pBase);
+			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
+		ATL_DBCLI_END_VBUF_GUARDED_REGION()
+	}
+	void Write(_In_ const T& Element)
+	{
+		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+			*m_pCurrent = Element;
+			m_pCurrent++;
+			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
+		ATL_DBCLI_END_VBUF_GUARDED_REGION()
+	}
+	T& Read()
+	{
+		return *m_pCurrent;
+	}
+	_Ret_opt_z_ operator BSTR()
 	{
+		BSTR bstrTemp = NULL ;
+		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
+				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
+		ATL_DBCLI_END_VBUF_GUARDED_REGION()
+		return bstrTemp;
 	}
+	const T& operator[](_In_ int nElement) const
+	{
+		if(nElement < 0 || nElement >= m_nMaxElements)
+			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
 
-	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
+		return m_pBase[nElement];
+	}
+	operator T*()
 	{
-		ATLENSURE_RETURN(pUnk != NULL);
-		CComPtr<IAccessor> spAccessor;
-		HRESULT hr = pUnk->QueryInterface(&spAccessor);
-		if (FAILED(hr))
-			return hr;
+		return m_pBase;
+	}
 
-		ULONG   i;
-		DBBYTEOFFSET nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
-		DBLENGTH nLength;
+};
 
-		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
-		// we get it ourselves
-		if (m_pColumnInfo == NULL)
-		{
-			CComPtr<IColumnsInfo> spColumnsInfo;
-			hr = pUnk->QueryInterface(&spColumnsInfo);
-			if (FAILED(hr))
-				return hr;
 
-			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
-			if (FAILED(hr))
-				return hr;
+typedef CVirtualBuffer<BYTE> CVirtualBytes;
 
-			m_bOverride = false;
-		}
-		else
-			m_bOverride = true;
+///////////////////////////////////////////////////////////////////////////
+// class CArrayRowset
+//
+// Allows you to access a rowset with an array syntax. TAccessor must be a
+// CAccessor<> type class
 
-		DBBINDING* pBinding = NULL;
-		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
-		if (pBinding == NULL)
-			return E_OUTOFMEMORY;
+template <class TAccessor, class T>
+class CArrayRowset :
+	public CVirtualBuffer<typename TAccessor::DataClass>,
+	protected CBulkRowset<TAccessor>
+{
+public:
+	CArrayRowset(_In_ int nMax = 100000) :
+		CVirtualBuffer<typename TAccessor::DataClass>(nMax)
+	{
+		m_nRowsRead = 0;
+	}
+	typename TAccessor::DataClass& operator[](_In_ int nRow)
+	{
+		ATLASSERT(nRow >= 0);
+		if( nRow < 0 )
+			AtlThrow(E_INVALIDARG);
 
-		::ATL::CAutoVectorPtr<DBBINDING> spBinding(pBinding);
+		HRESULT hr = S_OK;
+		typename TAccessor::DataClass* pCurrent = m_pBase + m_nRowsRead;
 
-		ATLASSUME(m_pfClientOwnedMemRef == NULL);
-		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
-		if( m_pfClientOwnedMemRef == NULL )
+		// Retrieve the row if we haven't retrieved it already
+		while ((ULONG)nRow >= m_nRowsRead)
 		{
-			return E_OUTOFMEMORY;
+			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
+			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+				// Get the row
+				hr = CRowset<TAccessor>::MoveNext();
+				if (hr != S_OK)
+					break;
+			ATL_DBCLI_END_VBUF_GUARDED_REGION()
+			m_nRowsRead++;
+			pCurrent++;
 		}
 
-		DBBINDING* pCurrent = pBinding;
+		if(hr != S_OK)
+		{
+			ATLASSERT(hr != DB_S_ENDOFROWSET);	// if you're getting this assertion, then
+												// most likely you are trying to access an
+												// out of bounds element of CArrayRowset
+												// (ex. table[100].data where table has only
+												// 50 records)
+			AtlThrow(hr);
+		}
 
-		ATLASSUME(m_pColumnInfo != NULL || m_nColumns == 0);
+		return *(m_pBase + nRow);
+	}
 
-		for (i = 0; i < m_nColumns; i++)
+	HRESULT Snapshot() throw()
+	{
+		HRESULT hr = S_FALSE;
+		ATLASSUME(m_nRowsRead == 0);
+		ATLASSUME(m_spRowset != NULL);
+		typename TAccessor::DataClass* pCurrent = m_pBase;
+		m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
+		ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+			hr = CRowset<TAccessor>::MoveFirst();
+		ATL_DBCLI_END_VBUF_GUARDED_REGION()
+		if (FAILED(hr))
+			return hr;
+		do
 		{
-			m_pfClientOwnedMemRef[i] = false;
+			m_nRowsRead++;
+			pCurrent++;
+			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
+			ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION()
+				hr = CRowset<TAccessor>::MoveNext();
+			ATL_DBCLI_END_VBUF_GUARDED_REGION()
+		} while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);
 
-			// If it's a IPersist* object or the column size is large enough for us to treat it as
-			// a BLOB then we will request references (in client owned memory) to a string
-			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
-			{
-				m_pColumnInfo[i].wType      = OleDbType | DBTYPE_BYREF;
-				m_pColumnInfo[i].ulColumnSize   = sizeof(BaseType*);
-				m_pfClientOwnedMemRef[i] = true;
-			}
-			else // We're treating everything as a string so add 1 for the NULL byte.
-			{
-				switch (m_pColumnInfo[i].wType)
-				{
-				case DBTYPE_BOOL:
-					nLength = 2;
-					break;
-				case DBTYPE_BYTES:
-					nLength = m_pColumnInfo[i].ulColumnSize * 2;
-					break;
-				case DBTYPE_BSTR:
-					nLength = m_pColumnInfo[i].ulColumnSize;
-					break;
-				case DBTYPE_STR:
-					nLength = m_pColumnInfo[i].ulColumnSize;
-					break;
-				case DBTYPE_WSTR:
-					nLength = m_pColumnInfo[i].ulColumnSize;
-					break;
-				case DBTYPE_I1:
-					nLength = 5;
-					break;
-				case DBTYPE_I2:
-					nLength = 7;
-					break;
-				case DBTYPE_I4:
-					nLength = 12;
-					break;
-				case DBTYPE_I8:
-					nLength = 22;
-					break;
-				case DBTYPE_UI1:
-					nLength = 4;
-					break;
-				case DBTYPE_UI2:
-					nLength = 6;
-					break;
-				case DBTYPE_UI4:
-					nLength = 11;
-					break;
-				case DBTYPE_UI8:
-					nLength = 21;
-					break;
-				case DBTYPE_R4:
-					nLength = 13;
-					break;
-				case DBTYPE_R8:
-					nLength = 23;		// maybe 9
-					break;
-				case DBTYPE_DECIMAL:
-					nLength = 23;
-					break;
-				case DBTYPE_NUMERIC:
-					nLength = 23;
-					break;
-				case DBTYPE_VARIANT:
-					nLength = 20;
-					break;
-				case DBTYPE_IDISPATCH:
-					nLength = 32;
-					break;
-				case DBTYPE_IUNKNOWN:
-					nLength = 32;
-					break;
-				case DBTYPE_GUID:
-					nLength = 38;
-					break;
-				case DBTYPE_ARRAY:
-					nLength = 32;
-					break;
-				case DBTYPE_VECTOR:
-					nLength = 32;
-					break;
-				case DBTYPE_DATE:
-					nLength = 32;
-					break;
-				case DBTYPE_DBDATE:
-					nLength = 32;
-					break;
-				case DBTYPE_DBTIME:
-					nLength = 32;
-					break;
-				case DBTYPE_DBTIMESTAMP:
-					nLength = 32;
-					break;
-				case DBTYPE_FILETIME:
-					nLength = 32;
-					break;
-				case DBTYPE_PROPVARIANT:
-					nLength = 32;
-					break;
-				case DBTYPE_VARNUMERIC:
-					nLength = 32;
-					break;
-				case DBTYPE_CY:
-					nLength = 32;
-					break;
-				default:
-					ATLASSERT(FALSE); // unhandled column type
-					nLength = 32;
-				}
-				m_pColumnInfo[i].ulColumnSize = (nLength + 1) * sizeof(BaseType);
-				m_pColumnInfo[i].wType = OleDbType;
-			}
+		return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
+	}
+	ULONG   m_nRowsRead;
+	T*	m_pBase;
+	T*	m_pAccessor;
+};
 
-			// Calculate the column data offset
-			nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( OleDbType ) );
+#undef ATL_DBCLI_BEGIN_VBUF_GUARDED_REGION
+#undef ATL_DBCLI_END_VBUF_GUARDED_REGION
 
-			// Calculate the column length offset
-			nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
+// Used when you don't need any parameters or output columns
+class CNoAccessor
+{
+public:
+	// We don't need any typedef's here as the default
+	// global typedef is not to have any parameters and
+	// output columns.
+	HRESULT BindColumns(_In_opt_ IUnknown*) throw()
+	{
+		return S_OK;
+	}
+	HRESULT BindParameters(
+		_In_opt_ HACCESSOR*,
+		_In_opt_ ICommand*,
+		_Deref_opt_out_ void**) throw()
+	{
+		return S_OK;
+	}
+	void Close() throw()
+	{
+	}
+	HRESULT ReleaseAccessors(_In_opt_ IUnknown*) throw()
+	{
+		return S_OK;
+	}
+	void FreeRecordMemory(_Inout_opt_ IRowset* /*pRowset*/) throw()
+	{
+	}
+	void FreeRecordMemory(_In_ int /*nAccessor*/, _Inout_opt_ IRowset* /*pRowset*/) throw()
+	{
+	}
+	HRESULT GetColumnInfo(
+		_In_opt_ IRowset*,
+		_In_opt_ DBORDINAL*,
+		_In_opt_ DBCOLUMNINFO**) throw()
+	{
+		return E_FAIL;
+	}
+	ULONG GetNumAccessors() const throw()
+	{
+		return 0;
+	}
+	bool IsAutoAccessor(_In_ ULONG /*nAccessor*/) const throw()
+	{
+		return false;
+	}
+	HACCESSOR GetHAccessor(_In_ ULONG /*nAccessor*/) const throw()
+	{
+		return 0;
+	}
+	BYTE* GetBuffer() const throw()
+	{
+		ATLASSERT(FALSE);
+		return NULL;
+	}
+	static void Bind(
+		_In_opt_ DBBINDING*,
+		_In_ DBORDINAL,
+		_In_ DBTYPE,
+		_In_ DBLENGTH,
+		_In_ BYTE,
+		_In_ BYTE,
+		_In_ DBPARAMIO,
+		_In_ DBBYTEOFFSET,
+		_In_ DBBYTEOFFSET = 0,
+		_In_ DBBYTEOFFSET = 0,
+		_In_opt_ DBOBJECT* = NULL) throw()
+	{
+		ATLASSERT(FALSE);
+	}
+	bool NoBindOnNullRowset() const throw()
+	{
+		return false;
+	}
+};
 
-			// Calculate the column status offset
-			nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
+// Used when a rowset will not be returned from the command
+template <class TAccessor = CAccessorBase>
+class CNoRowset
+{
+public:
+	HRESULT BindFinished() throw()
+	{
+		return S_OK;
+	}
+	void Close() throw()
+	{
+	}
+	static const IID& GetIID() throw()
+	{
+		return IID_NULL;
+	}
+	IRowset* GetInterface() const throw()
+	{
+		return NULL;
+	}
+	IRowset** GetInterfacePtr() throw()
+	{
+		return NULL;
+	}
+	void SetAccessor(_In_opt_ void*) throw()
+	{
+	}
+	void SetupOptionalRowsetInterfaces() throw()
+	{
+	}
+};
 
-			BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
-				m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
-				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
+// Used with SQL Server 2000, a rowset will not be returned from the command, but instead
+// we get an ISequentialStream object and use it to read the data.
+template <class TAccessor = CAccessorBase>
+class CStreamRowset
+{
+public:
+	// Constructors & destructors
+	CStreamRowset()
+	{
+		m_spStream = NULL;
+	}
 
-			pCurrent++;
+	~CStreamRowset()
+	{
+		Close();
+	}
 
-			// Note that, as we're not using this for anything else, we're using the
-			// pTypeInfo element to store the offset to our data.
-			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
-		}
+	// Methods
+	void Close()
+	{
+		if (m_spStream != NULL)
+			m_spStream.Release();
+	}
 
-		// Allocate the accessor memory if we haven't done so yet
-		if (m_pAccessorInfo == NULL)
-		{
-			hr = AllocateAccessorMemory(1); // We only have one accessor
-			if (FAILED(hr))
-			{
-				delete [] m_pfClientOwnedMemRef;
-				m_pfClientOwnedMemRef = NULL;
-				return hr;
-			}
-			m_pAccessorInfo->bAutoAccessor = true;
-		}
+	// Implementation
+	static const IID& GetIID()
+	{
+		return IID_ISequentialStream;
+	}
+	ISequentialStream* GetInterface() const
+	{
+		return m_spStream;
+	}
+	ISequentialStream** GetInterfacePtr()
+	{
+		return &m_spStream;
+	}
 
-		// Allocate enough memory for the data buffer and tell the rowset
-		// Note that the rowset will free the memory in its destructor.
-		m_pBuffer = NULL;
-		ATLTRY(m_pBuffer = new BYTE[nOffset]);
-		if (m_pBuffer == NULL)
-		{
-			delete [] m_pfClientOwnedMemRef;
-			m_pfClientOwnedMemRef = NULL;
-			return E_OUTOFMEMORY;
-		}
+	HRESULT BindFinished() throw()
+	{
+		return S_OK;
+	}
+	void SetAccessor(_In_opt_ void*) throw()
+	{
+	}
+	void SetupOptionalRowsetInterfaces() throw()
+	{
+	}
 
-		memset(m_pBuffer, 0, nOffset);
-		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
-				nOffset, spAccessor);
+	CComPtr<ISequentialStream> m_spStream;
+};
 
-		if( FAILED(hr) )
-		{
-			delete [] m_pfClientOwnedMemRef;
-			m_pfClientOwnedMemRef = NULL;
-		}
 
-		return hr;
+///////////////////////////////////////////////////////////////////////////
+// class CAccessor
+// T is the class that contains the data that will be accessed.
+ATLPREFAST_SUPPRESS(6387)
+template <class T>
+class CAccessor :
+	public CAccessorBase,
+	public T
+{
+public:
+	typedef T DataClass;
+
+// Implementation
+	HRESULT ReleaseAccessors(_Inout_ IUnknown* pUnk) throw()
+	{
+		FreeRecordMemory( (IRowset*) pUnk );
+		return CAccessorBase::ReleaseAccessors(pUnk);
 	}
 
-	BaseType* GetString(_In_ DBORDINAL nColumn) const throw()
+	// Free's any columns in the current record that need to be freed.
+	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
+	void FreeRecordMemory(
+		_In_ int nAccessor,
+		_In_opt_ IRowset* /* pRowset */) throw()
 	{
-		if (TranslateColumnNo(nColumn))
+		(nAccessor);
+		__if_exists(_GetBindEntries)
 		{
-			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
-				return *(BaseType**)_GetDataPtr(nColumn);
-			else
-				return (BaseType*)_GetDataPtr(nColumn);
+			DBORDINAL nColumns;
+
+			// Passing in m_pBuffer tells the column entry maps to free the
+			// memory for the types if appropriate
+			this->_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL, m_pBuffer);
 		}
-		else
-			return NULL;
+	}
+	void FreeRecordMemory(_Inout_opt_ IRowset* pRowset) throw()
+	{
+		for (ULONG i = 0; i < GetNumAccessors(); i++)
+			FreeRecordMemory(i, pRowset);
 	}
 
-	BaseType* GetString(_In_z_ const CHAR* pColumnName) const throw()
+	HRESULT GetColumnInfo(
+		_In_opt_ IRowset*,
+		_In_opt_ DBORDINAL*,
+		_Deref_out_opt_ DBCOLUMNINFO** ppColumnInfo) throw()
 	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-		{
-			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
-				return *(BaseType**)_GetDataPtr(nColumn);
-			else
-				return (BaseType*)_GetDataPtr(nColumn);
-		}
-		else
-			return NULL;    // Not Found
+		ATLASSERT(ppColumnInfo != NULL);
+		*ppColumnInfo = NULL;
+
+		return E_FAIL;
 	}
 
-	BaseType* GetString(_In_z_ const WCHAR* pColumnName) const throw()
+	void ClearRecordMemory() throw()
 	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
+		__if_exists(_GetBindEntries)
 		{
-			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
-				return *(BaseType**)_GetDataPtr(nColumn);
-			else
-				return (BaseType*)_GetDataPtr(nColumn);
+			for (ULONG i = 0; i < _OutputColumnsClass::_GetNumAccessors(); i++)
+			{
+				DBORDINAL nColumns;
+				this->_GetBindEntries(NULL, &nColumns, NULL, i, NULL, m_pBuffer, true);
+			}
 		}
-		else
-			return NULL;    // Not Found
 	}
 
-	void _SetLength(
-		_In_ DBORDINAL nColumn,
-		_In_ DBLENGTH nLength) throw()
+	HRESULT BindColumns(_Inout_ IUnknown* pUnk) throw()
 	{
-		DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
-		IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
-		*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
-	}
+		HRESULT hr;
+		ULONG   nAccessors;
+		DBLENGTH  nSize;
+		nAccessors = _OutputColumnsClass::_GetNumAccessors();
 
-	HRESULT _SetString(
-		_In_ DBORDINAL nColumn,
-		_In_z_ BaseType* data) throw()
+		SetBuffer((BYTE*)(T*)this);
+		ClearRecordMemory();
+
+		nSize = sizeof(T);
+		hr = BindAccessors(nAccessors, nSize, pUnk);
+		return hr;
+	}
+	HRESULT BindAccessors(
+		_In_ ULONG nAccessors,
+		_In_ DBLENGTH nSize,
+		_Inout_ IUnknown* pUnk) throw()
 	{
-		DBLENGTH stringLen = (DBLENGTH)strlenT<BaseType>( data );
+		ATLENSURE_RETURN(pUnk != NULL);
+		HRESULT hr;
 
-		if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
+		CComPtr<IAccessor> spAccessor;
+		hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
+		if (SUCCEEDED(hr))
 		{
-			BaseType** pBuffer = (BaseType**)_GetDataPtr(nColumn);
+			// Allocate the accessor memory if we haven't done so yet
+			if (m_pAccessorInfo == NULL)
+			{
+				hr = AllocateAccessorMemory(nAccessors);
+				if (FAILED(hr))
+					return hr;
+			}
 
+			for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
+				hr = BindAccessor(spAccessor, i, nSize);
+		}
 
+		return hr;
+	}
 
-			//in case of overflow throw exception
-			if (stringLen + 1>(size_t(-1)/sizeof(BaseType)))
-			{
-				return(E_FAIL);//arithmetic overflow
-			}
+	HRESULT BindAccessor(
+		_Inout_ IAccessor* pAccessor,
+		_In_ ULONG nAccessor,
+		_In_ DBLENGTH nSize) throw()
+	{
+		CAutoVectorPtr<DBBINDING>	spBindings;
+		CAutoVectorPtr<LPOLESTR>	spColumnNames;
+		DBORDINAL			nColumns = 0;
+		bool				bAuto = false;
+		HRESULT				hr;
+		CComHeapPtr<DBCOLUMNINFO>	spColumnInfo;
+		DBORDINAL			nColumnInfoCount = 0;
+		CComHeapPtr<OLECHAR>		spStringsBuffer;
 
-			BaseType* pNewBuffer = (BaseType*)::ATL::AtlCoTaskMemRecalloc( *pBuffer, (stringLen + 1), sizeof(BaseType));
-			if( pNewBuffer == NULL )
-				return E_OUTOFMEMORY;
+		// First time just get the number of entries by passing in &nColumns
+		_OutputColumnsClass::_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL);
 
-			*pBuffer = pNewBuffer;
-			strcpyT<BaseType>( pNewBuffer, stringLen+1, data);
-			_SetLength( nColumn, stringLen * sizeof(BaseType) );
+		ATLASSERT(nColumns > 0);
+
+		// Allocate the binding structures
+		if( !spBindings.Allocate(nColumns) )
+			return E_OUTOFMEMORY;
+
+		for( ULONG i = 0; i < nColumns; i++ )
+			spBindings[i].pObject = NULL;
+
+		// Allocate the column names strings array
+		if( !spColumnNames.Allocate(nColumns) )
+			return E_OUTOFMEMORY;
+
+		// Now get the bind entries
+		hr = _OutputColumnsClass::_GetBindEntries(spColumnNames, &nColumns, spBindings, nAccessor, &bAuto);
+		if (SUCCEEDED(hr))
+		{
+			// translate the columns names to oridinals if necessary
+			for( ULONG i = 0; i < nColumns; i++ )
+				if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
+				{
+					// if necessary, get the column information
+					if( spColumnInfo == NULL )
+					{
+						if( FAILED( GetColumnNames( pAccessor, &spColumnInfo, &spStringsBuffer, &nColumnInfoCount ) ) )
+						{
+							ATLASSERT( FALSE ); // unable to get columns information
+							return E_FAIL;
+						}
+					}
+					if( ! GetOridinalColumnNo(spColumnNames[i], spBindings[i].iOrdinal, spColumnInfo, nColumnInfoCount ) )
+					{
+						ATLASSERT(FALSE); // unable to match column name to an oridinal !!!
+						return E_FAIL;
+					}
+				}
+
+			m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
+			hr = BindEntries(spBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
 		}
 		else
 		{
-			BaseType* pBuffer = (BaseType*)_GetDataPtr(nColumn);
-			if( stringLen >= m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) )
-			{
-				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1, data);
-				pBuffer[m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType) - 1] = 0;
-				_SetLength( nColumn, m_pColumnInfo[nColumn].ulColumnSize - sizeof(BaseType));
-				return DBSTATUS_S_TRUNCATED;
-			}
-			else
-			{
-				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize / sizeof(BaseType), data);
-				_SetLength( nColumn, stringLen * sizeof(BaseType) );
-			}
+			// free any DBBINDING::pObject's
+			for( ULONG i = 0; i < nColumns; i++ )
+				delete spBindings[i].pObject;
+
 		}
-		return S_OK;
+		return hr;
 	}
 
-	HRESULT SetString(
-		_In_ DBORDINAL nColumn,
-		_In_z_ BaseType* data) throw()
-	{
-		if (TranslateColumnNo(nColumn))
-			return _SetString(nColumn, data);
-		else
-			return DB_S_ERRORSOCCURRED;
-	}
-	HRESULT SetString(
-		_In_z_ const CHAR* pColumnName,
-		_In_z_ BaseType* data) throw()
-	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-			return _SetString(nColumn, data);
-		else
-			return DB_S_ERRORSOCCURRED;
-	}
-	HRESULT SetString(
-		_In_z_ const WCHAR* pColumnName,
-		_In_z_ BaseType* data) throw()
+	HRESULT BindParameters(
+		_In_ HACCESSOR* pHAccessor,
+		_Inout_ ICommand* pCommand,
+		_Deref_out_ void** ppParameterBuffer) throw()
 	{
-		ATLASSERT(pColumnName != NULL);
-		DBORDINAL nColumn;
-		if (GetInternalColumnNo(pColumnName, &nColumn))
-			return _SetString(nColumn, data);
-		else
-			return DB_S_ERRORSOCCURRED;
-	}
-};
+		HRESULT				hr = S_OK;
+		ATLENSURE_RETURN(ppParameterBuffer);
 
+		// In the static accessor case, the parameter buffer will be T plus the size of CAccessorBase
+		*ppParameterBuffer = static_cast<T*>(this);
 
-typedef CDynamicStringAccessorT<CHAR, DBTYPE_STR> CDynamicStringAccessorA;
-typedef CDynamicStringAccessorT<WCHAR, DBTYPE_WSTR> CDynamicStringAccessorW;
+		// Only bind the parameters if we haven't already done it
+		if (*pHAccessor == 0)
+		{
+			DBORDINAL			nColumns = 0;
+			CAutoVectorPtr<DBBINDING>	spBinding;
+			CAutoVectorPtr<LPOLESTR>	spColumnNames;
 
-#ifdef _UNICODE
-typedef CDynamicStringAccessorW CDynamicStringAccessor;
-#else
-typedef CDynamicStringAccessorA CDynamicStringAccessor;
-#endif
+			CComHeapPtr<DBPARAMINFO>	spParameterInfo;
+			DB_UPARAMS			nParameterInfoCount = 0;
+			CComHeapPtr<OLECHAR>		spStringsBuffer;
 
-class CXMLAccessor :
-	public CDynamicStringAccessorW
-{
-public:
+			_ParamClass::_GetParamEntries(NULL, &nColumns, NULL);
+
+			// Allocate the DBPARAMINFO array
+			if( !spBinding.Allocate(nColumns) )
+				return E_OUTOFMEMORY;
+
+			// Allocate the column names strings array
+			if( !spColumnNames.Allocate(nColumns) )
+				return E_OUTOFMEMORY;
 
-	HRESULT GetXMLColumnData(_Inout_ CSimpleStringW& strOutput) throw()
-	{
-		_ATLTRY
-		{
-			strOutput = L"<columninfo>\n";
-			DBTYPE wType;
-			DBORDINAL nColumns = m_nColumns;
-			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
-			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
-			{
-				--nColumns;
-			}
-			for (ULONG i=1; i <= nColumns; i++)
+			hr = _ParamClass::_GetParamEntries(spColumnNames, &nColumns, spBinding);
+			if (SUCCEEDED(hr))
 			{
-				strOutput += L"<column type=\"";
-				if( !GetColumnType(i, &wType) )
-					return E_FAIL;
+				for( ULONG i = 0; i < nColumns; i++ )
+				{
+					// For bindings in parameter accessors, consumer-owned memory must always be used.
+					spBinding[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 
-				wType &= ~DBTYPE_BYREF;
-				wType &= ~DBTYPE_ARRAY;
-				wType &= ~DBTYPE_VECTOR;
+					// translate the columns names to oridinals if necessary
+					if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
+					{
+						// if necessary, get the column information
+						if( spParameterInfo == NULL )
+						{
+							if( FAILED( GetParameterNames( pCommand, &spParameterInfo, &spStringsBuffer, &nParameterInfoCount ) ) )
+							{
+								ATLASSERT( FALSE ); // unable to get columns information
+								return E_FAIL;
+							}
+						}
+						if( ! GetOridinalParameterNo(spColumnNames[i], spBinding[i].iOrdinal, spParameterInfo, nParameterInfoCount ) )
+						{
+							ATLASSERT(FALSE); // unable to match parameter name to an oridinal !!!
+							return E_FAIL;
+						}
+					}
+				}
 
-				switch (wType)
+				// Get the IAccessor from the passed ICommand
+				ATLENSURE_RETURN(pCommand != NULL);
+				CComPtr<IAccessor> spAccessor;
+				hr = pCommand->QueryInterface(IID_IAccessor, (void**)&spAccessor);
+				if (SUCCEEDED(hr))
 				{
-				case DBTYPE_BOOL:
-					strOutput += L"BOOL";
-					break;
-				case DBTYPE_STR:
-				case DBTYPE_WSTR:
-					strOutput += L"STRING";
-					break;
-				case DBTYPE_I1:
-					strOutput += L"I1";
-					break;
-				case DBTYPE_I2:
-					strOutput += L"I2";
-					break;
-				case DBTYPE_I4:
-					strOutput += L"I4";
-					break;
-				case DBTYPE_I8:
-					strOutput += L"I8";
-					break;
-				case DBTYPE_UI1:
-					strOutput += L"UI1";
-					break;
-				case DBTYPE_UI2:
-					strOutput += L"UI2";
-					break;
-				case DBTYPE_UI4:
-					strOutput += L"UI4";
-					break;
-				case DBTYPE_UI8:
-					strOutput += L"UI8";
-					break;
-				case DBTYPE_R4:
-					strOutput += L"R4";
-					break;
-				case DBTYPE_R8:
-					strOutput += L"R8";
-					break;
-				case DBTYPE_DECIMAL:
-					strOutput += L"DECIMAL";
-					break;
-				case DBTYPE_NUMERIC:
-					strOutput += L"NUMERIC";
-					break;
-				case DBTYPE_VARIANT:
-					strOutput += L"VARIANT";
-					break;
-				case DBTYPE_IDISPATCH:
-					strOutput += L"DISPATCH";
-					break;
-				case DBTYPE_IUNKNOWN:
-					strOutput += L"IUNKNOWN";
-					break;
-				case DBTYPE_GUID:
-					strOutput += L"GUID";
-					break;
-				case DBTYPE_DBDATE:
-					strOutput += L"DBDATE";
-					break;
-				case DBTYPE_DBTIME:
-					strOutput += L"DBTIME";
-					break;
-				case DBTYPE_DBTIMESTAMP:
-					strOutput += L"DBTIMESTAMP";
-					break;
-				case DBTYPE_FILETIME:
-					strOutput += L"FILETIME";
-					break;
-				case DBTYPE_PROPVARIANT:
-					strOutput += L"PROPVARIANT";
-					break;
-				case DBTYPE_VARNUMERIC:
-					strOutput += L"VARNUMERIC";
-					break;
+					hr = BindEntries(spBinding, nColumns, pHAccessor, sizeof(T), spAccessor);
 				}
-				strOutput += L"\">";
-				strOutput += GetColumnName(i);
-				strOutput += L"</column>\n";
 			}
-			strOutput += L"</columninfo>\n";
-			return S_OK;
-		}
-		_ATLCATCH(e)
-		{
-			_ATLDELETEEXCEPTION(e)
-			return E_FAIL;
 		}
+		return hr;
 	}
 
-	HRESULT GetXMLRowData(
-		_Inout_ CSimpleStringW& strOutput,
-		_In_ bool bAppend = false) throw()
+protected:
+	bool GetOridinalColumnNo(
+		_In_z_ LPCOLESTR pOleColumnName,
+		_Out_ DBORDINAL& nColumn,
+		_In_count_(nColumns) DBCOLUMNINFO* pColumnInfo,
+		_In_ DBORDINAL nColumns) throw()
 	{
-		_ATLTRY
+		ATLASSERT(pOleColumnName != NULL);
+		ATLASSERT(pColumnInfo != NULL);
+
+		if( pOleColumnName == NULL || pColumnInfo == NULL )
+			return false;
+
+		// Search through the columns trying to find a match
+		for (ULONG i = 0; i < nColumns; i++)
 		{
-			LPOLESTR pszName;
-			if (!bAppend)
-				strOutput.Empty();
-			strOutput += L"<row>";
-			DBORDINAL nColumns = m_nColumns;
-			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
-			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
+			if (pColumnInfo[i].pwszName != NULL && wcscmp(pColumnInfo[i].pwszName, pOleColumnName) == 0)
 			{
-				--nColumns;
+				nColumn = pColumnInfo[i].iOrdinal;
+				return true;
 			}
-			for (ULONG i=1; i<=nColumns; i++)
-			{
-				pszName = GetColumnName(i);
-				strOutput += L"<";
-				strOutput += pszName;
-				strOutput += L">";
-				DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
-				if( !GetStatus(i, &dbStatus) )
-					return E_FAIL;
+		}
+		return false;   // Not Found
+	}
+	
+	HRESULT GetColumnNames(
+		_Inout_ IAccessor* pAccessor,
+		_Deref_out_ DBCOLUMNINFO** ppColumnInfo,
+		_Deref_out_z_ OLECHAR** ppStringsBuffer,
+		_Out_ DBORDINAL* pnColumns) throw()
+	{
+		ATLASSERT( ppColumnInfo != NULL );
+		ATLASSERT( ppStringsBuffer != NULL );
+		ATLASSERT( pnColumns != NULL );
+		ATLASSERT( pAccessor != NULL );
 
-				if (dbStatus!=DBSTATUS_S_ISNULL)
-					strOutput += GetString(i);
+		if( ppColumnInfo == NULL || ppStringsBuffer == NULL || pnColumns == NULL || pAccessor == NULL )
+			return E_FAIL;
 
-				strOutput += L"</";
-				strOutput += pszName;
-				strOutput += L">";
+		CComPtr<IColumnsInfo> spColumnsInfo;
+		HRESULT hr = pAccessor->QueryInterface(IID_IColumnsInfo, (void**)&spColumnsInfo);
+		if (FAILED(hr))
+			return hr;
+
+		hr = spColumnsInfo->GetColumnInfo(pnColumns, ppColumnInfo, ppStringsBuffer);
+		if (FAILED(hr))
+			return hr;
+
+		return S_OK;
+	}
+	
+	bool GetOridinalParameterNo(
+		_In_z_ LPCOLESTR pOleParameterName,
+		_Out_ DB_UPARAMS& nParameter,
+		_In_count_(nParameters) DBPARAMINFO* pParameterInfo,
+		_In_ DB_UPARAMS nParameters) throw()
+	{
+		ATLASSERT(pOleParameterName != NULL);
+		ATLASSERT(pParameterInfo != NULL);
+
+		if( pOleParameterName == NULL || pParameterInfo == NULL )
+			return false;
+
+		// Search through the columns trying to find a match
+		for (ULONG i = 0; i < nParameters; i++)
+		{
+			if (pParameterInfo[i].pwszName != NULL && wcscmp(pParameterInfo[i].pwszName, pOleParameterName) == 0)
+			{
+				nParameter = pParameterInfo[i].iOrdinal;
+				return true;
 			}
-			strOutput += L"</row>";
-			return S_OK;
 		}
-		_ATLCATCH(e)
-		{
-			_ATLDELETEEXCEPTION(e)
+		return false;   // Not Found
+	}
+
+	HRESULT GetParameterNames(
+		_Inout_ ICommand* pCmd,
+		_Deref_out_ DBPARAMINFO** ppParameterInfo,
+		_Deref_out_z_ OLECHAR** ppStringsBuffer,
+		_Out_ DB_UPARAMS* pnParameters) throw()
+	{
+		ATLASSERT( ppParameterInfo != NULL );
+		ATLASSERT( ppStringsBuffer != NULL );
+		ATLASSERT( pnParameters != NULL );
+		ATLASSERT( pCmd != NULL );
+
+		if( ppParameterInfo == NULL || ppStringsBuffer == NULL || pnParameters == NULL || pCmd == NULL )
 			return E_FAIL;
-		}
+
+		CComPtr<ICommandWithParameters> spCommandWithParameters;
+		HRESULT hr = pCmd->QueryInterface(IID_ICommandWithParameters, (void**)&spCommandWithParameters);
+		if (FAILED(hr))
+			return hr;
+
+		hr = spCommandWithParameters->GetParameterInfo(pnParameters, ppParameterInfo, ppStringsBuffer);
+		if (FAILED(hr))
+			return hr;
+
+		return S_OK;
 	}
 };
 
@@ -4919,7 +4917,7 @@ public:
 	{
 		ATLENSURE_RETURN(pUnk != NULL);
 		CComPtr<IAccessor> spAccessor;
-		HRESULT hr = pUnk->QueryInterface(&spAccessor);
+		HRESULT hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
@@ -4931,7 +4929,7 @@ public:
 		if (m_pColumnInfo == NULL)
 		{
 			CComPtr<IColumnsInfo> spColumnsInfo;
-			hr = pUnk->QueryInterface(&spColumnsInfo);
+			hr = pUnk->QueryInterface(IID_IColumnsInfo, (void**)&spColumnsInfo);
 			if (FAILED(hr))
 				return hr;
 
@@ -4973,7 +4971,7 @@ public:
 					return E_OUTOFMEMORY;
 				}
 				pObject->dwFlags = STGM_READ;
-				pObject->iid     = __uuidof(ISequentialStream);
+				pObject->iid     = IID_ISequentialStream;
 				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
 				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
 			}
@@ -5494,13 +5492,13 @@ public:
 
 		CComPtr<IAccessor> spAccessor;
 		ATLENSURE_RETURN(pCommand != NULL);
-		HRESULT hr = pCommand->QueryInterface(&spAccessor);
+		HRESULT hr = pCommand->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
 		// Try to bind parameters if available
 		CComPtr<ICommandWithParameters> spCommandParameters;
-		hr = pCommand->QueryInterface(&spCommandParameters);
+		hr = pCommand->QueryInterface(IID_ICommandWithParameters, (void**)&spCommandParameters);
 		if (FAILED(hr))
 			return hr;
 
@@ -5786,7 +5784,7 @@ public:
 	{
 		ATLENSURE_RETURN(pUnk != NULL);
 		CComPtr<IAccessor> spAccessor;
-		HRESULT hr = pUnk->QueryInterface(&spAccessor);
+		HRESULT hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
@@ -5817,7 +5815,7 @@ public:
 			// Get the IAccessor from the passed IUnknown
 			CComPtr<IAccessor> spAccessor;
 			ATLENSURE_RETURN(pCommand != NULL);
-			hr = pCommand->QueryInterface(&spAccessor);
+			hr = pCommand->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 			if (SUCCEEDED(hr))
 			{
 				hr = BindEntries(m_pParameterEntry, m_nParameters, pHAccessor,
@@ -5928,7 +5926,7 @@ public:
 			(BYTE*)pData - m_pBuffer);
 
 		CComPtr<IAccessor> spAccessor;
-		HRESULT hr = pUnk->QueryInterface(&spAccessor);
+		HRESULT hr = pUnk->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 		if (FAILED(hr))
 			return hr;
 
@@ -6006,7 +6004,7 @@ public:
 			// Get the IAccessor from the passed ICommand
 			CComPtr<IAccessor> spAccessor;
 			ATLENSURE_RETURN(pCommand != NULL);
-			hr = pCommand->QueryInterface(&spAccessor);
+			hr = pCommand->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 			if (SUCCEEDED(hr))
 			{
 				*ppParameterBuffer = m_pParamInfo->m_pBuffer;
@@ -6073,10 +6071,10 @@ ATLPREFAST_SUPPRESS(6387)
 			return E_POINTER;
 
 		ATLASSERT(GetInterface() != NULL);
-		if (GetInterface() == NULL)
+		if (this->GetInterface() == NULL)
 			return E_FAIL;
 		CComPtr<IColumnsInfo> spColumns;
-		HRESULT hr = GetInterface()->QueryInterface(&spColumns);
+		HRESULT hr = this->GetInterface()->QueryInterface(IID_IColumnsInfo, (void**)&spColumns);
 		if (SUCCEEDED(hr))
 			hr = spColumns->GetColumnInfo(pulColumns, ppColumnInfo, ppStrings);
 
@@ -6093,12 +6091,12 @@ ATLPREFAST_UNSUPPRESS()
 		// If you get a compilation here, then you are most likely calling this function
 		// from a class that is not using CDynamicAccessor.
 		ATLASSERT(GetInterface() != NULL);
-		if (GetInterface() == NULL)
+		if (this->GetInterface() == NULL)
 			return E_FAIL;
 
 		ATLASSUME(ppColumnInfo != NULL);
 
-		return TAccessor::GetColumnInfo(GetInterface(), pColumns, ppColumnInfo);
+		return TAccessor::GetColumnInfo(this->GetInterface(), pColumns, ppColumnInfo);
 	}
 	
 	// Call to bind the output columns
@@ -6106,19 +6104,19 @@ ATLPREFAST_UNSUPPRESS()
 	{
 		// Bind should only be called when we've successfully opened the rowset
 		ATLASSERT(GetInterface() != NULL);
-		if (GetInterface() == NULL)
+		if (this->GetInterface() == NULL)
 			return E_FAIL;
-		HRESULT hr = TAccessor::BindColumns(GetInterface());
+		HRESULT hr = TAccessor::BindColumns(this->GetInterface());
 		if (SUCCEEDED(hr))
-			hr = BindFinished();
+			hr = this->BindFinished();
 		return hr;
 	}
 	// Close the opened rowset and release the created accessors for the output columns
 	void Close() throw()
 	{
-		if (GetInterface() != NULL)
+		if (this->GetInterface() != NULL)
 		{
-			ReleaseAccessors(GetInterface());
+			this->ReleaseAccessors(this->GetInterface());
 			TAccessor::Close();
 			TRowset<TAccessor>::Close();
 		}
@@ -6133,6 +6131,7 @@ ATLPREFAST_UNSUPPRESS()
 	{
 		TAccessor::FreeRecordMemory(nAccessor, m_spRowset);
 	}
+	IUnknown* m_spRowset;
 };
 
 ///////////////////////////////////////////////////////////////////////////
@@ -6171,12 +6170,12 @@ public:
 			return E_FAIL;
 
 		// Bind the moniker for the sources rowset
-		if (FAILED(BindMoniker(pMoniker, 0, __uuidof(ISourcesRowset),
+		if (FAILED(BindMoniker(pMoniker, 0, IID_ISourcesRowset,
 					(void**)&m_spSourcesRowset)))
 			return E_FAIL;
 
 		// Enumerate the data sources
-		if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
+		if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, IID_IRowset, 0,
 			NULL, (IUnknown**)&m_spRowset)))
 			return E_FAIL;
 
@@ -6201,12 +6200,12 @@ public:
 		HRESULT hr;
 		// Create the enumerator
 		hr = CoCreateInstance(*pClsid, NULL, CLSCTX_INPROC_SERVER,
-				__uuidof(ISourcesRowset), (LPVOID*)&m_spSourcesRowset);
+				IID_ISourcesRowset, (LPVOID*)&m_spSourcesRowset);
 		if (FAILED(hr))
 			return hr;
 
 		// Get the rowset so we can enumerate the data sources
-		hr = m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
+		hr = m_spSourcesRowset->GetSourcesRowset(NULL, IID_IRowset, 0,
 			NULL, (IUnknown**)&m_spRowset);
 		if (FAILED(hr))
 			return hr;
@@ -6236,7 +6235,7 @@ public:
 		if (m_spSourcesRowset == NULL)
 			return E_FAIL;
 
-		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
+		hr = m_spSourcesRowset->QueryInterface(IID_IParseDisplayName, (void**)&spParse);
 		if (FAILED(hr))
 			return hr;
 
@@ -6259,7 +6258,7 @@ public:
 		if (m_spSourcesRowset == NULL)
 			return E_FAIL;
 
-		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
+		hr = m_spSourcesRowset->QueryInterface(IID_IParseDisplayName, (void**)&spParse);
 		if (FAILED(hr))
 			return hr;
 
@@ -6302,7 +6301,7 @@ public:
 		HRESULT hr;
 
 		m_spInit.Release();
-		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
+		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,
 				(void**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
@@ -6318,7 +6317,7 @@ public:
 		_In_ long nInitMode = 0) throw()
 	{
 		m_spInit.Release();
-		HRESULT hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
+		HRESULT hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,
 				(void**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
@@ -6400,7 +6399,7 @@ public:
 
 		m_spInit.Release();
 		//  Now bind the moniker
-		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
+		hr = BindMoniker(spMoniker, 0, IID_IDBInitialize, (void**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
 
@@ -6421,7 +6420,7 @@ public:
 
 		m_spInit.Release();
 		//  Now bind the moniker
-		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
+		hr = BindMoniker(spMoniker, 0, IID_IDBInitialize, (void**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
 
@@ -6434,18 +6433,18 @@ public:
 	{
 		CComPtr<IDBPromptInitialize> spDBInit;
 
-		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
+		HRESULT hr = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDBPromptInitialize, (void**) &spDBInit);
 		if (FAILED(hr))
 			return hr;
 
 		CComPtr<IDBProperties> spIDBProperties;
 		hr = spDBInit->PromptDataSource(NULL, hWnd, dwPromptOptions, 0, NULL, NULL,
-			__uuidof(IDBProperties), (IUnknown**)&spIDBProperties);
+			IID_IDBProperties, (IUnknown**)&spIDBProperties);
 
 		if (hr == S_OK)
 		{
-			hr = spIDBProperties->QueryInterface(&m_spInit);
+			hr = spIDBProperties->QueryInterface(IID_IDBProperties, (void**)&m_spInit);
 			if (SUCCEEDED(hr))
 				hr = m_spInit->Initialize();
 		}
@@ -6459,14 +6458,14 @@ public:
 	{
 		CComPtr<IDataInitialize> spDataInit;
 
-		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDataInitialize), (void**)&spDataInit);
+		HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDataInitialize, (void**)&spDataInit);
 		if (FAILED(hr))
 			return hr;
 
 		m_spInit.Release();
 		hr = spDataInit->CreateDBInstance(clsid, NULL, CLSCTX_INPROC_SERVER, NULL,
-			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
+			IID_IDBInitialize, (IUnknown**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
 
@@ -6496,8 +6495,8 @@ public:
 	{
 		CComPtr<IDBPromptInitialize> spDBInit;
 
-		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
+		HRESULT hr = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDBPromptInitialize, (void**) &spDBInit);
 		if (FAILED(hr))
 		{
 			return hr;
@@ -6525,8 +6524,8 @@ public:
 		CComPtr<IDataInitialize> spDataInit;
 		CComHeapPtr<OLECHAR>     spszInitString;
 
-		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDataInitialize), (void**)&spDataInit);
+		HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDataInitialize, (void**)&spDataInit);
 		if (FAILED(hr))
 			return hr;
 
@@ -6543,20 +6542,20 @@ public:
 	{
 		CComPtr<IDataInitialize> spDataInit;
 
-		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDataInitialize), (void**)&spDataInit);
+		HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDataInitialize, (void**)&spDataInit);
 		if (FAILED(hr))
 			return hr;
 
 		hr = spDataInit->GetDataSource(NULL, CLSCTX_INPROC_SERVER, szInitializationString,
-			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
+			IID_IDBInitialize, (IUnknown**)&m_spInit);
 		if (FAILED(hr))
 			return hr;
 
 		if( fPromptForInfo )
 		{
 			CComPtr<IDBProperties> spIDBProperties;
-			hr = m_spInit->QueryInterface( &spIDBProperties );
+			hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spIDBProperties);
 
 			DBPROP rgProperties[1];
 			DBPROPSET rgPropertySets[1];
@@ -6591,8 +6590,8 @@ ATLPREFAST_SUPPRESS(6387)
 		CComPtr<IDataInitialize> spDataInit;
 		LPOLESTR    szInitString;
 
-		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
-			__uuidof(IDataInitialize), (void**)&spDataInit);
+		HRESULT hr = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER,
+			IID_IDataInitialize, (void**)&spDataInit);
 		if (FAILED(hr))
 			return hr;
 
@@ -6621,7 +6620,7 @@ ATLPREFAST_UNSUPPRESS()
 		// Check that we are connected
 		ATLASSUME(m_spInit != NULL);
 
-		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
+		HRESULT hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
 		if (FAILED(hr))
 			return hr;
 
@@ -6641,7 +6640,7 @@ ATLPREFAST_UNSUPPRESS()
 		// Check that we are connected
 		ATLASSUME(m_spInit != NULL);
 
-		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
+		HRESULT hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
 		if (FAILED(hr))
 			return hr;
 
@@ -6676,7 +6675,7 @@ ATLPREFAST_UNSUPPRESS()
 		CComPtr<IPersist> spPersist;
 		CLSID   clsid;
 
-		HRESULT hr = pIDBProperties->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
+		HRESULT hr = pIDBProperties->QueryInterface(IID_IPersist, (void**)&spPersist);
 		if (FAILED(hr))
 			return hr;
 
@@ -6706,7 +6705,7 @@ ATLPREFAST_UNSUPPRESS()
 		ATLASSUME(m_spInit != NULL);
 		CComPtr<IDBProperties>  spProperties;
 
-		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
+		HRESULT hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
 		if (FAILED(hr))
 			return hr;
 
@@ -6765,7 +6764,7 @@ ATLPREFAST_UNSUPPRESS()
 			CComPtr<IDBProperties>  spProperties;
 			HRESULT                 hr;
 
-			hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
+			hr = m_spInit->QueryInterface(IID_IDBProperties, (void**)&spProperties);
 			if (FAILED(hr))
 				return hr;
 
@@ -6804,11 +6803,11 @@ public:
 		// Check we have connected to the database
 		ATLASSERT(ds.m_spInit != NULL);
 
-		HRESULT hr = ds.m_spInit->QueryInterface(__uuidof(IDBCreateSession), (void**)&spSession);
+		HRESULT hr = ds.m_spInit->QueryInterface(IID_IDBCreateSession, (void**)&spSession);
 		if (FAILED(hr))
 			return hr;
 
-		hr = spSession->CreateSession(NULL, __uuidof(IOpenRowset), (IUnknown**)&m_spOpenRowset);
+		hr = spSession->CreateSession(NULL, IID_IOpenRowset, (IUnknown**)&m_spOpenRowset);
 
 		if( pPropSet != NULL && SUCCEEDED(hr) && m_spOpenRowset != NULL )
 		{
@@ -6817,7 +6816,7 @@ public:
 				ulPropSets = 1;
 
 			CComPtr<ISessionProperties> spSessionProperties;
-			hr = m_spOpenRowset->QueryInterface(__uuidof(ISessionProperties), (void**)&spSessionProperties);
+			hr = m_spOpenRowset->QueryInterface(IID_ISessionProperties, (void**)&spSessionProperties);
 			if(FAILED(hr))
 				return hr;
 
@@ -6840,7 +6839,7 @@ public:
 	{
 		ATLASSUME(m_spOpenRowset != NULL);
 		CComPtr<ITransactionLocal> spTransactionLocal;
-		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransactionLocal);
+		HRESULT hr = m_spOpenRowset->QueryInterface(IID_ITransactionLocal, (void**)&spTransactionLocal);
 
 		if (SUCCEEDED(hr))
 			hr = spTransactionLocal->StartTransaction(isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);
@@ -6855,7 +6854,7 @@ public:
 	{
 		ATLASSUME(m_spOpenRowset != NULL);
 		CComPtr<ITransaction> spTransaction;
-		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);
+		HRESULT hr = m_spOpenRowset->QueryInterface(IID_ITransaction, (void**)&spTransaction);
 
 		if (SUCCEEDED(hr))
 			hr = spTransaction->Abort(pboidReason, bRetaining, bAsync);
@@ -6870,7 +6869,7 @@ public:
 	{
 		ATLASSUME(m_spOpenRowset != NULL);
 		CComPtr<ITransaction> spTransaction;
-		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);
+		HRESULT hr = m_spOpenRowset->QueryInterface(IID_ITransaction, (void**)&spTransaction);
 
 		if (SUCCEEDED(hr))
 			hr = spTransaction->Commit(bRetaining, grfTC, grfRM);
@@ -6882,7 +6881,7 @@ public:
 	{
 		ATLASSUME(m_spOpenRowset != NULL);
 		CComPtr<ITransaction> spTransaction;
-		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);
+		HRESULT hr = m_spOpenRowset->QueryInterface(IID_ITransaction, (void**)&spTransaction);
 
 		if (SUCCEEDED(hr))
 			hr = spTransaction->GetTransactionInfo(pInfo);
@@ -7023,15 +7022,15 @@ public:
 		if (pPropSet != NULL && ulPropSets == 0)
 			ulPropSets = 1;
 
-		HRESULT hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, GetIID(),
-			ulPropSets, pPropSet, (IUnknown**)GetInterfacePtr());
+		HRESULT hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, this->GetIID(),
+			ulPropSets, pPropSet, (IUnknown**)this->GetInterfacePtr());
 		if (SUCCEEDED(hr))
 		{
-			SetupOptionalRowsetInterfaces();
+			this->SetupOptionalRowsetInterfaces();
 
 			// If we have output columns then bind
 			if (_OutputColumnsClass::HasOutputColumns())
-				hr = Bind();
+				hr = this->Bind();
 		}
 
 		return hr;
@@ -7069,17 +7068,17 @@ public:
 
 		CComPtr<IDBCreateCommand> spCreateCommand;
 
-		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBCreateCommand), (void**)&spCreateCommand);
+		HRESULT hr = session.m_spOpenRowset->QueryInterface(IID_IDBCreateCommand, (void**)&spCreateCommand);
 		if (FAILED(hr))
 			return hr;
 
-		return spCreateCommand->CreateCommand(NULL, __uuidof(ICommand), (IUnknown**)&m_spCommand);
+		return spCreateCommand->CreateCommand(NULL, IID_ICommand, (IUnknown**)&m_spCommand);
 	}
 	// Prepare the command
 	HRESULT Prepare(_In_ ULONG cExpectedRuns = 0) throw()
 	{
 		CComPtr<ICommandPrepare> spCommandPrepare;
-		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
+		HRESULT hr = m_spCommand->QueryInterface(IID_ICommandPrepare, (void**)&spCommandPrepare);
 		if (SUCCEEDED(hr))
 			hr = spCommandPrepare->Prepare(cExpectedRuns);
 
@@ -7089,7 +7088,7 @@ public:
 	HRESULT Unprepare() throw()
 	{
 		CComPtr<ICommandPrepare> spCommandPrepare;
-		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
+		HRESULT hr = m_spCommand->QueryInterface(IID_ICommandPrepare, (void**)&spCommandPrepare);
 		if (SUCCEEDED(hr))
 			hr = spCommandPrepare->Unprepare();
 
@@ -7107,7 +7106,7 @@ public:
 		if (SUCCEEDED(hr))
 		{
 			CComPtr<ICommandText> spCommandText;
-			hr = m_spCommand->QueryInterface(&spCommandText);
+			hr = m_spCommand->QueryInterface(IID_ICommandText, (void**)&spCommandText);
 			if (SUCCEEDED(hr))
 				hr = spCommandText->SetCommandText(guidCommand, wszCommand);
 		}
@@ -7128,7 +7127,7 @@ public:
 		if (m_hParameterAccessor != 0 && m_spCommand != NULL )
 		{
 			CComPtr<IAccessor> spAccessor;
-			HRESULT hr = m_spCommand->QueryInterface(&spAccessor);
+			HRESULT hr = m_spCommand->QueryInterface(IID_IAccessor, (void**)&spAccessor);
 			if (SUCCEEDED(hr))
 			{
 				spAccessor->ReleaseAccessor(m_hParameterAccessor, NULL);
@@ -7144,7 +7143,7 @@ public:
 		_Out_cap_x_(*pParams) _Deref_post_z_ OLECHAR** ppNamesBuffer) throw()
 	{
 		CComPtr<ICommandWithParameters> spCommandParameters;
-		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
+		HRESULT hr = m_spCommand->QueryInterface(IID_ICommandWithParameters, (void**)&spCommandParameters);
 		if (SUCCEEDED(hr))
 		{
 			// Get the parameter information
@@ -7160,7 +7159,7 @@ public:
 		_In_opt_count_(ulParams) const DBPARAMBINDINFO* pParamInfo) throw()
 	{
 		CComPtr<ICommandWithParameters> spCommandParameters;
-		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
+		HRESULT hr = m_spCommand->QueryInterface(IID_ICommandWithParameters, (void**)&spCommandParameters);
 		if (SUCCEEDED(hr))
 		{
 			// Set the parameter information
@@ -7301,7 +7300,7 @@ public:
 		if (_ParamClass::HasParameters())
 		{
 			// Bind the parameters in the accessor if they haven't already been bound
-			hr = BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
+			hr = this->BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
 			if (FAILED(hr))
 				return hr;
 
@@ -7326,19 +7325,19 @@ public:
 
 		// If user calls GetNextResult but the interface is not available
 		// return E_FAIL.
-		if (GetMultiplePtr() == NULL)
+		if (this->GetMultiplePtr() == NULL)
 			return E_FAIL;
 
 		// Close the existing rowset in preparation for opening the next one
-		Close();
+		this->Close();
 
-		HRESULT hr = GetMultiplePtr()->GetResult(NULL, 0, GetIID(),
-			pulRowsAffected, (IUnknown**)GetInterfacePtr());
+		HRESULT hr = this->GetMultiplePtr()->GetResult(NULL, 0, this->GetIID(),
+			pulRowsAffected, (IUnknown**)this->GetInterfacePtr());
 		if (FAILED(hr))
 			return hr;
 
-		if (bBind && GetInterface() != NULL)
-			return Bind();
+		if (bBind && this->GetInterface() != NULL)
+			return this->Bind();
 		else
 			return hr;
 	}
@@ -7351,7 +7350,7 @@ public:
 		_In_ bool bBind = true,
 		_In_ ULONG ulPropSets = 0) throw()
 	{
-		HRESULT hr = Execute((IUnknown**)GetInterfacePtr(), pParams, pPropSet,
+		HRESULT hr = Execute((IUnknown**)this->GetInterfacePtr(), pParams, pPropSet,
 							pRowsAffected, ulPropSets);
 		if (FAILED(hr))
 			return hr;
@@ -7360,10 +7359,10 @@ public:
 		if (bBind && _OutputColumnsClass::HasOutputColumns())
 		{
 			// for dynamic accessors we don't want to automatically call Bind if we got no rowset in return
-			if( NoBindOnNullRowset() && GetInterface() == NULL )
+			if( this->NoBindOnNullRowset() && this->GetInterface() == NULL )
 				return hr;
 			else
-				return Bind();
+				return this->Bind();
 		}
 		else
 			return hr;
@@ -7397,7 +7396,7 @@ public:
 				ulPropSets = 1;
 
 			CComPtr<ICommandProperties> spCommandProperties;
-			hr = m_spCommand->QueryInterface(&spCommandProperties);
+			hr = m_spCommand->QueryInterface(IID_ICommandProperties, (void**)&spCommandProperties);
 			if (FAILED(hr))
 				return hr;
 
@@ -7414,25 +7413,25 @@ public:
 		else
 			pAffected = &nAffected;
 
-		if (UseMultipleResults())
+		if (this->UseMultipleResults())
 		{
-			hr = m_spCommand->Execute(NULL, __uuidof(IMultipleResults), pParams,
-				pAffected, (IUnknown**)GetMultiplePtrAddress());
+			hr = m_spCommand->Execute(NULL, IID_IMultipleResults, pParams,
+				pAffected, (IUnknown**)this->GetMultiplePtrAddress());
 
 			if (SUCCEEDED(hr))
 				hr = GetNextResult(pAffected, false);
 			else
 				// If we can't get IMultipleResults then just try to get IRowset
-				hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
+				hr = m_spCommand->Execute(NULL, this->GetIID(), pParams, pAffected,
 					ppInterface);
 		}
 		else
 		{
-			hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
+			hr = m_spCommand->Execute(NULL, this->GetIID(), pParams, pAffected,
 				ppInterface);
 		}
 		if (SUCCEEDED(hr))
-			SetupOptionalRowsetInterfaces();
+			this->SetupOptionalRowsetInterfaces();
 
 		return hr;
 	}
diff --git a/include/atldbsch.h b/include/atldbsch.h
index a173bb9..1836d07 100644
--- a/include/atldbsch.h
+++ b/include/atldbsch.h
@@ -45,12 +45,12 @@ ATLPREFAST_SUPPRESS(6387)
 		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);
 		CComPtr<IDBSchemaRowset> spSchemaRowset;
 
-		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
+		HRESULT hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset, (void**)&spSchemaRowset);
 		if (FAILED(hr))
 			return hr;
 
 		return spSchemaRowset->GetRowset(NULL, guidSchema, nRestrictions,
-			m_pvarRestrictions, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
+			m_pvarRestrictions, IID_IRowset, 0, NULL, (IUnknown**)ppRowset);
 	}
 ATLPREFAST_UNSUPPRESS()
 	
@@ -70,12 +70,12 @@ ATLPREFAST_SUPPRESS(6387)
 		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);
 		CComPtr<IDBSchemaRowset> spSchemaRowset;
 
-		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
+		HRESULT hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset, (void**)&spSchemaRowset);
 		if (FAILED(hr))
 			return hr;
 		
 		return spSchemaRowset->GetRowset(NULL, guidSchema, 0,
-			NULL, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
+			NULL, IID_IRowset, 0, NULL, (IUnknown**)ppRowset);
 	}
 ATLPREFAST_UNSUPPRESS()
 };
@@ -222,7 +222,7 @@ public:
 
 		ATLENSURE_RETURN(session.m_spOpenRowset != NULL);
 
-		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset),
+		hr = session.m_spOpenRowset->QueryInterface(IID_IDBSchemaRowset,
 			(void**)&spSchemaRowset);
 		if (FAILED(hr))
 			return hr;
diff --git a/include/atldef.h b/include/atldef.h
index f0a4351..391fe8c 100644
--- a/include/atldef.h
+++ b/include/atldef.h
@@ -52,10 +52,12 @@ namespace Inconsistent_definition_of_symbol__ATL_MIXED
 #else
 namespace Inconsistent_definition_of_symbol__ATL_MIXED
 {
+#ifdef _MSC_VER
 #ifdef _M_IX86
 #pragma comment(linker, "/include:??3@YAXPAX@Z")
 #else
 #pragma comment(linker, "/include:??3@YAXPEAX@Z")
+#endif
 #endif
 	struct _Please_define_it_the_same_throughout_your_project { virtual void one(){} };
 }
@@ -71,10 +73,12 @@ namespace Define_the_symbol__ATL_MIXED
 #if defined(_M_CEE)
 	struct Thank_you { };
 #else
+#ifdef _MSC_VER
 #ifdef _M_IX86
 #pragma comment(linker, "/include:??3@YAXPAX@Z")
 #else
 #pragma comment(linker, "/include:??3@YAXPEAX@Z")
+#endif
 #endif
 	struct Thank_you { virtual void one(){} };
 #endif
@@ -141,12 +145,104 @@ char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOf
 #endif
 #endif
 
+#ifdef _MSC_VER
+
 #ifndef AtlThrow
 #ifndef _ATL_CUSTOM_THROW
 #define AtlThrow ATL::AtlThrowImpl
 #endif
 #endif // AtlThrow
 
+#else
+
+#undef WINVER
+#define WINVER		0x0601
+#undef _WIN32_WINNT
+#define _WIN32_WINNT	0x0601
+#undef _WIN32_IE
+#define _WIN32_IE	0x0601
+
+#define _Deref_inout_z_
+#define _Deref_opt_out_
+#define _Deref_opt_out_z_
+#define _Deref_out_
+#define _Deref_out_opt_
+#define _Deref_out_opt_z_
+#define _Deref_out_z_
+#define _Deref_post_cap_(size)
+#define _Deref_post_maybenull_
+#define _Deref_post_opt_bytecount_c_(size)
+#define _Deref_post_opt_cap_(size)
+#define _Deref_post_opt_valid_
+#define _Deref_post_opt_z_
+#define _Deref_post_valid_
+#define _Deref_post_z_
+#define _Deref_post_z_cap_(cap)
+#define _Deref_pre_maybenull_
+#define _Deref_pre_opt_valid_
+#define _Deref_pre_valid_
+#define _Deref_pre_z_
+
+#define _Post_z_
+#define _Post_z_count_(size)
+#define _Post_bytecount_c_(size)
+#define _Pre_notnull_
+#define _Prepost_bytecount_x_(size)
+#define _Printf_format_string_
+
+#define _Ret_cap_(size)
+#define _Ret_count_x_(size)
+#define _Ret_opt_bytecap_(size)
+#define _Ret_opt_count_(size)
+#define _Ret_opt_z_
+#define _Ret_opt_z_cap_(size)
+#define _Ret_z_
+
+#define __deref
+#define __deref_inout_opt
+#define __deref_opt_out
+#define __deref_opt_out_opt
+#define __deref_out
+#define __format_string
+#define __in_opt
+#define __interface interface
+#define __leave return 0
+#define __noop
+#define __nullterminated
+#define __out_bcount_part(size,length)
+#define __out_bcount_part_z(size,length)
+#define __out_ecount_part(size,length)
+#define __out_ecount_part_z(size,length)
+#define __out_ecount_part_z_opt(size,length)
+#define __out_opt
+#define __post
+#define __reserved
+#define __success(expr)
+#define __unaligned
+
+#ifndef __try
+#define __try try
+#endif
+#ifndef __except
+#define __except(x) catch(...)
+#endif
+#ifndef __finally
+#define __finally catch(...)
+#endif
+
+#define _CPPUNWIND
+#define _ATL_NO_UUIDOF
+#define _ATL_DISABLE_DEPRECATED
+#define _ATL_DISABLE_NO_VTABLE
+#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
+
+#ifdef _DEBUG
+#define _ATL_NO_DEBUG_CRT
+#include <crtdbg.h>
+#endif
+
+#endif
+
 #ifndef ATLASSERT
 #define ATLASSERT(expr) _ASSERTE(expr)
 #endif // ATLASSERT
@@ -309,19 +405,31 @@ do { \
 #ifdef _ATL_DISABLE_NOTHROW
 #define ATL_NOTHROW
 #else
+#ifdef _MSC_VER
 #define ATL_NOTHROW __declspec(nothrow)
+#else
+#define ATL_NOTHROW __attribute__((nothrow))
+#endif
 #endif
 
 #ifdef _ATL_DISABLE_FORCEINLINE
 #define ATL_FORCEINLINE
 #else
+#ifdef _MSC_VER
 #define ATL_FORCEINLINE __forceinline
+#else
+#define ATL_FORCEINLINE __attribute__((always_inline))
+#endif
 #endif
 
 #ifdef _ATL_DISABLE_NOINLINE
 #define ATL_NOINLINE
 #else
+#ifdef _MSC_VER
 #define ATL_NOINLINE __declspec( noinline )
+#else
+#define ATL_NOINLINE __attribute__((noinline))
+#endif
 #endif
 
 #ifdef _ATL_DISABLE_DEPRECATED
@@ -385,8 +493,8 @@ do { \
 	#define ATLAPIINL_(x) ATLAPI_(x)
 	#define ATLINLINE
 #else
-	#define ATLAPI __declspec(nothrow) HRESULT __stdcall
-	#define ATLAPI_(x) __declspec(nothrow) x __stdcall
+	#define ATLAPI ATL_NOTHROW HRESULT __stdcall
+	#define ATLAPI_(x) ATL_NOTHROW x __stdcall
 	#define ATLAPIINL ATLAPI
 	#define ATLAPIINL_(x) ATLAPI_(x)
 	#define ATLINLINE inline
@@ -410,7 +518,7 @@ do { \
 #define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
 #else
 /* prefast noise VSW 489981 */
-#define ATLTRYALLOC(x) __pragma(warning(push)) __pragma(warning(disable: 4571)) try{x;} catch(...) {} __pragma(warning(pop))
+#define ATLTRYALLOC(x) try{x;} catch(...) {}
 #endif	//__AFX
 
 #endif	//ATLTRYALLOC
@@ -673,8 +781,8 @@ that we consider it dangerous to even throw an exception
 #define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
 #endif
 
-#define ATLPREFAST_SUPPRESS(x) __pragma(warning(push)) __pragma(warning(disable: x))
-#define ATLPREFAST_UNSUPPRESS() __pragma(warning(pop))
+#define ATLPREFAST_SUPPRESS(x)
+#define ATLPREFAST_UNSUPPRESS()
 	
 #ifndef _FormatMessage_format_string_
 #define _FormatMessage_format_string_
@@ -686,7 +794,11 @@ that we consider it dangerous to even throw an exception
 namespace ATL {
 
 template < typename T >
+#ifdef _MSC_VER
 _Ret_opt_bytecap_(dwLen) inline __declspec(noalias) T* SAL_Assume_bytecap_for_opt_(
+#else
+inline T* SAL_Assume_bytecap_for_opt_(
+#endif
 	_Out_opt_cap_c_(0) T* buf, 
 	_In_ size_t dwLen)
 {
@@ -695,7 +807,11 @@ _Ret_opt_bytecap_(dwLen) inline __declspec(noalias) T* SAL_Assume_bytecap_for_op
 }
 
 template < typename T >
+#ifdef _MSC_VER
 _Ret_z_ inline __declspec(noalias) T* SAL_Assume_notnull_for_opt_z_(_In_opt_z_ T* buf)
+#else
+inline T* SAL_Assume_notnull_for_opt_z_(_In_opt_z_ T* buf)
+#endif
 {
 	ATLASSUME(buf!=0);
 	return buf;
diff --git a/include/atlenc.h b/include/atlenc.h
index eaa7651..4e4278e 100644
--- a/include/atlenc.h
+++ b/include/atlenc.h
@@ -718,7 +718,7 @@ inline BOOL QPDecode(
 				szBuf[0] = *pbSrcData++;
 				szBuf[1] = *pbSrcData++;
 				szBuf[2] = '\0';
-				char* tmp = '\0';
+				char* tmp = _TEXT('\0');
 				ATLENSURE(szDest < szDestEnd);
 				*szDest++ = (BYTE)strtoul(szBuf, &tmp, 16);
 				nWritten++;
diff --git a/include/atlevent.h b/include/atlevent.h
index df0cdb4..0408d95 100644
--- a/include/atlevent.h
+++ b/include/atlevent.h
@@ -195,7 +195,7 @@ namespace ATL {
 			::VariantInit(pVarResult);
 		}
 		EXCEPINFO excepInfo;
-		memset(&excepInfo, 0, sizeof excepInfo);
+		memset(&excepInfo, 0, sizeof(excepInfo));
 		UINT nArgErr = (UINT)-1;
 		HRESULT hr = pDispatch->Invoke(id, IID_NULL, LOCALE_USER_DEFAULT, wFlags, pDispParams, pVarResult, &excepInfo, &nArgErr);
 		if (FAILED(hr)) {
diff --git a/include/atlexcept.h b/include/atlexcept.h
index 19ce88b..2e2398c 100644
--- a/include/atlexcept.h
+++ b/include/atlexcept.h
@@ -13,8 +13,17 @@
 
 #pragma once
 
+#ifndef AtlThrow
+#define ATLTRACE
+#define ATLTRACE2
+#ifndef _ATL_CUSTOM_THROW
+#define AtlThrow ATL::AtlThrowImpl
+#endif
+const DWORD_PTR atlTraceException = 0;
+#else
 #include <atldef.h>
 #include <atltrace.h>
+#endif
 
 
 #pragma pack(push,_ATL_PACKING)
@@ -63,7 +72,7 @@ public:
 #else
 ATL_NOINLINE __declspec(noreturn) inline void WINAPI AtlThrowImpl(_In_ HRESULT hr)
 {
-	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
+	ATLTRACE(atlTraceException, 0, LPTSTR ("AtlThrow: hr = 0x%x\n"), hr );
 #ifdef _AFX
 	if( hr == E_OUTOFMEMORY )
 	{
diff --git a/include/atlhandlerimpl.h b/include/atlhandlerimpl.h
index 462d635..ac3fbd8 100644
--- a/include/atlhandlerimpl.h
+++ b/include/atlhandlerimpl.h
@@ -157,6 +157,9 @@ class ATL_NO_VTABLE CPreviewHandlerImpl :
 	public IInitializeWithStream,
 	public IPreviewHandlerVisuals
 {
+private:
+	typedef IObjectWithSiteImpl<T> __super;
+
 public:
 	CPreviewHandlerImpl(void) :
 		m_pPreviewCtrl(NULL), m_pStream(NULL),
@@ -406,7 +409,7 @@ public:
 		// Get the new frame
 		if (m_spUnkSite)
 		{
-			m_spUnkSite->QueryInterface(&m_pFrame);
+			m_spUnkSite->QueryInterface(IID_IPreviewHandlerFrame, (void**) &m_pFrame);
 		}
 
 		return S_OK;
diff --git a/include/atlhost.h b/include/atlhost.h
index 0294100..8a5eb00 100644
--- a/include/atlhost.h
+++ b/include/atlhost.h
@@ -21,7 +21,9 @@
 #endif //!_ATL_NO_PRAGMA_WARNINGS
 
 #include <urlmon.h>
+#include <initguid.h>
 #include <mshtml.h>
+#undef INITGUID
 #include <mshtmhst.h>
 #include <exdisp.h>
 
@@ -101,14 +103,14 @@ static HRESULT CreateNormalizedObject(
 		(lpszTricsData[6] == OLECHAR(':')))
 	{
 		// It's HTML, so let's create mshtml
-		hr = CoCreateInstance(__uuidof(HTMLDocument), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
+		hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
 		bWasHTML = true;
 	}
 	// Is it a URL?
 	else if (CAtlModule::FindOneOf(COLE2CT(lpszTricsData), _T(":")))
 	{
 		// URL so let's create shdocvw
-		hr = CoCreateInstance(__uuidof(WebBrowser), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
+		hr = CoCreateInstance(CLSID_WebBrowser, NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
 		bWasHTML = true;
 	}
 	// assume ProgID or CLSID
@@ -133,7 +135,7 @@ static HRESULT CreateNormalizedObject(
             if (::SysStringLen(bstrLicKey) != 0)
 			{
 				CComPtr<IClassFactory2> spClassFactory;
-				hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, __uuidof(IClassFactory2), (void**)&spClassFactory);
+				hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory2, (void**)&spClassFactory);
 				if (SUCCEEDED(hr))
 				{
 					hr = spClassFactory->CreateInstanceLic(NULL, NULL, riid, bstrLicKey, ppvObj);
@@ -346,7 +348,7 @@ class ATL_NO_VTABLE CAxHostWindow :
 #ifndef _ATL_NO_DOCHOSTUIHANDLER
 		public IDocHostUIHandler,
 #endif
-		public IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>
+		public IDispatchImpl<IAxWinAmbientDispatchEx, &IID_IAxWinAmbientDispatchEx, &CAtlModule::m_libid, 0xFFFF, 0xFFFF>
 {
 public:
 // ctor/dtor
@@ -500,7 +502,7 @@ public:
 	{
 		ATLASSUME(lParam != 0);
 		LPMSG lpMsg = (LPMSG)lParam;
-		CComQIPtr<IOleInPlaceActiveObject, &__uuidof(IOleInPlaceActiveObject)> spInPlaceActiveObject(m_spUnknown);
+		CComQIPtr<IOleInPlaceActiveObject, &IID_IOleInPlaceActiveObject> spInPlaceActiveObject(m_spUnknown);
 		if(spInPlaceActiveObject)
 		{
 			if(spInPlaceActiveObject->TranslateAccelerator(lpMsg) == S_OK)
@@ -556,7 +558,7 @@ public:
 		if (m_spUnknown != NULL)
 		{
 			CComPtr<IObjectWithSite> spSite;
-			m_spUnknown->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
+			m_spUnknown->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
 			if (spSite != NULL)
 				spSite->SetSite(NULL);
 		}
@@ -610,7 +612,7 @@ public:
 			if (m_spOleObject != NULL && !m_bInPlaceActive)
 			{
 				CComPtr<IOleClientSite> spClientSite;
-				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
+				GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
 				if (spClientSite != NULL)
 					m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
 			}
@@ -634,7 +636,7 @@ public:
 			if (m_spOleObject != NULL && !m_bUIActive)
 			{
 				CComPtr<IOleClientSite> spClientSite;
-				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
+				GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
 				if (spClientSite != NULL)
 					m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
 			}
@@ -794,7 +796,7 @@ public:
 		_Inout_opt_ IStream* pStream)
 	{
 		CComPtr<IUnknown> p;
-		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, NULL);
+		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_IUnknown, NULL, NULL);
 	}
 	STDMETHOD(CreateControlEx)(
 		_In_z_ LPCOLESTR lpszTricsData,
@@ -891,7 +893,7 @@ ATLPREFAST_SUPPRESS(6387)
 		_In_opt_z_ BSTR bstrLic)
 	{
 		CComPtr<IUnknown> p;
-		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, bstrLic);
+		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_IUnknown, NULL, bstrLic);
 	}
 
 	_Success_(return == S_OK) STDMETHOD(CreateControlLicEx)(
@@ -939,7 +941,7 @@ ATLPREFAST_SUPPRESS(6387)
 
 			bool bWasHTML = false;
 
-			hr = CreateNormalizedObject(lpszTricsData, __uuidof(IUnknown), (void**)ppUnk, bWasHTML, bstrLic);
+			hr = CreateNormalizedObject(lpszTricsData, IID_IUnknown, (void**)ppUnk, bWasHTML, bstrLic);
 
 			if (SUCCEEDED(hr))
 			{			
@@ -989,7 +991,7 @@ ATLPREFAST_SUPPRESS(6387)
 						if (SUCCEEDED(hr))
 						{
 							CComPtr<IPersistStreamInit> spPSI;
-							hr = spUnk->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spPSI);
+							hr = spUnk->QueryInterface(IID_IPersistStreamInit, (void**)&spPSI);
 							if (SUCCEEDED(hr))
 							{
 								hr = spPSI->Load(spStream);
@@ -1004,7 +1006,7 @@ ATLPREFAST_SUPPRESS(6387)
 				else
 				{
 					CComPtr<IWebBrowser2> spBrowser;
-					spUnk->QueryInterface(__uuidof(IWebBrowser2), (void**)&spBrowser);
+					spUnk->QueryInterface(IID_IWebBrowser2, (void**)&spBrowser);
 					if (spBrowser)
 					{
 						CComVariant ve;
@@ -1215,7 +1217,7 @@ ATLPREFAST_SUPPRESS(6387)
 			hr = m_spIDocHostUIHandlerDispatch->GetDropTarget(pDropTarget, &spUnk);
 			if (SUCCEEDED(hr) && spUnk)
 			{
-				hr = spUnk->QueryInterface(__uuidof(IDropTarget), (void**)ppDropTarget);
+				hr = spUnk->QueryInterface(IID_IDropTarget, (void**)ppDropTarget);
 				if (FAILED(hr) || *ppDropTarget == NULL)
 					hr = E_NOTIMPL;
 			}
@@ -1306,7 +1308,7 @@ ATLPREFAST_UNSUPPRESS()
 			CComPtr<IUnknown> spUnk;
 			hr = m_spIDocHostUIHandlerDispatch->FilterDataObject(pDO, &spUnk);
 			if (spUnk)
-				hr = QueryInterface(__uuidof(IDataObject), (void**)ppDORet);
+				hr = QueryInterface(IID_IDataObject, (void**)ppDORet);
 			if (FAILED(hr) || *ppDORet == NULL)
 				hr = S_FALSE;
 		}
@@ -1317,7 +1319,7 @@ ATLPREFAST_UNSUPPRESS()
 	HRESULT FireAmbientPropertyChange(_In_ DISPID dispChanged)
 	{
 		HRESULT hr = S_OK;
-		CComQIPtr<IOleControl, &__uuidof(IOleControl)> spOleControl(m_spUnknown);
+		CComQIPtr<IOleControl, &IID_IOleControl> spOleControl(m_spUnknown);
 		if (spOleControl != NULL)
 			hr = spOleControl->OnAmbientPropertyChange(dispChanged);
 		return hr;
@@ -1336,7 +1338,7 @@ ATLPREFAST_UNSUPPRESS()
 		_Out_opt_ EXCEPINFO *pExcepInfo,
 		_Out_opt_ UINT *puArgErr)
 	{
-		HRESULT hr = IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>::Invoke
+		HRESULT hr = IDispatchImpl<IAxWinAmbientDispatchEx, &IID_IAxWinAmbientDispatchEx, &CAtlModule::m_libid, 0xFFFF, 0xFFFF>::Invoke
 			(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
 		if ((hr == DISP_E_MEMBERNOTFOUND || hr == TYPE_E_ELEMENTNOTFOUND) && m_spAmbientDispatch != NULL)
 		{
@@ -1496,7 +1498,7 @@ ATLPREFAST_UNSUPPRESS()
 			fd.cySize.Lo = lfHeight * 720000 / ppi;
 			fd.cySize.Hi = 0;
 
-			OleCreateFontIndirect(&fd, __uuidof(IFontDisp), (void**) &m_spFont);
+			OleCreateFontIndirect(&fd, IID_IFontDisp, (void**) &m_spFont);
 		}
 
 		return m_spFont.CopyTo(pFont);
@@ -1616,7 +1618,7 @@ ATLPREFAST_UNSUPPRESS()
 		if (SUCCEEDED(hr) && m_spUnkSite)
 		{
 			// Look for "outer" IServiceProvider
-			hr = m_spUnkSite->QueryInterface(__uuidof(IServiceProvider), (void**)&m_spServices);
+			hr = m_spUnkSite->QueryInterface(IID_IServiceProvider, (void**)&m_spServices);
 			ATLASSERT( SUCCEEDED(hr) && "No ServiceProvider!" );
 		}
 
@@ -1649,9 +1651,9 @@ ATLPREFAST_UNSUPPRESS()
 			hr = E_NOTIMPL;
 			(*ppContainer) = NULL;
 			if (m_spUnkSite)
-				hr = m_spUnkSite->QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
+				hr = m_spUnkSite->QueryInterface(IID_IOleContainer, (void**)ppContainer);
 			if (FAILED(hr))
-				hr = QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
+				hr = QueryInterface(IID_IOleContainer, (void**)ppContainer);
 		}
 		return hr;
 	}
@@ -1700,7 +1702,7 @@ ATLPREFAST_UNSUPPRESS()
 		m_bInPlaceActive = TRUE;
 		OleLockRunning(m_spOleObject, TRUE, FALSE);
 		m_bWindowless = FALSE;
-		m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
+		m_spOleObject->QueryInterface(IID_IOleInPlaceObject, (void**) &m_spInPlaceObjectWindowless);
 		return S_OK;
 	}
 	STDMETHOD(OnUIActivate)()
@@ -1737,7 +1739,7 @@ ATLPREFAST_SUPPRESS(6387)
 				return hRet;
 			}
 
-			pFrameWindow->QueryInterface(__uuidof(IOleInPlaceFrame), (void**) &m_spInPlaceFrame);
+			pFrameWindow->QueryInterface(IID_IOleInPlaceFrame, (void**) &m_spInPlaceFrame);
 			ATLASSUME(m_spInPlaceFrame);
 		}
 		if (!m_spInPlaceUIWindow)
@@ -1750,7 +1752,7 @@ ATLPREFAST_SUPPRESS(6387)
 				return hRet;
 			}		
 
-			pUIWindow->QueryInterface(__uuidof(IOleInPlaceUIWindow), (void**) &m_spInPlaceUIWindow);
+			pUIWindow->QueryInterface(IID_IOleInPlaceUIWindow, (void**) &m_spInPlaceUIWindow);
 			ATLASSUME(m_spInPlaceUIWindow);
 		}
 		HRESULT hr=S_OK;
@@ -1848,12 +1850,12 @@ ATLPREFAST_UNSUPPRESS()
 		if (dwFlags & ACTIVATE_WINDOWLESS)
 		{
 			m_bWindowless = TRUE;
-			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObjectWindowless), (void**) &m_spInPlaceObjectWindowless);
+			hr = m_spOleObject->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**) &m_spInPlaceObjectWindowless);
 		}
 		if (FAILED(hr))
 		{
 			m_bWindowless = FALSE;
-			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
+			hr = m_spOleObject->QueryInterface(IID_IOleInPlaceObject, (void**) &m_spInPlaceObjectWindowless);
 		}
 		if (m_spInPlaceObjectWindowless)
 			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
@@ -2085,7 +2087,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (ppenum == NULL)
 			return E_POINTER;
 		*ppenum = NULL;
-		typedef CComObject<CComEnum<IEnumUnknown, &__uuidof(IEnumUnknown), IUnknown*, _CopyInterface<IUnknown> > > enumunk;
+		typedef CComObject<CComEnum<IEnumUnknown, &IID_IEnumUnknown, IUnknown*, _CopyInterface<IUnknown> > > enumunk;
 		enumunk* p = NULL;
 
 ATLPREFAST_SUPPRESS(6014)
@@ -2099,7 +2101,7 @@ ATLPREFAST_UNSUPPRESS()
 		// There is always only one object.
 		HRESULT hRes = p->Init(reinterpret_cast<IUnknown**>(&pTemp), reinterpret_cast<IUnknown**>(&pTemp + 1), GetControllingUnknown(), AtlFlagCopy);
 		if (SUCCEEDED(hRes))
-			hRes = p->QueryInterface(__uuidof(IEnumUnknown), (void**)ppenum);
+			hRes = p->QueryInterface(IID_IEnumUnknown, (void**)ppenum);
 		if (FAILED(hRes))
 			delete p;
 		return hRes;
@@ -2123,19 +2125,19 @@ ATLPREFAST_UNSUPPRESS()
 		m_spUnknown = pUnkControl;
 
 		HRESULT hr = S_OK;
-		pUnkControl->QueryInterface(__uuidof(IOleObject), (void**)&m_spOleObject);
+		pUnkControl->QueryInterface(IID_IOleObject, (void**)&m_spOleObject);
 		if (m_spOleObject)
 		{
 			m_spOleObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
 			if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
 			{
-				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
+				CComQIPtr<IOleClientSite, &IID_IOleClientSite> spClientSite(GetControllingUnknown());
 				m_spOleObject->SetClientSite(spClientSite);
 			}
 
 			if (!bInited) // If user hasn't initialized the control, initialize/load using IPersistStreamInit or IPersistStream
 			{
-				CComQIPtr<IPersistStreamInit> spPSI(m_spOleObject);
+				CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> spPSI(m_spOleObject);
 				if (spPSI)
 				{
 					if (pStream)
@@ -2145,7 +2147,7 @@ ATLPREFAST_UNSUPPRESS()
 				}
 				else if (pStream)
 				{
-					CComQIPtr<IPersistStream> spPS(m_spOleObject);
+					CComQIPtr<IPersistStream, &IID_IPersistStream> spPS(m_spOleObject);
 					if (spPS)
 						hr = spPS->Load(pStream);
 				}
@@ -2166,15 +2168,15 @@ ATLPREFAST_UNSUPPRESS()
 
 			if (0 == (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
 			{
-				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
+				CComQIPtr<IOleClientSite, &IID_IOleClientSite> spClientSite(GetControllingUnknown());
 				m_spOleObject->SetClientSite(spClientSite);
 			}
 
 			m_dwViewObjectType = 0;
-			hr = m_spOleObject->QueryInterface(__uuidof(IViewObjectEx), (void**) &m_spViewObject);
+			hr = m_spOleObject->QueryInterface(IID_IViewObjectEx, (void**) &m_spViewObject);
 			if (FAILED(hr))
 			{
-				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject2), (void**) &m_spViewObject);
+				hr = m_spOleObject->QueryInterface(IID_IViewObject2, (void**) &m_spViewObject);
 				if (SUCCEEDED(hr))
 					m_dwViewObjectType = 3;
 			} else
@@ -2182,11 +2184,11 @@ ATLPREFAST_UNSUPPRESS()
 
 			if (FAILED(hr))
 			{
-				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject), (void**) &m_spViewObject);
+				hr = m_spOleObject->QueryInterface(IID_IViewObject, (void**) &m_spViewObject);
 				if (SUCCEEDED(hr))
 					m_dwViewObjectType = 1;
 			}
-			CComQIPtr<IAdviseSink> spAdviseSink(GetControllingUnknown());
+			CComQIPtr<IAdviseSink, &IID_IAdviseSink> spAdviseSink(GetControllingUnknown());
 			m_spOleObject->Advise(spAdviseSink, &m_dwOleObject);
 			if (m_spViewObject)
 				m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, spAdviseSink);
@@ -2204,13 +2206,13 @@ ATLPREFAST_UNSUPPRESS()
 				m_rcPos.right = m_rcPos.left + m_pxSize.cx;
 				m_rcPos.bottom = m_rcPos.top + m_pxSize.cy;
 
-				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
+				CComQIPtr<IOleClientSite, &IID_IOleClientSite> spClientSite(GetControllingUnknown());
 				hr = m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
 				RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
 			}
 		}
 		CComPtr<IObjectWithSite> spSite;
-		pUnkControl->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
+		pUnkControl->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
 		if (spSite != NULL)
 			spSite->SetSite(GetControllingUnknown());
 
@@ -2466,7 +2468,7 @@ static LRESULT CALLBACK AtlAxWindowProc(
 #endif
 				return -1;	// abort window creation
 			}
-			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
+			hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
 			if(FAILED(hRet))
 				return -1;	// abort window creation
 
@@ -2586,7 +2588,7 @@ static LRESULT CALLBACK AtlAxWindowProc2(
 #endif
 				return -1;	// abort window creation
 			}
-			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindowLic), (void**)&pAxWindow);
+			hRet = spUnk->QueryInterface(IID_IAxWinHostWindowLic, (void**)&pAxWindow);
 			if(FAILED(hRet))
 				return -1;	// abort window creation
 			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
@@ -2684,7 +2686,7 @@ typename Helper::ReturnType AtlAxDialogCreateT(
 	_In_ LPARAM dwInitParam)
 {
 	AtlAxWinInit();
-	Helper::ReturnType nRet = Helper::GetInvalidValue();
+	typename Helper::ReturnType nRet = Helper::GetInvalidValue();
 
 	HRSRC hDlg = AtlFindResource(hInstance, lpTemplateName, (StringType)RT_DIALOG);
 	if (hDlg != NULL)
@@ -2821,11 +2823,11 @@ ATLINLINE ATLAPI AtlAxCreateControlLicEx(
 	CComPtr<IUnknown> spUnkContainer;
 	CComPtr<IUnknown> spUnkControl;
 
-	hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
+	hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
 	if (SUCCEEDED(hr))
 	{
 		CComPtr<IAxWinHostWindowLic> pAxWindow;
-		spUnkContainer->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
+		spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
 		CComBSTR bstrName(lpszName);
 		hr = pAxWindow->CreateControlLicEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink, bstrLic);
 	}
@@ -2864,11 +2866,11 @@ ATLINLINE ATLAPI AtlAxAttachControl(
 		return E_INVALIDARG;
 	CComPtr<IUnknown> spUnkContainer;
 
-	HRESULT hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
+	HRESULT hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
 	if (SUCCEEDED(hr))
 	{
 		CComPtr<IAxWinHostWindow> spAxWindow;
-		hr = spUnkContainer->QueryInterface(&spAxWindow);
+		hr = spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&spAxWindow);
 		if (SUCCEEDED(hr))
 			hr = spAxWindow->AttachControl(pControl, hWnd);
 	}
diff --git a/include/atlimage.h b/include/atlimage.h
index 629756e..f40142f 100644
--- a/include/atlimage.h
+++ b/include/atlimage.h
@@ -44,6 +44,14 @@
 
 #pragma pack(push, _ATL_PACKING)
 
+#ifndef _MSC_VER
+#define ALPHA_SHIFT 24
+#define RED_SHIFT   16
+#define GREEN_SHIFT  8
+#define BLUE_SHIFT   0
+#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)
+#endif
+
 namespace ATL
 {
 
@@ -54,7 +62,7 @@ class CImage;
 class CImageDC
 {
 public:
-	CImageDC(_In_ const CImage& image) throw( ... );
+	CImageDC(_In_ const CImage& image) noexcept(false);
 	~CImageDC() throw();
 
 	operator HDC() const throw();
@@ -477,7 +485,7 @@ private:
 	static CDCCache s_cache;
 };
 
-inline CImageDC::CImageDC(_In_ const CImage& image) throw( ... ) :
+inline CImageDC::CImageDC(_In_ const CImage& image) noexcept(false) :
 	m_image( image ),
 	m_hDC( image.GetDC() )
 {
@@ -1012,7 +1020,7 @@ inline BOOL CImage::Draw(
 	Gdiplus::Graphics dcDst(hDestDC);
 	dcDst.SetInterpolationMode(interpolationMode);
 
-	Gdiplus::Status status = dcDst.DrawImage(&bm, rectDest.left, rectDest.top, rectDest.right - rectDest.left, rectDest.bottom - rectDest.top);
+	Gdiplus::Status status = dcDst.DrawImage(&bm, (int)rectDest.left, (int)rectDest.top, (int)(rectDest.right - rectDest.left), (int)(rectDest.bottom - rectDest.top));
 
 	return status == Gdiplus::Ok;
 }
diff --git a/include/atlmem.h b/include/atlmem.h
index e089444..fd733fb 100644
--- a/include/atlmem.h
+++ b/include/atlmem.h
@@ -37,15 +37,20 @@ inline N WINAPI AtlAlignDown(
 	return( N( n&~(N( nAlign )-1) ) );
 }
 
+#ifdef _MSC_VER
 __interface __declspec(uuid("654F7EF5-CFDF-4df9-A450-6C6A13C622C0")) IAtlMemMgr
+#else
+const IID IID_IAtlMemMgr = { 0x654f7ef5, 0xcfdf, 0x4df9, 0xa4,0x50, 0x6c,0x6a,0x13,0xc6,0x22,0xc0 };
+interface IAtlMemMgr
+#endif
 {
 public:
-	void* Allocate(_In_ size_t nBytes) throw();
-	void Free(_Inout_opt_ void* p) throw();
+	void* Allocate(_In_ size_t nBytes) throw() {}
+	void Free(_Inout_opt_ void* p) throw() {}
 	void* Reallocate(
 		_Inout_opt_bytecap_(nBytes) void* p,
-		_In_ size_t nBytes) throw();
-	size_t GetSize(_In_ void* p) throw();
+		_In_ size_t nBytes) throw() {}
+	size_t GetSize(_In_ void* p) throw() {}
 };
 
 class CCRTHeap :
@@ -249,7 +254,7 @@ public:
 #pragma pack(pop)
 
 #ifdef _OBJBASE_H_
-#include <atlcommem.h>
+#include <ATLComMem.h>
 #endif	// _OBJBASE_H_
 
 #endif  //__ATLMEM_H__
diff --git a/include/atlplus.h b/include/atlplus.h
index 4257544..1dc15db 100644
--- a/include/atlplus.h
+++ b/include/atlplus.h
@@ -111,7 +111,7 @@ ATLPREFAST_SUPPRESS(6387)
 		if (ppv == NULL)
 			return E_POINTER;
 		*ppv = NULL;
-		if (IsEqualGUID(riid, __uuidof(IUnknown)) || IsEqualGUID(riid, __uuidof(IRegistrarBase)) )
+		if (IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IRegistrarBase) )
 		{
 			*ppv = this;
 			return S_OK;
diff --git a/include/atlsecurity.h b/include/atlsecurity.h
index d6a3358..c325124 100644
--- a/include/atlsecurity.h
+++ b/include/atlsecurity.h
@@ -43,36 +43,36 @@ public:
 
 	explicit CSid(
 		_In_z_ LPCTSTR pszAccountName,
-		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
+		_In_opt_z_ LPCTSTR pszSystem = NULL) noexcept(false);
 	explicit CSid(
 		_In_ const SID *pSid,
-		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
+		_In_opt_z_ LPCTSTR pszSystem = NULL) noexcept(false);
 	CSid(
 		_In_ const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
-		_In_ BYTE nSubAuthorityCount, ...) throw(...);
+		_In_ BYTE nSubAuthorityCount, ...) noexcept(false);
 	virtual ~CSid() throw();
 
-	CSid(_In_ const CSid &rhs) throw(...);
-	CSid &operator=(_In_ const CSid &rhs) throw(...);
+	CSid(_In_ const CSid &rhs) noexcept(false);
+	CSid &operator=(_In_ const CSid &rhs) noexcept(false);
 
-	CSid(_In_ const SID &rhs) throw(...);
-	CSid &operator=(_In_ const SID &rhs) throw(...);
+	CSid(_In_ const SID &rhs) noexcept(false);
+	CSid &operator=(_In_ const SID &rhs) noexcept(false);
 
 	typedef CAtlArray<CSid> CSidArray;
 
 	bool LoadAccount(
 		_In_z_ LPCTSTR pszAccountName,
-		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
+		_In_opt_z_ LPCTSTR pszSystem = NULL) noexcept(false);
 	bool LoadAccount(
 		_In_ const SID *pSid,
-		_In_opt_z_ LPCTSTR pszSystem = NULL) throw(...);
+		_In_opt_z_ LPCTSTR pszSystem = NULL) noexcept(false);
 
-	LPCTSTR AccountName() const throw(...);
-	LPCTSTR Domain() const throw(...);
-	LPCTSTR Sid() const throw(...);
+	LPCTSTR AccountName() const noexcept(false);
+	LPCTSTR Domain() const noexcept(false);
+	LPCTSTR Sid() const noexcept(false);
 
-	const SID *GetPSID() const throw(...);
-	operator const SID *() const throw(...);
+	const SID *GetPSID() const noexcept(false);
+	operator const SID *() const noexcept(false);
 	SID_NAME_USE SidNameUse() const throw();
 
 	UINT GetLength() const throw();
@@ -87,9 +87,9 @@ public:
 	bool IsValid() const throw();
 
 private:
-	void Copy(_In_ const SID &rhs) throw(...);
+	void Copy(_In_ const SID &rhs) noexcept(false);
 	void Clear() throw();
-	void GetAccountNameAndDomain() const throw(...);
+	void GetAccountNameAndDomain() const noexcept(false);
 	SID* _GetPSID() const throw();
 
 	BYTE m_buffer[SECURITY_MAX_SID_SIZE];
@@ -131,42 +131,42 @@ bool operator>=(
 namespace Sids
 {
 // Universal
-CSid Null() throw(...);
-CSid World() throw(...);
-CSid Local() throw(...);
-CSid CreatorOwner() throw(...);
-CSid CreatorGroup() throw(...);
-CSid CreatorOwnerServer() throw(...);
-CSid CreatorGroupServer() throw(...);
+CSid Null() noexcept(false);
+CSid World() noexcept(false);
+CSid Local() noexcept(false);
+CSid CreatorOwner() noexcept(false);
+CSid CreatorGroup() noexcept(false);
+CSid CreatorOwnerServer() noexcept(false);
+CSid CreatorGroupServer() noexcept(false);
 
 // NT Authority
-CSid Dialup() throw(...);
-CSid Network() throw(...);
-CSid Batch() throw(...);
-CSid Interactive() throw(...);
-CSid Service() throw(...);
-CSid AnonymousLogon() throw(...);
-CSid Proxy() throw(...);
-CSid ServerLogon() throw(...);
-CSid Self() throw(...);
-CSid AuthenticatedUser() throw(...);
-CSid RestrictedCode() throw(...);
-CSid TerminalServer() throw(...);
-CSid System() throw(...);
-CSid NetworkService() throw (...);
+CSid Dialup() noexcept(false);
+CSid Network() noexcept(false);
+CSid Batch() noexcept(false);
+CSid Interactive() noexcept(false);
+CSid Service() noexcept(false);
+CSid AnonymousLogon() noexcept(false);
+CSid Proxy() noexcept(false);
+CSid ServerLogon() noexcept(false);
+CSid Self() noexcept(false);
+CSid AuthenticatedUser() noexcept(false);
+CSid RestrictedCode() noexcept(false);
+CSid TerminalServer() noexcept(false);
+CSid System() noexcept(false);
+CSid NetworkService() noexcept(false);
 
 // NT Authority\BUILTIN
-CSid Admins() throw(...);
-CSid Users() throw(...);
-CSid Guests() throw(...);
-CSid PowerUsers() throw(...);
-CSid AccountOps() throw(...);
-CSid SystemOps() throw(...);
-CSid PrintOps() throw(...);
-CSid BackupOps() throw(...);
-CSid Replicator() throw(...);
-CSid RasServers() throw(...);
-CSid PreW2KAccess() throw(...);
+CSid Admins() noexcept(false);
+CSid Users() noexcept(false);
+CSid Guests() noexcept(false);
+CSid PowerUsers() noexcept(false);
+CSid AccountOps() noexcept(false);
+CSid SystemOps() noexcept(false);
+CSid PrintOps() noexcept(false);
+CSid BackupOps() noexcept(false);
+CSid Replicator() noexcept(false);
+CSid RasServers() noexcept(false);
+CSid PreW2KAccess() noexcept(false);
 } // namespace Sids
 
 //***************************************
@@ -189,8 +189,8 @@ public:
 	CAcl() throw();
 	virtual ~CAcl() throw();
 
-	CAcl(_In_ const CAcl &rhs) throw(...);
-	CAcl &operator=(_In_ const CAcl &rhs) throw(...);
+	CAcl(_In_ const CAcl &rhs) noexcept(false);
+	CAcl &operator=(_In_ const CAcl &rhs) noexcept(false);
 
 	typedef CAtlArray<ACCESS_MASK> CAccessMaskArray;
 	typedef CAtlArray<BYTE> CAceTypeArray;
@@ -200,7 +200,7 @@ public:
 		_Out_ CSid::CSidArray *pSids,
 		_Out_opt_ CAccessMaskArray *pAccessMasks = NULL,
 		_Out_opt_ CAceTypeArray *pAceTypes = NULL,
-		_Out_opt_ CAceFlagArray *pAceFlags = NULL) const throw(...);
+		_Out_opt_ CAceFlagArray *pAceFlags = NULL) const noexcept(false);
 	void GetAclEntry(
 		_In_ UINT nIndex,
 		_Inout_opt_ CSid* pSid,
@@ -208,17 +208,17 @@ public:
 		_Out_opt_ BYTE* pType = NULL,
 		_Out_opt_ BYTE* pFlags = NULL,
 		_Out_opt_ GUID* pObjectType = NULL,
-		_Out_opt_ GUID* pInheritedObjectType = NULL) const throw(...);
+		_Out_opt_ GUID* pInheritedObjectType = NULL) const noexcept(false);
 
-	bool RemoveAces(_In_ const CSid &rSid) throw(...);
+	bool RemoveAces(_In_ const CSid &rSid) noexcept(false);
 
 	virtual UINT GetAceCount() const throw() = 0;
 	virtual void RemoveAllAces() throw() = 0;
 	virtual void RemoveAce(_In_ UINT nIndex) = 0;
 
-	const ACL *GetPACL() const throw(...);
-	operator const ACL *() const throw(...);
-	UINT GetLength() const throw(...);
+	const ACL *GetPACL() const noexcept(false);
+	operator const ACL *() const noexcept(false);
+	UINT GetLength() const noexcept(false);
 
 	void SetNull() throw();
 	void SetEmpty() throw();
@@ -238,13 +238,13 @@ protected:
 		CAce(
 			_In_ const CSid &rSid,
 			_In_ ACCESS_MASK accessmask,
-			_In_ BYTE aceflags) throw(...);
+			_In_ BYTE aceflags) noexcept(false);
 		virtual ~CAce() throw();
 
-		CAce(_In_ const CAce &rhs) throw(...);
-		CAce &operator=(_In_ const CAce &rhs) throw(...);
+		CAce(_In_ const CAce &rhs) noexcept(false);
+		CAce &operator=(_In_ const CAce &rhs) noexcept(false);
 
-		virtual void *GetACE() const throw(...) = 0;
+		virtual void *GetACE() const noexcept(false) = 0;
 		virtual UINT GetLength() const throw() = 0;
 		virtual BYTE AceType() const throw() = 0;
 		virtual bool IsObjectAce() const throw();
@@ -280,33 +280,33 @@ public:
 	CDacl() throw();
 	virtual ~CDacl() throw();
 
-	CDacl(_In_ const CDacl &rhs) throw(...);
-	CDacl &operator=(_In_ const CDacl &rhs) throw(...);
+	CDacl(_In_ const CDacl &rhs) noexcept(false);
+	CDacl &operator=(_In_ const CDacl &rhs) noexcept(false);
 
-	CDacl(_In_ const ACL &rhs) throw(...);
-	CDacl &operator=(_In_ const ACL &rhs) throw(...);
+	CDacl(_In_ const ACL &rhs) noexcept(false);
+	CDacl &operator=(_In_ const ACL &rhs) noexcept(false);
 
 	bool AddAllowedAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
-		_In_ BYTE aceflags = 0) throw(...);
+		_In_ BYTE aceflags = 0) noexcept(false);
 	bool AddDeniedAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
-		_In_ BYTE aceflags = 0) throw(...);
+		_In_ BYTE aceflags = 0) noexcept(false);
 #if(_WIN32_WINNT >= 0x0500)
 	bool AddAllowedAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
 		_In_ BYTE aceflags,
 		_In_ const GUID *pObjectType,
-		_In_ const GUID *pInheritedObjectType) throw(...);
+		_In_ const GUID *pInheritedObjectType) noexcept(false);
 	bool AddDeniedAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
 		_In_ BYTE aceflags,
 		_In_ const GUID *pObjectType,
-		_In_ const GUID *pInheritedObjectType) throw(...);
+		_In_ const GUID *pInheritedObjectType) noexcept(false);
 #endif
 	void RemoveAllAces() throw();
 	void RemoveAce(_In_ UINT nIndex);
@@ -314,8 +314,8 @@ public:
 	UINT GetAceCount() const throw();
 
 private:
-	void Copy(_In_ const CDacl &rhs) throw(...);
-	void Copy(_In_ const ACL &rhs) throw(...);
+	void Copy(_In_ const CDacl &rhs) noexcept(false);
+	void Copy(_In_ const ACL &rhs) noexcept(false);
 
 	class CAccessAce : 
 		public CAcl::CAce
@@ -325,10 +325,10 @@ private:
 			_In_ const CSid &rSid,
 			_In_ ACCESS_MASK accessmask,
 			_In_ BYTE aceflags,
-			_In_ bool bAllowAccess) throw(...);
+			_In_ bool bAllowAccess) noexcept(false);
 		virtual ~CAccessAce() throw();
 
-		void *GetACE() const throw(...);
+		void *GetACE() const noexcept(false);
 		UINT GetLength() const throw();
 		BYTE AceType() const throw();
 
@@ -354,13 +354,13 @@ private:
 			_In_ BYTE aceflags,
 			_In_ bool bAllowAccess,
 			_In_opt_ const GUID *pObjectType,
-			_In_opt_ const GUID *pInheritedObjectType) throw(...);
+			_In_opt_ const GUID *pInheritedObjectType) noexcept(false);
 		virtual ~CAccessObjectAce() throw();
 
-		CAccessObjectAce(_In_ const CAccessObjectAce &rhs) throw(...);
-		CAccessObjectAce &operator=(_In_ const CAccessObjectAce &rhs) throw(...);
+		CAccessObjectAce(_In_ const CAccessObjectAce &rhs) noexcept(false);
+		CAccessObjectAce &operator=(_In_ const CAccessObjectAce &rhs) noexcept(false);
 
-		void *GetACE() const throw(...);
+		void *GetACE() const noexcept(false);
 		UINT GetLength() const throw();
 		BYTE AceType() const throw();
 		bool IsObjectAce() const throw();
@@ -390,18 +390,18 @@ public:
 	CSacl() throw();
 	virtual ~CSacl() throw();
 
-	CSacl(_In_ const CSacl &rhs) throw(...);
-	CSacl &operator=(_In_ const CSacl &rhs) throw(...);
+	CSacl(_In_ const CSacl &rhs) noexcept(false);
+	CSacl &operator=(_In_ const CSacl &rhs) noexcept(false);
 
-	CSacl(_In_ const ACL &rhs) throw(...);
-	CSacl &operator=(_In_ const ACL &rhs) throw(...);
+	CSacl(_In_ const ACL &rhs) noexcept(false);
+	CSacl &operator=(_In_ const ACL &rhs) noexcept(false);
 
 	bool AddAuditAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
 		_In_ bool bSuccess,
 		_In_ bool bFailure,
-		_In_ BYTE aceflags = 0) throw(...);
+		_In_ BYTE aceflags = 0) noexcept(false);
 #if(_WIN32_WINNT >= 0x0500)
 	bool AddAuditAce(
 		_In_ const CSid &rSid,
@@ -410,7 +410,7 @@ public:
 		_In_ bool bFailure,
 		_In_ BYTE aceflags,
 		_In_ const GUID *pObjectType,
-		_In_ const GUID *pInheritedObjectType) throw(...);
+		_In_ const GUID *pInheritedObjectType) noexcept(false);
 #endif
 	void RemoveAllAces() throw();
 	void RemoveAce(_In_ UINT nIndex);
@@ -418,8 +418,8 @@ public:
 	UINT GetAceCount() const throw();
 
 private:
-	void Copy(_In_ const CSacl &rhs) throw(...);
-	void Copy(_In_ const ACL &rhs) throw(...);
+	void Copy(_In_ const CSacl &rhs) noexcept(false);
+	void Copy(_In_ const ACL &rhs) noexcept(false);
 
 	class CAuditAce : 
 		public CAcl::CAce
@@ -430,10 +430,10 @@ private:
 			_In_ ACCESS_MASK accessmask,
 			_In_ BYTE aceflags,
 			_In_ bool bAuditSuccess,
-			_In_ bool bAuditFailure) throw(...);
+			_In_ bool bAuditFailure) noexcept(false);
 		virtual ~CAuditAce() throw();
 
-		void *GetACE() const throw(...);
+		void *GetACE() const noexcept(false);
 		UINT GetLength() const throw();
 		BYTE AceType() const throw();
 	protected:
@@ -453,13 +453,13 @@ private:
 			_In_ bool bAuditSuccess,
 			_In_ bool bAuditFailure,
 			_In_opt_ const GUID *pObjectType,
-			_In_opt_ const GUID *pInheritedObjectType) throw(...);
+			_In_opt_ const GUID *pInheritedObjectType) noexcept(false);
 		virtual ~CAuditObjectAce() throw();
 
-		CAuditObjectAce(_In_ const CAuditObjectAce &rhs) throw(...);
-		CAuditObjectAce &operator=(_In_ const CAuditObjectAce &rhs) throw(...);
+		CAuditObjectAce(_In_ const CAuditObjectAce &rhs) noexcept(false);
+		CAuditObjectAce &operator=(_In_ const CAuditObjectAce &rhs) noexcept(false);
 
-		void *GetACE() const throw(...);
+		void *GetACE() const noexcept(false);
 		UINT GetLength() const throw();
 		BYTE AceType() const throw();
 		bool IsObjectAce() const throw();
@@ -485,52 +485,52 @@ public:
 	CSecurityDesc() throw();
 	virtual ~CSecurityDesc() throw();
 
-	CSecurityDesc(_In_ const CSecurityDesc &rhs) throw(...);
-	CSecurityDesc &operator=(_In_ const CSecurityDesc &rhs) throw(...);
+	CSecurityDesc(_In_ const CSecurityDesc &rhs) noexcept(false);
+	CSecurityDesc &operator=(_In_ const CSecurityDesc &rhs) noexcept(false);
 
-	CSecurityDesc(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);
-	CSecurityDesc &operator=(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);
+	CSecurityDesc(_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false);
+	CSecurityDesc &operator=(_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false);
 
 #if(_WIN32_WINNT >= 0x0500)
-	bool FromString(_In_z_ LPCTSTR pstr) throw(...);
+	bool FromString(_In_z_ LPCTSTR pstr) noexcept(false);
 	bool ToString(
 		_In_ CString *pstr,
 		_In_ SECURITY_INFORMATION si =
 			OWNER_SECURITY_INFORMATION |
 			GROUP_SECURITY_INFORMATION |
 			DACL_SECURITY_INFORMATION |
-			SACL_SECURITY_INFORMATION) const throw(...);
+			SACL_SECURITY_INFORMATION) const noexcept(false);
 #endif
 
 	void SetOwner(
 		_In_ const CSid &sid,
-		_In_ bool bDefaulted = false) throw(...);
+		_In_ bool bDefaulted = false) noexcept(false);
 	void SetGroup(
 		_In_ const CSid &sid,
-		_In_ bool bDefaulted = false) throw(...);
+		_In_ bool bDefaulted = false) noexcept(false);
 	void SetDacl(
 		_In_ const CDacl &Dacl,
-		_In_ bool bDefaulted = false) throw(...);
+		_In_ bool bDefaulted = false) noexcept(false);
 	void SetDacl(
 		_In_ bool bPresent,
-		_In_ bool bDefaulted = false) throw(...);
+		_In_ bool bDefaulted = false) noexcept(false);
 	void SetSacl(
 		_In_ const CSacl &Sacl,
-		_In_ bool bDefaulted = false) throw(...);
+		_In_ bool bDefaulted = false) noexcept(false);
 	bool GetOwner(
 		_Out_ CSid *pSid,
-		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
+		_Out_opt_ bool *pbDefaulted = NULL) const noexcept(false);
 	bool GetGroup(
 		_Out_ CSid *pSid,
-		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
+		_Out_opt_ bool *pbDefaulted = NULL) const noexcept(false);
 	bool GetDacl(
 		_Out_ CDacl *pDacl,
 		_Out_opt_ bool *pbPresent = NULL,
-		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
+		_Out_opt_ bool *pbDefaulted = NULL) const noexcept(false);
 	bool GetSacl(
 		_Out_ CSacl *pSacl,
 		_Out_opt_ bool *pbPresent = NULL,
-		_Out_opt_ bool *pbDefaulted = NULL) const throw(...);
+		_Out_opt_ bool *pbDefaulted = NULL) const noexcept(false);
 
 	bool IsDaclDefaulted() const throw();
 	bool IsDaclPresent() const throw();
@@ -551,7 +551,7 @@ public:
 
 	void GetSECURITY_DESCRIPTOR(
 		_Out_ SECURITY_DESCRIPTOR *pSD,
-		_Inout_ LPDWORD lpdwBufferLength) throw(...);
+		_Inout_ LPDWORD lpdwBufferLength) noexcept(false);
 
 	UINT GetLength() throw();
 
@@ -562,13 +562,13 @@ public:
 		_In_ SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet) throw();
 #endif
 
-	void MakeSelfRelative() throw(...);
-	void MakeAbsolute() throw(...);
+	void MakeSelfRelative() noexcept(false);
+	void MakeAbsolute() noexcept(false);
 
 protected:
 	virtual void Clear() throw();
-	void AllocateAndInitializeSecurityDescriptor() throw(...);
-	void Init(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...);
+	void AllocateAndInitializeSecurityDescriptor() noexcept(false);
+	void Init(_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false);
 
 	SECURITY_DESCRIPTOR *m_pSecurityDescriptor;
 };
@@ -583,11 +583,11 @@ public:
 	CSecurityAttributes() throw();
 	explicit CSecurityAttributes(
 		_In_ const CSecurityDesc &rSecurityDescriptor,
-		_In_ bool bInheritHandle = false) throw(...);
+		_In_ bool bInheritHandle = false) noexcept(false);
 
 	void Set(
 		_In_ const CSecurityDesc &rSecurityDescriptor,
-		_In_ bool bInheritHandle = false) throw(...);
+		_In_ bool bInheritHandle = false) noexcept(false);
 
 protected:
 	CSecurityDesc m_SecurityDescriptor;
@@ -643,30 +643,30 @@ public:
 	CTokenPrivileges() throw();
 	virtual ~CTokenPrivileges() throw();
 
-	CTokenPrivileges(_In_ const CTokenPrivileges &rhs) throw(...);
-	CTokenPrivileges &operator=(_In_ const CTokenPrivileges &rhs) throw(...);
+	CTokenPrivileges(_In_ const CTokenPrivileges &rhs) noexcept(false);
+	CTokenPrivileges &operator=(_In_ const CTokenPrivileges &rhs) noexcept(false);
 
-	CTokenPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
-	CTokenPrivileges &operator=(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
+	CTokenPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false);
+	CTokenPrivileges &operator=(_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false);
 
-	void Add(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
+	void Add(_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false);
 	bool Add(
 		_In_z_ LPCTSTR pszPrivilege,
-		_In_ bool bEnable) throw(...);
+		_In_ bool bEnable) noexcept(false);
 
 	typedef CAtlArray<CString> CNames;
 	typedef CAtlArray<DWORD> CAttributes;
 
 	bool LookupPrivilege(
 		_In_z_ LPCTSTR pszPrivilege,
-		_Out_opt_ DWORD *pdwAttributes = NULL) const throw(...);
+		_Out_opt_ DWORD *pdwAttributes = NULL) const noexcept(false);
 	void GetNamesAndAttributes(
 		_Inout_ CNames *pNames,
-		_Inout_opt_ CAttributes *pAttributes = NULL) const throw(...);
-	void GetDisplayNames(_Inout_ CNames *pDisplayNames) const throw(...);
+		_Inout_opt_ CAttributes *pAttributes = NULL) const noexcept(false);
+	void GetDisplayNames(_Inout_ CNames *pDisplayNames) const noexcept(false);
 	void GetLuidsAndAttributes(
 		_Inout_ CLUIDArray *pPrivileges,
-		_Inout_opt_ CAttributes *pAttributes = NULL) const throw(...);
+		_Inout_opt_ CAttributes *pAttributes = NULL) const noexcept(false);
 
 	bool Delete(_In_z_ LPCTSTR pszPrivilege) throw();
 	void DeleteAll() throw();
@@ -674,8 +674,8 @@ public:
 	UINT GetCount() const throw();
 	UINT GetLength() const throw();
 
-	const TOKEN_PRIVILEGES *GetPTOKEN_PRIVILEGES() const throw(...);
-	operator const TOKEN_PRIVILEGES *() const throw(...);
+	const TOKEN_PRIVILEGES *GetPTOKEN_PRIVILEGES() const noexcept(false);
+	operator const TOKEN_PRIVILEGES *() const noexcept(false);
 
 private:
 	typedef CAtlMap<LUID, DWORD> Map;
@@ -683,7 +683,7 @@ private:
 	mutable TOKEN_PRIVILEGES *m_pTokenPrivileges;
 	bool m_bDirty;
 
-	void AddPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...);
+	void AddPrivileges(_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false);
 };
 
 //******************************************************
@@ -695,21 +695,21 @@ public:
 	CTokenGroups() throw();
 	virtual ~CTokenGroups() throw();
 
-	CTokenGroups(_In_ const CTokenGroups &rhs) throw(...);
-	CTokenGroups &operator=(_In_ const CTokenGroups &rhs) throw(...);
+	CTokenGroups(_In_ const CTokenGroups &rhs) noexcept(false);
+	CTokenGroups &operator=(_In_ const CTokenGroups &rhs) noexcept(false);
 
-	CTokenGroups(_In_ const TOKEN_GROUPS &rhs) throw(...);
-	CTokenGroups &operator=(_In_ const TOKEN_GROUPS &rhs) throw(...);
+	CTokenGroups(_In_ const TOKEN_GROUPS &rhs) noexcept(false);
+	CTokenGroups &operator=(_In_ const TOKEN_GROUPS &rhs) noexcept(false);
 
-	void Add(_In_ const TOKEN_GROUPS &rTokenGroups) throw(...);
-	void Add(_In_ const CSid &rSid, _In_ DWORD dwAttributes) throw(...);
+	void Add(_In_ const TOKEN_GROUPS &rTokenGroups) noexcept(false);
+	void Add(_In_ const CSid &rSid, _In_ DWORD dwAttributes) noexcept(false);
 
 	bool LookupSid(
 		_In_ const CSid &rSid,
 		_Out_opt_ DWORD *pdwAttributes = NULL) const throw();
 	void GetSidsAndAttributes(
 		_Inout_ CSid::CSidArray *pSids,
-		_Inout_opt_ CAtlArray<DWORD> *pAttributes = NULL) const throw(...);
+		_Inout_opt_ CAtlArray<DWORD> *pAttributes = NULL) const noexcept(false);
 
 	bool Delete(_In_ const CSid &rSid) throw();
 	void DeleteAll() throw();
@@ -717,8 +717,8 @@ public:
 	UINT GetCount() const throw();
 	UINT GetLength() const throw();
 
-	const TOKEN_GROUPS *GetPTOKEN_GROUPS() const throw(...);
-	operator const TOKEN_GROUPS *() const throw(...);
+	const TOKEN_GROUPS *GetPTOKEN_GROUPS() const noexcept(false);
+	operator const TOKEN_GROUPS *() const noexcept(false);
 
 private:
 	class CTGElementTraits :
@@ -743,7 +743,7 @@ private:
 	mutable TOKEN_GROUPS *m_pTokenGroups;
 	mutable bool m_bDirty;
 
-	void AddTokenGroups(_In_ const TOKEN_GROUPS &rTokenGroups) throw(...);
+	void AddTokenGroups(_In_ const TOKEN_GROUPS &rTokenGroups) noexcept(false);
 };
 
 // *************************************
@@ -764,34 +764,34 @@ public:
 	bool EnablePrivilege(
 		_In_z_ LPCTSTR pszPrivilege,
 		_In_opt_ CTokenPrivileges *pPreviousState = NULL,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool EnablePrivileges(
 		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool DisablePrivilege(
 		_In_z_ LPCTSTR pszPrivilege,
 		_In_opt_ CTokenPrivileges *pPreviousState = NULL,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool DisablePrivileges(
 		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool EnableDisablePrivileges(
 		_In_ const CTokenPrivileges &rPrivilenges,
 		_Inout_opt_ CTokenPrivileges *pPreviousState = NULL,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool PrivilegeCheck(
 		_In_ PPRIVILEGE_SET RequiredPrivileges,
 		_Out_ bool *pbResult) const throw();
 
-	bool GetLogonSid(_Inout_ CSid *pSid) const throw(...);
-	bool GetTokenId(_Out_ LUID *pluid) const throw(...);
-	bool GetLogonSessionId(_Out_ LUID *pluid) const throw(...);
+	bool GetLogonSid(_Inout_ CSid *pSid) const noexcept(false);
+	bool GetTokenId(_Out_ LUID *pluid) const noexcept(false);
+	bool GetLogonSessionId(_Out_ LUID *pluid) const noexcept(false);
 
 	bool CheckTokenMembership(
 		_In_ const CSid &rSid,
-		_Inout_ bool *pbIsMember) const throw(...);
+		_Inout_ bool *pbIsMember) const noexcept(false);
 #if(_WIN32_WINNT >= 0x0500)
 	bool IsTokenRestricted() const throw();
 #endif
@@ -800,7 +800,7 @@ public:
 protected:
 	void InfoTypeToRetType(
 		_Inout_ CSid *pRet,
-		_In_ const TOKEN_USER &rWork) const throw(...)
+		_In_ const TOKEN_USER &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = *static_cast<SID *>(rWork.User.Sid);
@@ -808,7 +808,7 @@ protected:
 
 	void InfoTypeToRetType(
 		_Inout_ CTokenGroups *pRet,
-		_In_ const TOKEN_GROUPS &rWork) const throw(...)
+		_In_ const TOKEN_GROUPS &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = rWork;
@@ -816,7 +816,7 @@ protected:
 
 	void InfoTypeToRetType(
 		_Inout_ CTokenPrivileges *pRet,
-		_In_ const TOKEN_PRIVILEGES &rWork) const throw(...)
+		_In_ const TOKEN_PRIVILEGES &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = rWork;
@@ -824,7 +824,7 @@ protected:
 
 	void InfoTypeToRetType(
 		_Inout_ CSid *pRet,
-		_In_ const TOKEN_OWNER &rWork) const throw(...)
+		_In_ const TOKEN_OWNER &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = *static_cast<SID *>(rWork.Owner);
@@ -832,7 +832,7 @@ protected:
 
 	void InfoTypeToRetType(
 		_Inout_ CSid *pRet,
-		_In_ const TOKEN_PRIMARY_GROUP &rWork) const throw(...)
+		_In_ const TOKEN_PRIMARY_GROUP &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = *static_cast<SID *>(rWork.PrimaryGroup);
@@ -840,7 +840,7 @@ protected:
 
 	void InfoTypeToRetType(
 		_Inout_ CDacl *pRet,
-		_In_ const TOKEN_DEFAULT_DACL &rWork) const throw(...)
+		_In_ const TOKEN_DEFAULT_DACL &rWork) const noexcept(false)
 	{
 		ATLENSURE(pRet);
 		*pRet = *rWork.DefaultDacl;
@@ -850,7 +850,7 @@ protected:
 	bool GetInfoConvert(
 		_Inout_ RET_T *pRet,
 		_In_ TOKEN_INFORMATION_CLASS TokenClass,
-		_Out_opt_ INFO_T *pWork = NULL) const throw(...)
+		_Out_opt_ INFO_T *pWork = NULL) const noexcept(false)
 	{
 		ATLASSERT(pRet);
 		if(!pRet)
@@ -875,7 +875,7 @@ protected:
 	template<typename RET_T>
 	bool GetInfo(
 		_Inout_ RET_T *pRet,
-		_In_ TOKEN_INFORMATION_CLASS TokenClass) const throw(...)
+		_In_ TOKEN_INFORMATION_CLASS TokenClass) const noexcept(false)
 	{
 		ATLASSERT(pRet);
 		if(!pRet)
@@ -888,36 +888,36 @@ protected:
 	}
 
 public:
-	bool GetDefaultDacl(_Inout_ CDacl *pDacl) const throw(...);
-	bool GetGroups(_Inout_ CTokenGroups *pGroups) const throw(...);
-	bool GetImpersonationLevel(_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const throw(...);
-	bool GetOwner(_Inout_ CSid *pSid) const throw(...);
-	bool GetPrimaryGroup(_Inout_ CSid *pSid) const throw(...);
-	bool GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const throw(...);
-	bool GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const throw(...);
-	bool GetSource(_Inout_ TOKEN_SOURCE *pSource) const throw(...);
-	bool GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const throw(...);
-	bool GetType(_Inout_ TOKEN_TYPE *pType) const throw(...);
-	bool GetUser(_Inout_ CSid *pSid) const throw(...);
-
-	bool SetOwner(_In_ const CSid &rSid) throw(...);
-	bool SetPrimaryGroup(_In_ const CSid &rSid) throw(...);
-	bool SetDefaultDacl(_In_ const CDacl &rDacl) throw(...);
+	bool GetDefaultDacl(_Inout_ CDacl *pDacl) const noexcept(false);
+	bool GetGroups(_Inout_ CTokenGroups *pGroups) const noexcept(false);
+	bool GetImpersonationLevel(_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const noexcept(false);
+	bool GetOwner(_Inout_ CSid *pSid) const noexcept(false);
+	bool GetPrimaryGroup(_Inout_ CSid *pSid) const noexcept(false);
+	bool GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const noexcept(false);
+	bool GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const noexcept(false);
+	bool GetSource(_Inout_ TOKEN_SOURCE *pSource) const noexcept(false);
+	bool GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const noexcept(false);
+	bool GetType(_Inout_ TOKEN_TYPE *pType) const noexcept(false);
+	bool GetUser(_Inout_ CSid *pSid) const noexcept(false);
+
+	bool SetOwner(_In_ const CSid &rSid) noexcept(false);
+	bool SetPrimaryGroup(_In_ const CSid &rSid) noexcept(false);
+	bool SetDefaultDacl(_In_ const CDacl &rDacl) noexcept(false);
 
 	bool CreateImpersonationToken(
 		_Inout_ CAccessToken *pImp,
-		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) const throw(...);
+		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) const noexcept(false);
 	bool CreatePrimaryToken(
 		_Inout_ CAccessToken *pPri,
 		_In_ DWORD dwDesiredAccess = MAXIMUM_ALLOWED,
-		_In_opt_ const CSecurityAttributes *pTokenAttributes = NULL) const throw(...);
+		_In_opt_ const CSecurityAttributes *pTokenAttributes = NULL) const noexcept(false);
 
 #if(_WIN32_WINNT >= 0x0500)
 	bool CreateRestrictedToken(
 		_Inout_ CAccessToken *pRestrictedToken,
 		_In_ const CTokenGroups &SidsToDisable,
 		_In_ const CTokenGroups &SidsToRestrict,
-		_In_ const CTokenPrivileges &PrivilegesToDelete = CTokenPrivileges()) const throw(...);
+		_In_ const CTokenPrivileges &PrivilegesToDelete = CTokenPrivileges()) const noexcept(false);
 #endif
 
 	// Token API type functions
@@ -934,31 +934,31 @@ public:
 		_In_ DWORD dwDesiredAccess,
 		_In_ bool bImpersonate = false,
 		_In_ bool bOpenAsSelf = true,
-		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) throw(...);
+		_In_ SECURITY_IMPERSONATION_LEVEL sil = SecurityImpersonation) noexcept(false);
 
 #if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)
 	bool OpenCOMClientToken(
 		_In_ DWORD dwDesiredAccess,
 		_In_ bool bImpersonate = false,
-		_In_ bool bOpenAsSelf = true) throw(...);
+		_In_ bool bOpenAsSelf = true) noexcept(false);
 #endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)
 
 	bool OpenNamedPipeClientToken(
 		_In_ HANDLE hPipe,
 		_In_ DWORD dwDesiredAccess,
 		_In_ bool bImpersonate = false,
-		_In_ bool bOpenAsSelf = true) throw(...);
+		_In_ bool bOpenAsSelf = true) noexcept(false);
 	bool OpenRPCClientToken(
 		_In_ RPC_BINDING_HANDLE BindingHandle,
 		_In_ DWORD dwDesiredAccess,
 		_In_ bool bImpersonate = false,
-		_In_ bool bOpenAsSelf = true) throw(...);
+		_In_ bool bOpenAsSelf = true) noexcept(false);
 
-	bool ImpersonateLoggedOnUser() const throw(...);
-	bool Impersonate(_In_opt_ HANDLE hThread = NULL) const throw(...);
+	bool ImpersonateLoggedOnUser() const noexcept(false);
+	bool Impersonate(_In_opt_ HANDLE hThread = NULL) const noexcept(false);
 	bool Revert(_In_opt_ HANDLE hThread = NULL) const throw();
 
-	bool LoadUserProfile() throw(...);
+	bool LoadUserProfile() noexcept(false);
 	HANDLE GetProfile() const throw();
 
 	// Must hold Tcb privilege
@@ -988,7 +988,7 @@ protected:
 		_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 		_In_ bool bEnable,
 		_Inout_opt_ CTokenPrivileges *pPreviousState,
-		_Out_opt_ bool* pbErrNotAllAssigned=NULL) throw(...);
+		_Out_opt_ bool* pbErrNotAllAssigned=NULL) noexcept(false);
 	bool CheckImpersonation() const throw();
 
 	bool RevertToLevel(_In_opt_ SECURITY_IMPERSONATION_LEVEL *pSil) const throw();
@@ -998,8 +998,8 @@ protected:
 	HANDLE m_hToken, m_hProfile;
 
 private:
-	CAccessToken(_In_ const CAccessToken &rhs) throw(...);
-	CAccessToken &operator=(_In_ const CAccessToken &rhs) throw(...);
+	CAccessToken(_In_ const CAccessToken &rhs) noexcept(false);
+	CAccessToken &operator=(_In_ const CAccessToken &rhs) noexcept(false);
 
 	class CRevert
 	{
@@ -1065,8 +1065,8 @@ public:
 private:
 	const CAccessToken* m_pAT;
 
-	CAutoRevertImpersonation(_In_ const CAutoRevertImpersonation &rhs) throw(...);
-	CAutoRevertImpersonation &operator=(_In_ const CAutoRevertImpersonation &rhs) throw(...);
+	CAutoRevertImpersonation(_In_ const CAutoRevertImpersonation &rhs) noexcept(false);
+	CAutoRevertImpersonation &operator=(_In_ const CAutoRevertImpersonation &rhs) noexcept(false);
 };
 
 //*******************************************
@@ -1127,8 +1127,8 @@ protected:
 private:
 	bool m_bPrivate;
 
-	CPrivateObjectSecurityDesc(_In_ const CPrivateObjectSecurityDesc &rhs) throw(...);
-	CPrivateObjectSecurityDesc &operator=(_In_ const CPrivateObjectSecurityDesc &rhs) throw(...);
+	CPrivateObjectSecurityDesc(_In_ const CPrivateObjectSecurityDesc &rhs) noexcept(false);
+	CPrivateObjectSecurityDesc &operator=(_In_ const CPrivateObjectSecurityDesc &rhs) noexcept(false);
 };
 
 //*******************************************
@@ -1143,7 +1143,7 @@ inline bool AtlGetSecurityDescriptor(
 		GROUP_SECURITY_INFORMATION |
 		DACL_SECURITY_INFORMATION |
 		SACL_SECURITY_INFORMATION,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 inline bool AtlGetSecurityDescriptor(
 	_In_ HANDLE hObject,
@@ -1154,95 +1154,95 @@ inline bool AtlGetSecurityDescriptor(
 		GROUP_SECURITY_INFORMATION |
 		DACL_SECURITY_INFORMATION |
 		SACL_SECURITY_INFORMATION,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 inline bool AtlGetOwnerSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...);
+	_Inout_ CSid *pSid) noexcept(false);
 
 inline bool AtlSetOwnerSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...);
+	_In_ const CSid &rSid) noexcept(false);
 
 inline bool AtlGetOwnerSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...);
+	_Inout_ CSid *pSid) noexcept(false);
 
 inline bool AtlSetOwnerSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...);
+	_In_ const CSid &rSid) noexcept(false);
 
 inline bool AtlGetGroupSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...);
+	_Inout_ CSid *pSid) noexcept(false);
 
 inline bool AtlSetGroupSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...);
+	_In_ const CSid &rSid) noexcept(false);
 
 inline bool AtlGetGroupSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...);
+	_Inout_ CSid *pSid) noexcept(false);
 
 inline bool AtlSetGroupSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...);
+	_In_ const CSid &rSid) noexcept(false);
 
 inline bool AtlGetDacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CDacl *pDacl) throw(...);
+	_Inout_ CDacl *pDacl) noexcept(false);
 
 inline bool AtlSetDacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CDacl &rDacl,
-	_In_ DWORD dwInheritanceFlowControl = 0) throw(...);
+	_In_ DWORD dwInheritanceFlowControl = 0) noexcept(false);
 
 inline bool AtlGetDacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CDacl *pDacl) throw(...);
+	_Inout_ CDacl *pDacl) noexcept(false);
 
 inline bool AtlSetDacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CDacl &rDacl,
-	_In_ DWORD dwInheritanceFlowControl = 0) throw(...);
+	_In_ DWORD dwInheritanceFlowControl = 0) noexcept(false);
 
 inline bool AtlGetSacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_Inout_ CSacl *pSacl,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 inline bool AtlSetSacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CSacl &rSacl,
 	_In_ DWORD dwInheritanceFlowControl = 0,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 inline bool AtlGetSacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_Inout_ CSacl *pSacl,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 inline bool AtlSetSacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CSacl &rSacl,
 	_In_ DWORD dwInheritanceFlowControl = 0,
-	_In_ bool bRequestNeededPrivileges = true) throw(...);
+	_In_ bool bRequestNeededPrivileges = true) noexcept(false);
 
 } // namespace ATL
 
diff --git a/include/atlsecurity.inl b/include/atlsecurity.inl
index 9aee409..72e1b30 100644
--- a/include/atlsecurity.inl
+++ b/include/atlsecurity.inl
@@ -34,7 +34,7 @@ inline CSid::CSid() throw() :
 
 inline CSid::CSid(
 		_In_z_ LPCTSTR pszAccountName,
-		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...) :
+		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) noexcept(false) :
 	m_bValid(false),
 	m_sidnameuse(SidTypeInvalid)
 {
@@ -44,7 +44,7 @@ inline CSid::CSid(
 
 inline CSid::CSid(
 		_In_ const SID *pSid,
-		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...) :
+		_In_opt_z_ LPCTSTR pszSystem /* = NULL */) noexcept(false) :
 	m_bValid(false),
 	m_sidnameuse(SidTypeInvalid)
 {
@@ -57,7 +57,7 @@ inline CSid::CSid(
 inline CSid::CSid(
 		_In_ const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
 		_In_ BYTE nSubAuthorityCount,
-		...) throw(...) :
+		...) noexcept(false) :
 	m_bValid(false),
 	m_sidnameuse(SidTypeInvalid)
 {
@@ -91,7 +91,7 @@ inline CSid::~CSid() throw()
 {
 }
 
-inline CSid::CSid(_In_ const CSid &rhs) throw(...) :
+inline CSid::CSid(_In_ const CSid &rhs) noexcept(false) :
 	m_sidnameuse(rhs.m_sidnameuse),
 	m_bValid(rhs.m_bValid),
 	m_strAccountName(rhs.m_strAccountName),
@@ -111,7 +111,7 @@ inline CSid::CSid(_In_ const CSid &rhs) throw(...) :
 	}
 }
 
-inline CSid &CSid::operator=(_In_ const CSid &rhs) throw(...)
+inline CSid &CSid::operator=(_In_ const CSid &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -134,14 +134,14 @@ inline CSid &CSid::operator=(_In_ const CSid &rhs) throw(...)
 	return *this;
 }
 
-inline CSid::CSid(_In_ const SID &rhs) throw(...) :
+inline CSid::CSid(_In_ const SID &rhs) noexcept(false) :
 	m_bValid(false),
 	m_sidnameuse(SidTypeInvalid)
 {
 	Copy(rhs);
 }
 
-inline CSid &CSid::operator=(_In_ const SID &rhs) throw(...)
+inline CSid &CSid::operator=(_In_ const SID &rhs) noexcept(false)
 {
 	if (!m_bValid || _GetPSID() != &rhs)
 	{
@@ -155,7 +155,7 @@ inline CSid &CSid::operator=(_In_ const SID &rhs) throw(...)
 
 inline bool CSid::LoadAccount(
 	_In_z_ LPCTSTR pszAccountName,
-	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...)
+	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) noexcept(false)
 {
     Clear();
 
@@ -218,7 +218,7 @@ inline bool CSid::LoadAccount(
 
 inline bool CSid::LoadAccount(
 	_In_ const SID *pSid,
-	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) throw(...)
+	_In_opt_z_ LPCTSTR pszSystem /* = NULL */) noexcept(false)
 {
     Clear();
 	ATLASSERT(pSid);
@@ -240,21 +240,21 @@ inline bool CSid::LoadAccount(
 	return false;
 }
 
-inline LPCTSTR CSid::AccountName() const throw(...)
+inline LPCTSTR CSid::AccountName() const noexcept(false)
 {
 	if(m_strAccountName.IsEmpty())
 		GetAccountNameAndDomain();
 	return m_strAccountName;
 }
 
-inline LPCTSTR CSid::Domain() const throw(...)
+inline LPCTSTR CSid::Domain() const noexcept(false)
 {
 	if(m_strDomain.IsEmpty())
 		GetAccountNameAndDomain();
 	return m_strDomain;
 }
 
-inline LPCTSTR CSid::Sid() const throw(...)
+inline LPCTSTR CSid::Sid() const noexcept(false)
 {
 	_ATLTRY
 	{
@@ -310,12 +310,12 @@ inline LPCTSTR CSid::Sid() const throw(...)
 	}
 }
 
-inline const SID *CSid::GetPSID() const throw(...)
+inline const SID *CSid::GetPSID() const noexcept(false)
 {
 	return _GetPSID();
 }
 
-inline CSid::operator const SID *() const throw(...)
+inline CSid::operator const SID *() const noexcept(false)
 {
 	return GetPSID();
 }
@@ -384,7 +384,7 @@ inline void CSid::Clear() throw()
 	m_bValid = false;
 }
 
-inline void CSid::Copy(_In_ const SID &rhs) throw(...)
+inline void CSid::Copy(_In_ const SID &rhs) noexcept(false)
 {
 	// This function assumes everything is cleaned up/initialized
 	// (with the exception of m_strSystem).
@@ -414,7 +414,7 @@ inline void CSid::Copy(_In_ const SID &rhs) throw(...)
 	}
 }
 
-inline void CSid::GetAccountNameAndDomain() const throw(...)
+inline void CSid::GetAccountNameAndDomain() const noexcept(false)
 {
 	static const DWORD dwMax = 32;
 	DWORD cbName = dwMax, cbDomain = dwMax;
@@ -541,7 +541,7 @@ inline bool operator>=(
 
 namespace Sids
 {
-__declspec(selectany) extern const SID_IDENTIFIER_AUTHORITY
+extern __declspec(selectany) const SID_IDENTIFIER_AUTHORITY
 	SecurityNullSidAuthority		= SECURITY_NULL_SID_AUTHORITY,
 	SecurityWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
 	SecurityLocalSidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
@@ -550,138 +550,138 @@ __declspec(selectany) extern const SID_IDENTIFIER_AUTHORITY
 	SecurityNTAuthority				= SECURITY_NT_AUTHORITY;
 
 // Universal
-inline CSid Null() throw(...)
+inline CSid Null() noexcept(false)
 {
 	return CSid(SecurityNullSidAuthority, 1, SECURITY_NULL_RID);
 }
-inline CSid World() throw(...)
+inline CSid World() noexcept(false)
 {
 	return CSid(SecurityWorldSidAuthority, 1, SECURITY_WORLD_RID);
 }
-inline CSid Local() throw(...)
+inline CSid Local() noexcept(false)
 {
 	return CSid(SecurityLocalSidAuthority, 1, SECURITY_LOCAL_RID);
 }
-inline CSid CreatorOwner() throw(...)
+inline CSid CreatorOwner() noexcept(false)
 {
 	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_RID);
 }
-inline CSid CreatorGroup() throw(...)
+inline CSid CreatorGroup() noexcept(false)
 {
 	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_RID);
 }
-inline CSid CreatorOwnerServer() throw(...)
+inline CSid CreatorOwnerServer() noexcept(false)
 {
 	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_SERVER_RID);
 }
-inline CSid CreatorGroupServer() throw(...)
+inline CSid CreatorGroupServer() noexcept(false)
 {
 	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_SERVER_RID);
 }
 
 // NT Authority
-inline CSid Dialup() throw(...)
+inline CSid Dialup() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_DIALUP_RID);
 }
-inline CSid Network() throw(...)
+inline CSid Network() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_RID);
 }
-inline CSid Batch() throw(...)
+inline CSid Batch() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_BATCH_RID);
 }
-inline CSid Interactive() throw(...)
+inline CSid Interactive() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_INTERACTIVE_RID);
 }
-inline CSid Service() throw(...)
+inline CSid Service() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_SERVICE_RID);
 }
-inline CSid AnonymousLogon() throw(...)
+inline CSid AnonymousLogon() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_ANONYMOUS_LOGON_RID);
 }
-inline CSid Proxy() throw(...)
+inline CSid Proxy() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_PROXY_RID);
 }
-inline CSid ServerLogon() throw(...)
+inline CSid ServerLogon() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_SERVER_LOGON_RID);
 }
-inline CSid Self() throw(...)
+inline CSid Self() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_PRINCIPAL_SELF_RID);
 }
-inline CSid AuthenticatedUser() throw(...)
+inline CSid AuthenticatedUser() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_AUTHENTICATED_USER_RID);
 }
-inline CSid RestrictedCode() throw(...)
+inline CSid RestrictedCode() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_RESTRICTED_CODE_RID);
 }
-inline CSid TerminalServer() throw(...)
+inline CSid TerminalServer() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_TERMINAL_SERVER_RID);
 }
-inline CSid System() throw(...)
+inline CSid System() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_LOCAL_SYSTEM_RID);
 }
 
 
-inline CSid NetworkService() throw(...)
+inline CSid NetworkService() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_SERVICE_RID);
 
 }
 
 // NT Authority\BUILTIN
-inline CSid Admins() throw(...)
+inline CSid Admins() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS);
 }
-inline CSid Users() throw(...)
+inline CSid Users() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS);
 }
-inline CSid Guests() throw(...)
+inline CSid Guests() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS);
 }
-inline CSid PowerUsers() throw(...)
+inline CSid PowerUsers() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS);
 }
-inline CSid AccountOps() throw(...)
+inline CSid AccountOps() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ACCOUNT_OPS);
 }
-inline CSid SystemOps() throw(...)
+inline CSid SystemOps() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS);
 }
-inline CSid PrintOps() throw(...)
+inline CSid PrintOps() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PRINT_OPS);
 }
-inline CSid BackupOps() throw(...)
+inline CSid BackupOps() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_BACKUP_OPS);
 }
-inline CSid Replicator() throw(...)
+inline CSid Replicator() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_REPLICATOR);
 }
-inline CSid RasServers() throw(...)
+inline CSid RasServers() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_RAS_SERVERS);
 }
-inline CSid PreW2KAccess() throw(...)
+inline CSid PreW2KAccess() noexcept(false)
 {
 	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS);
 }
@@ -702,14 +702,14 @@ inline CAcl::~CAcl() throw()
 	free(m_pAcl);
 }
 
-inline CAcl::CAcl(_In_ const CAcl &rhs) throw(...) :
+inline CAcl::CAcl(_In_ const CAcl &rhs) noexcept(false) :
 	m_pAcl(NULL),
 	m_bNull(rhs.m_bNull),
 	m_dwAclRevision(rhs.m_dwAclRevision)
 {
 }
 
-inline CAcl &CAcl::operator=(_In_ const CAcl &rhs) throw(...)
+inline CAcl &CAcl::operator=(_In_ const CAcl &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -725,7 +725,7 @@ inline void CAcl::GetAclEntries(
 	_Out_ CSid::CSidArray *pSids,
 	_Out_opt_ CAccessMaskArray *pAccessMasks /* = NULL */,
 	_Out_opt_ CAceTypeArray *pAceTypes /* = NULL */,
-	_Out_opt_ CAceFlagArray *pAceFlags /* = NULL */) const throw(...)
+	_Out_opt_ CAceFlagArray *pAceFlags /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pSids);
 	if(pSids)
@@ -762,7 +762,7 @@ inline void CAcl::GetAclEntry(
 	_Out_opt_ BYTE* pType /* = NULL */,
 	_Out_opt_ BYTE* pFlags /* = NULL */,
 	_Out_opt_ GUID* pObjectType /* = NULL */,
-	_Out_opt_ GUID* pInheritedObjectType /* = NULL */) const throw(...)
+	_Out_opt_ GUID* pInheritedObjectType /* = NULL */) const noexcept(false)
 {
 	const CAce* pAce = GetAce(nIndex);
 
@@ -780,7 +780,7 @@ inline void CAcl::GetAclEntry(
 		*pInheritedObjectType = pAce->InheritedObjectType();
 }
 
-inline bool CAcl::RemoveAces(_In_ const CSid &rSid) throw(...)
+inline bool CAcl::RemoveAces(_In_ const CSid &rSid) noexcept(false)
 {
 	ATLASSERT(rSid.IsValid());
 	if (!rSid.IsValid())
@@ -811,7 +811,7 @@ inline bool CAcl::RemoveAces(_In_ const CSid &rSid) throw(...)
 	return bRet;
 }
 
-inline const ACL *CAcl::GetPACL() const throw(...)
+inline const ACL *CAcl::GetPACL() const noexcept(false)
 {
 	if(!m_pAcl && !m_bNull)
 	{
@@ -861,12 +861,12 @@ inline const ACL *CAcl::GetPACL() const throw(...)
 	return m_pAcl;
 }
 
-inline CAcl::operator const ACL *() const throw(...)
+inline CAcl::operator const ACL *() const noexcept(false)
 {
 	return GetPACL();
 }
 
-inline UINT CAcl::GetLength() const throw(...)
+inline UINT CAcl::GetLength() const noexcept(false)
 {
 	ACL *pAcl = const_cast<ACL *>(GetPACL());
 	ACL_SIZE_INFORMATION AclSize;
@@ -917,7 +917,7 @@ inline void CAcl::PrepareAcesForACL() const throw()
 inline CAcl::CAce::CAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
-		_In_ BYTE aceflags) throw(...) :
+		_In_ BYTE aceflags) noexcept(false) :
 	m_dwAccessMask(accessmask),
 	m_sid(rSid),
 	m_aceflags(aceflags),
@@ -934,7 +934,7 @@ inline CAcl::CAce::~CAce() throw()
 	}
 }
 
-inline CAcl::CAce::CAce(_In_ const CAce &rhs) throw(...) :
+inline CAcl::CAce::CAce(_In_ const CAce &rhs) noexcept(false) :
 	m_sid(rhs.m_sid),
 	m_dwAccessMask(rhs.m_dwAccessMask),
 	m_aceflags(rhs.m_aceflags),
@@ -942,7 +942,7 @@ inline CAcl::CAce::CAce(_In_ const CAce &rhs) throw(...) :
 {
 }
 
-inline CAcl::CAce &CAcl::CAce::operator=(_In_ const CAce &rhs) throw(...)
+inline CAcl::CAce &CAcl::CAce::operator=(_In_ const CAce &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -1010,12 +1010,12 @@ inline CDacl::~CDacl() throw()
 	CDacl::RemoveAllAces();
 }
 
-inline CDacl::CDacl(_In_ const CDacl &rhs) throw(...)
+inline CDacl::CDacl(_In_ const CDacl &rhs) noexcept(false)
 {
 	Copy(rhs);
 }
 
-inline CDacl &CDacl::operator=(_In_ const CDacl &rhs) throw(...)
+inline CDacl &CDacl::operator=(_In_ const CDacl &rhs) noexcept(false)
 {
 	if (this != &rhs)
 	{
@@ -1026,12 +1026,12 @@ inline CDacl &CDacl::operator=(_In_ const CDacl &rhs) throw(...)
 	return *this;
 }
 
-inline CDacl::CDacl(_In_ const ACL &rhs) throw(...)
+inline CDacl::CDacl(_In_ const ACL &rhs) noexcept(false)
 {
 	Copy(rhs);
 }
 
-inline CDacl &CDacl::operator=(_In_ const ACL &rhs) throw(...)
+inline CDacl &CDacl::operator=(_In_ const ACL &rhs) noexcept(false)
 {
 	RemoveAllAces();
 
@@ -1042,7 +1042,7 @@ inline CDacl &CDacl::operator=(_In_ const ACL &rhs) throw(...)
 inline bool CDacl::AddAllowedAce(
 	_In_ const CSid &rSid,
 	_In_ ACCESS_MASK accessmask,
-	_In_ BYTE aceflags /* = 0 */) throw(...)
+	_In_ BYTE aceflags /* = 0 */) noexcept(false)
 {
 	ATLASSERT(rSid.IsValid());
 	if(!rSid.IsValid())
@@ -1065,7 +1065,7 @@ inline bool CDacl::AddAllowedAce(
 inline bool CDacl::AddDeniedAce(
 	_In_ const CSid &rSid,
 	_In_ ACCESS_MASK accessmask,
-	_In_ BYTE aceflags /* = 0 */) throw(...)
+	_In_ BYTE aceflags /* = 0 */) noexcept(false)
 {
 	ATLASSERT(rSid.IsValid());
 	if(!rSid.IsValid())
@@ -1091,7 +1091,7 @@ inline bool CDacl::AddAllowedAce(
 	_In_ ACCESS_MASK accessmask,
 	_In_ BYTE aceflags,
 	_In_ const GUID *pObjectType,
-	_In_ const GUID *pInheritedObjectType) throw(...)
+	_In_ const GUID *pInheritedObjectType) noexcept(false)
 {
 	if(!pObjectType && !pInheritedObjectType)
 		return AddAllowedAce(rSid, accessmask, aceflags);
@@ -1123,7 +1123,7 @@ inline bool CDacl::AddDeniedAce(
 	_In_ ACCESS_MASK accessmask,
 	_In_ BYTE aceflags,
 	_In_ const GUID *pObjectType,
-	_In_ const GUID *pInheritedObjectType) throw(...)
+	_In_ const GUID *pInheritedObjectType) noexcept(false)
 {
 	if(!pObjectType && !pInheritedObjectType)
 		return AddDeniedAce(rSid, accessmask, aceflags);
@@ -1165,7 +1165,7 @@ inline UINT CDacl::GetAceCount() const throw()
 	return (UINT) m_acl.GetCount();
 }
 
-inline void CDacl::Copy(_In_ const CDacl &rhs) throw(...)
+inline void CDacl::Copy(_In_ const CDacl &rhs) noexcept(false)
 {
 	CSid sid;
 	ACCESS_MASK accessmask;
@@ -1234,7 +1234,7 @@ inline void CDacl::Copy(_In_ const CDacl &rhs) throw(...)
 	}
 }
 
-inline void CDacl::Copy(_In_ const ACL &rhs) throw(...)
+inline void CDacl::Copy(_In_ const ACL &rhs) noexcept(false)
 {
 	ACL *pAcl = const_cast<ACL *>(&rhs);
 	if (pAcl == NULL)
@@ -1366,7 +1366,7 @@ inline CDacl::CAccessAce::CAccessAce(
 		_In_ const CSid &rSid,
 		_In_ ACCESS_MASK accessmask,
 		_In_ BYTE aceflags,
-		_In_ bool bAllowAccess) throw(...) :
+		_In_ bool bAllowAccess) noexcept(false) :
 	CAce(rSid, accessmask, aceflags),
 	m_bAllow(bAllowAccess)
 {
@@ -1376,7 +1376,7 @@ inline CDacl::CAccessAce::~CAccessAce() throw()
 {
 }
 
-inline void *CDacl::CAccessAce::GetACE() const throw(...)
+inline void *CDacl::CAccessAce::GetACE() const noexcept(false)
 {
 	C_ASSERT(sizeof(ACCESS_ALLOWED_ACE) == sizeof(ACCESS_DENIED_ACE));
 	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Header)==offsetof(ACCESS_DENIED_ACE, Header));
@@ -1475,7 +1475,7 @@ inline CDacl::CAccessObjectAce::CAccessObjectAce(
 		_In_ BYTE aceflags,
 		_In_ bool bAllowAccess,
 		_In_opt_ const GUID *pObjectType,
-		_In_opt_ const GUID *pInheritedObjectType) throw(...) :
+		_In_opt_ const GUID *pInheritedObjectType) noexcept(false) :
 	CAccessAce(rSid, accessmask, aceflags, bAllowAccess),
 	m_pObjectType(NULL),
 	m_pInheritedObjectType(NULL)
@@ -1499,13 +1499,13 @@ inline CDacl::CAccessObjectAce::CAccessObjectAce(
 	}
 }
 
-inline CDacl::CAccessObjectAce::~CAccessObjectAce() throw()
+inline CDacl::CAccessObjectAce::~CAccessObjectAce() noexcept(false)
 {
 	delete m_pObjectType;
 	delete m_pInheritedObjectType;
 }
 
-inline CDacl::CAccessObjectAce::CAccessObjectAce(_In_ const CAccessObjectAce &rhs) throw(...) :
+inline CDacl::CAccessObjectAce::CAccessObjectAce(_In_ const CAccessObjectAce &rhs) noexcept(false) :
 	CAccessAce(rhs),
 	m_pObjectType(NULL),
 	m_pInheritedObjectType(NULL)
@@ -1514,7 +1514,7 @@ inline CDacl::CAccessObjectAce::CAccessObjectAce(_In_ const CAccessObjectAce &rh
 }
 
 inline CDacl::CAccessObjectAce &CDacl::CAccessObjectAce::operator=(
-	_In_ const CAccessObjectAce &rhs) throw(...)
+	_In_ const CAccessObjectAce &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -1559,7 +1559,7 @@ inline CDacl::CAccessObjectAce &CDacl::CAccessObjectAce::operator=(
 	return *this;
 }
 
-inline void *CDacl::CAccessObjectAce::GetACE() const throw(...)
+inline void *CDacl::CAccessObjectAce::GetACE() const noexcept(false)
 {
 	C_ASSERT(sizeof(ACCESS_ALLOWED_OBJECT_ACE) == sizeof(ACCESS_DENIED_OBJECT_ACE));
 	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Header)==offsetof(ACCESS_DENIED_OBJECT_ACE, Header));
@@ -1666,12 +1666,12 @@ inline CSacl::~CSacl() throw()
 	CSacl::RemoveAllAces();
 }
 
-inline CSacl::CSacl(_In_ const CSacl &rhs) throw(...)
+inline CSacl::CSacl(_In_ const CSacl &rhs) noexcept(false)
 {
 	Copy(rhs);
 }
 
-inline CSacl &CSacl::operator=(_In_ const CSacl &rhs) throw(...)
+inline CSacl &CSacl::operator=(_In_ const CSacl &rhs) noexcept(false)
 {
 	if (this != &rhs)
 	{
@@ -1682,12 +1682,12 @@ inline CSacl &CSacl::operator=(_In_ const CSacl &rhs) throw(...)
 	return *this;
 }
 
-inline CSacl::CSacl(_In_ const ACL &rhs) throw(...)
+inline CSacl::CSacl(_In_ const ACL &rhs) noexcept(false)
 {
 	Copy(rhs);
 }
 
-inline CSacl &CSacl::operator=(_In_ const ACL &rhs) throw(...)
+inline CSacl &CSacl::operator=(_In_ const ACL &rhs) noexcept(false)
 {
 	RemoveAllAces();
 
@@ -1700,7 +1700,7 @@ inline bool CSacl::AddAuditAce(
 	_In_ ACCESS_MASK accessmask,
 	_In_ bool bSuccess,
 	_In_ bool bFailure,
-	_In_ BYTE aceflags /* = 0 */) throw(...)
+	_In_ BYTE aceflags /* = 0 */) noexcept(false)
 {
 	ATLASSERT(rSid.IsValid());
 	if(!rSid.IsValid())
@@ -1728,7 +1728,7 @@ inline bool CSacl::AddAuditAce(
 	_In_ bool bFailure,
 	_In_ BYTE aceflags,
 	_In_ const GUID *pObjectType,
-	_In_ const GUID *pInheritedObjectType) throw(...)
+	_In_ const GUID *pInheritedObjectType) noexcept(false)
 {
 	if(!pObjectType && !pInheritedObjectType)
 		return AddAuditAce(rSid, accessmask, bSuccess, bFailure, aceflags);
@@ -1769,7 +1769,7 @@ inline UINT CSacl::GetAceCount() const throw()
 	return (UINT) m_acl.GetCount();
 }
 
-inline void CSacl::Copy(_In_ const CSacl &rhs) throw(...)
+inline void CSacl::Copy(_In_ const CSacl &rhs) noexcept(false)
 {
 	CSid sid;
 	ACCESS_MASK accessmask;
@@ -1842,7 +1842,7 @@ inline void CSacl::Copy(_In_ const CSacl &rhs) throw(...)
 	}
 }
 
-inline void CSacl::Copy(_In_ const ACL &rhs) throw(...)
+inline void CSacl::Copy(_In_ const ACL &rhs) noexcept(false)
 {
 	ACL *pAcl = const_cast<ACL *>(&rhs);
 	ACL_SIZE_INFORMATION aclsizeinfo;
@@ -1942,7 +1942,7 @@ inline CSacl::CAuditAce::CAuditAce(
 		_In_ ACCESS_MASK accessmask,
 		_In_ BYTE aceflags,
 		_In_ bool bAuditSuccess,
-		_In_ bool bAuditFailure) throw(...) :
+		_In_ bool bAuditFailure) noexcept(false) :
 	CAce(rSid, accessmask, aceflags),
 	m_bSuccess(bAuditSuccess),
 	m_bFailure(bAuditFailure)
@@ -1957,7 +1957,7 @@ inline CSacl::CAuditAce::~CAuditAce() throw()
 {
 }
 
-inline void *CSacl::CAuditAce::GetACE() const throw(...)
+inline void *CSacl::CAuditAce::GetACE() const noexcept(false)
 {
 	if(!m_pAce)
 	{
@@ -2002,7 +2002,7 @@ inline CSacl::CAuditObjectAce::CAuditObjectAce(
 		_In_ bool bAuditSuccess,
 		_In_ bool bAuditFailure,
 		_In_opt_ const GUID *pObjectType,
-		_In_opt_ const GUID *pInheritedObjectType) throw(...) :
+		_In_opt_ const GUID *pInheritedObjectType) noexcept(false) :
 	CAuditAce(rSid, accessmask, aceflags, bAuditSuccess, bAuditFailure),
 	m_pObjectType(NULL),
 	m_pInheritedObjectType(NULL)
@@ -2026,13 +2026,13 @@ inline CSacl::CAuditObjectAce::CAuditObjectAce(
 	}
 }
 
-inline CSacl::CAuditObjectAce::~CAuditObjectAce() throw()
+inline CSacl::CAuditObjectAce::~CAuditObjectAce() noexcept(false)
 {
 	delete m_pObjectType;
 	delete m_pInheritedObjectType;
 }
 
-inline CSacl::CAuditObjectAce::CAuditObjectAce(_In_ const CAuditObjectAce &rhs) throw(...) :
+inline CSacl::CAuditObjectAce::CAuditObjectAce(_In_ const CAuditObjectAce &rhs) noexcept(false) :
 	CAuditAce(rhs),
 	m_pObjectType(NULL),
 	m_pInheritedObjectType(NULL)
@@ -2041,7 +2041,7 @@ inline CSacl::CAuditObjectAce::CAuditObjectAce(_In_ const CAuditObjectAce &rhs)
 }
 
 inline CSacl::CAuditObjectAce &CSacl::CAuditObjectAce::operator=(
-	_In_ const CAuditObjectAce &rhs) throw(...)
+	_In_ const CAuditObjectAce &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -2086,7 +2086,7 @@ inline CSacl::CAuditObjectAce &CSacl::CAuditObjectAce::operator=(
 	return *this;
 }
 
-inline void *CSacl::CAuditObjectAce::GetACE() const throw(...)
+inline void *CSacl::CAuditObjectAce::GetACE() const noexcept(false)
 {
 	if(!m_pAce)
 	{
@@ -2196,7 +2196,7 @@ inline CSecurityDesc::~CSecurityDesc() throw()
 }
 
 inline CSecurityDesc::CSecurityDesc(
-		_In_ const CSecurityDesc &rhs) throw(...)
+		_In_ const CSecurityDesc &rhs) noexcept(false)
 	: m_pSecurityDescriptor(NULL)
 {
 	if(rhs.m_pSecurityDescriptor)
@@ -2204,7 +2204,7 @@ inline CSecurityDesc::CSecurityDesc(
 }
 
 inline CSecurityDesc &CSecurityDesc::operator=(
-	_In_ const CSecurityDesc &rhs) throw(...)
+	_In_ const CSecurityDesc &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -2216,14 +2216,14 @@ inline CSecurityDesc &CSecurityDesc::operator=(
 }
 
 inline CSecurityDesc::CSecurityDesc(
-		_In_ const SECURITY_DESCRIPTOR &rhs) throw(...) :
+		_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false) :
 	m_pSecurityDescriptor(NULL)
 {
 	Init(rhs);
 }
 
 inline CSecurityDesc &CSecurityDesc::operator=(
-	_In_ const SECURITY_DESCRIPTOR &rhs) throw(...)
+	_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false)
 {
 	if(m_pSecurityDescriptor != &rhs)
 	{
@@ -2234,7 +2234,7 @@ inline CSecurityDesc &CSecurityDesc::operator=(
 }
 
 #if(_WIN32_WINNT >= 0x0500)
-inline bool CSecurityDesc::FromString(_In_z_ LPCTSTR pstr) throw(...)
+inline bool CSecurityDesc::FromString(_In_z_ LPCTSTR pstr) noexcept(false)
 {
 	SECURITY_DESCRIPTOR *pSD;
 	if(!::ConvertStringSecurityDescriptorToSecurityDescriptor(pstr, SDDL_REVISION_1,
@@ -2253,7 +2253,7 @@ inline bool CSecurityDesc::ToString(
 		OWNER_SECURITY_INFORMATION |
 		GROUP_SECURITY_INFORMATION |
 		DACL_SECURITY_INFORMATION |
-		SACL_SECURITY_INFORMATION */) const throw(...)
+		SACL_SECURITY_INFORMATION */) const noexcept(false)
 {
 	ATLASSERT(pstr);
 	if(!pstr || !m_pSecurityDescriptor)
@@ -2284,7 +2284,7 @@ inline bool CSecurityDesc::ToString(
 
 inline void CSecurityDesc::SetOwner(
 	_In_ const CSid &sid,
-	_In_ bool bDefaulted /* = false */) throw(...)
+	_In_ bool bDefaulted /* = false */) noexcept(false)
 {
 	if(m_pSecurityDescriptor)
 		MakeAbsolute();
@@ -2323,7 +2323,7 @@ inline void CSecurityDesc::SetOwner(
 
 inline void CSecurityDesc::SetGroup(
 	_In_ const CSid &sid,
-	_In_ bool bDefaulted /* = false */) throw(...)
+	_In_ bool bDefaulted /* = false */) noexcept(false)
 {
 	if(m_pSecurityDescriptor)
 		MakeAbsolute();
@@ -2362,7 +2362,7 @@ inline void CSecurityDesc::SetGroup(
 
 inline void CSecurityDesc::SetDacl(
 	_In_ const CDacl &Dacl,
-	_In_ bool bDefaulted /* = false */) throw(...)
+	_In_ bool bDefaulted /* = false */) noexcept(false)
 {
 	if(m_pSecurityDescriptor)
 		MakeAbsolute();
@@ -2412,7 +2412,7 @@ inline void CSecurityDesc::SetDacl(
 
 inline void CSecurityDesc::SetDacl(
 	_In_ bool bPresent,
-	_In_ bool bDefaulted /* = false */) throw(...)
+	_In_ bool bDefaulted /* = false */) noexcept(false)
 {
 	if(m_pSecurityDescriptor)
 		MakeAbsolute();
@@ -2444,7 +2444,7 @@ inline void CSecurityDesc::SetDacl(
 
 inline void CSecurityDesc::SetSacl(
 	_In_ const CSacl &Sacl,
-	_In_ bool bDefaulted /* = false */) throw(...)
+	_In_ bool bDefaulted /* = false */) noexcept(false)
 {
 	if(m_pSecurityDescriptor)
 		MakeAbsolute();
@@ -2485,7 +2485,7 @@ inline void CSecurityDesc::SetSacl(
 
 inline bool CSecurityDesc::GetOwner(
 	_Out_ CSid *pSid,
-	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
+	_Out_opt_ bool *pbDefaulted /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pSid);
 	SID *pOwner;
@@ -2507,7 +2507,7 @@ inline bool CSecurityDesc::GetOwner(
 
 inline bool CSecurityDesc::GetGroup(
 	_Out_ CSid *pSid,
-	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
+	_Out_opt_ bool *pbDefaulted /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pSid);
 	SID *pGroup;
@@ -2530,7 +2530,7 @@ inline bool CSecurityDesc::GetGroup(
 inline bool CSecurityDesc::GetDacl(
 	_Out_ CDacl *pDacl,
 	_Out_opt_ bool *pbPresent /* = NULL */,
-	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
+	_Out_opt_ bool *pbDefaulted /* = NULL */) const noexcept(false)
 {
 	ACL *pAcl;
 	BOOL bPresent, bDefaulted;
@@ -2566,7 +2566,7 @@ inline bool CSecurityDesc::GetDacl(
 inline bool CSecurityDesc::GetSacl(
 	_Out_ CSacl *pSacl,
 	_Out_opt_ bool *pbPresent /* = NULL */,
-	_Out_opt_ bool *pbDefaulted /* = NULL */) const throw(...)
+	_Out_opt_ bool *pbDefaulted /* = NULL */) const noexcept(false)
 {
 	ACL *pAcl;
 	BOOL bPresent, bDefaulted;
@@ -2712,7 +2712,7 @@ inline CSecurityDesc::operator const SECURITY_DESCRIPTOR *() const throw()
 
 inline void CSecurityDesc::GetSECURITY_DESCRIPTOR(
 	_Out_ SECURITY_DESCRIPTOR *pSD,
-	_Inout_ LPDWORD lpdwBufferLength) throw(...)
+	_Inout_ LPDWORD lpdwBufferLength) noexcept(false)
 {
 	ATLASSERT(lpdwBufferLength && m_pSecurityDescriptor);
 	if(!lpdwBufferLength)
@@ -2763,7 +2763,7 @@ inline bool CSecurityDesc::SetControl(
 }
 #endif
 
-inline void CSecurityDesc::MakeSelfRelative() throw(...)
+inline void CSecurityDesc::MakeSelfRelative() noexcept(false)
 {
 	SECURITY_DESCRIPTOR_CONTROL sdc;
 	if(!m_pSecurityDescriptor)
@@ -2797,7 +2797,7 @@ inline void CSecurityDesc::MakeSelfRelative() throw(...)
 	m_pSecurityDescriptor = pSD;
 }
 
-inline void CSecurityDesc::MakeAbsolute() throw(...)
+inline void CSecurityDesc::MakeAbsolute() noexcept(false)
 {
 	SECURITY_DESCRIPTOR_CONTROL sdc;
 	if(!m_pSecurityDescriptor)
@@ -2893,7 +2893,7 @@ inline void CSecurityDesc::Clear() throw()
 	}
 }
 
-inline void CSecurityDesc::AllocateAndInitializeSecurityDescriptor() throw(...)
+inline void CSecurityDesc::AllocateAndInitializeSecurityDescriptor() noexcept(false)
 {
 	// m_pSecurityDescriptor should be NULL.
 	ATLASSERT(!m_pSecurityDescriptor);
@@ -2911,7 +2911,7 @@ inline void CSecurityDesc::AllocateAndInitializeSecurityDescriptor() throw(...)
 	}
 }
 
-inline void CSecurityDesc::Init(_In_ const SECURITY_DESCRIPTOR &rhs) throw(...)
+inline void CSecurityDesc::Init(_In_ const SECURITY_DESCRIPTOR &rhs) noexcept(false)
 {
 	SECURITY_DESCRIPTOR *pSD = const_cast<SECURITY_DESCRIPTOR *>(&rhs);
 	DWORD dwRev, dwLen = ::GetSecurityDescriptorLength(pSD);
@@ -2957,7 +2957,7 @@ inline CSecurityAttributes::CSecurityAttributes() throw()
 
 inline CSecurityAttributes::CSecurityAttributes(
 		_In_ const CSecurityDesc &rSecurityDescriptor,
-		_In_ bool bInheritHandle /* = false */) throw(...) :
+		_In_ bool bInheritHandle /* = false */) noexcept(false) :
 	m_SecurityDescriptor(rSecurityDescriptor)
 {
 	Set(m_SecurityDescriptor, bInheritHandle);
@@ -2965,7 +2965,7 @@ inline CSecurityAttributes::CSecurityAttributes(
 
 inline void CSecurityAttributes::Set(
 	_In_ const CSecurityDesc &rSecurityDescriptor,
-	_In_ bool bInheritHandle /* = false */) throw(...)
+	_In_ bool bInheritHandle /* = false */) noexcept(false)
 {
 	m_SecurityDescriptor = rSecurityDescriptor;
 	nLength = sizeof(SECURITY_ATTRIBUTES);
@@ -2989,7 +2989,7 @@ inline CTokenPrivileges::~CTokenPrivileges() throw()
 }
 
 inline CTokenPrivileges::CTokenPrivileges(
-		_In_ const CTokenPrivileges &rhs) throw(...) :
+		_In_ const CTokenPrivileges &rhs) noexcept(false) :
 	m_pTokenPrivileges(NULL),
 	m_bDirty(true)
 {
@@ -3003,7 +3003,7 @@ inline CTokenPrivileges::CTokenPrivileges(
 }
 
 inline CTokenPrivileges &CTokenPrivileges::operator=(
-	_In_ const CTokenPrivileges &rhs) throw(...)
+	_In_ const CTokenPrivileges &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -3022,14 +3022,14 @@ inline CTokenPrivileges &CTokenPrivileges::operator=(
 }
 
 inline CTokenPrivileges::CTokenPrivileges(
-		_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...) :
+		_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false) :
 	m_pTokenPrivileges(NULL)
 {
 	AddPrivileges(rPrivileges);
 }
 
 inline CTokenPrivileges &CTokenPrivileges::operator=(
-	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
+	_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false)
 {
 	m_mapTokenPrivileges.RemoveAll();
 	AddPrivileges(rPrivileges);
@@ -3037,14 +3037,14 @@ inline CTokenPrivileges &CTokenPrivileges::operator=(
 }
 
 inline void CTokenPrivileges::Add(
-	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
+	_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false)
 {
 	AddPrivileges(rPrivileges);
 }
 
 inline bool CTokenPrivileges::Add(
 	_In_z_ LPCTSTR pszPrivilege,
-	_In_ bool bEnable) throw(...)
+	_In_ bool bEnable) noexcept(false)
 {
 	LUID_AND_ATTRIBUTES la;
 	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &la.Luid))
@@ -3060,7 +3060,7 @@ inline bool CTokenPrivileges::Add(
 
 inline bool CTokenPrivileges::LookupPrivilege(
 	_In_z_ LPCTSTR pszPrivilege,
-	_Out_opt_ DWORD *pdwAttributes /* = NULL */) const throw(...)
+	_Out_opt_ DWORD *pdwAttributes /* = NULL */) const noexcept(false)
 {
 	DWORD dwAttributes;
 	LUID luid;
@@ -3079,7 +3079,7 @@ inline bool CTokenPrivileges::LookupPrivilege(
 
 inline void CTokenPrivileges::GetNamesAndAttributes(
 	_Inout_ CNames *pNames,
-	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const throw(...)
+	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pNames);
 	if(pNames)
@@ -3136,7 +3136,7 @@ inline void CTokenPrivileges::GetNamesAndAttributes(
 }
 
 inline void CTokenPrivileges::GetDisplayNames(
-	_Inout_ CNames *pDisplayNames) const throw(...)
+	_Inout_ CNames *pDisplayNames) const noexcept(false)
 {
 	ATLASSERT(pDisplayNames);
 	if(pDisplayNames)
@@ -3185,7 +3185,7 @@ inline void CTokenPrivileges::GetDisplayNames(
 
 inline void CTokenPrivileges::GetLuidsAndAttributes(
 	_Inout_ CLUIDArray *pLuids,
-	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const throw(...)
+	_Inout_opt_ CAttributes *pAttributes /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pLuids);
 	if(pLuids)
@@ -3236,7 +3236,7 @@ inline UINT CTokenPrivileges::GetLength() const throw()
 	return offsetof(TOKEN_PRIVILEGES, Privileges) + sizeof(LUID_AND_ATTRIBUTES) * GetCount();
 }
 
-inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const throw(...)
+inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const noexcept(false)
 {
 	if(m_bDirty)
 	{
@@ -3267,13 +3267,13 @@ inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const th
 	return m_pTokenPrivileges;
 }
 
-inline CTokenPrivileges::operator const TOKEN_PRIVILEGES *() const throw(...)
+inline CTokenPrivileges::operator const TOKEN_PRIVILEGES *() const noexcept(false)
 {
 	return GetPTOKEN_PRIVILEGES();
 }
 
 inline void CTokenPrivileges::AddPrivileges(
-	_In_ const TOKEN_PRIVILEGES &rPrivileges) throw(...)
+	_In_ const TOKEN_PRIVILEGES &rPrivileges) noexcept(false)
 {
 	m_bDirty = true;
 	for(UINT i = 0; i < rPrivileges.PrivilegeCount; i++)
@@ -3300,7 +3300,7 @@ inline CTokenGroups::~CTokenGroups() throw()
 }
 
 inline CTokenGroups::CTokenGroups(
-		_In_ const CTokenGroups &rhs) throw(...) :
+		_In_ const CTokenGroups &rhs) noexcept(false) :
 	m_pTokenGroups(NULL),
 	m_bDirty(true)
 {
@@ -3314,7 +3314,7 @@ inline CTokenGroups::CTokenGroups(
 }
 
 inline CTokenGroups &CTokenGroups::operator=(
-	_In_ const CTokenGroups &rhs) throw(...)
+	_In_ const CTokenGroups &rhs) noexcept(false)
 {
 	if(this != &rhs)
 	{
@@ -3333,14 +3333,14 @@ inline CTokenGroups &CTokenGroups::operator=(
 }
 
 inline CTokenGroups::CTokenGroups(
-		_In_ const TOKEN_GROUPS &rhs) throw(...) :
+		_In_ const TOKEN_GROUPS &rhs) noexcept(false) :
 	m_pTokenGroups(NULL)
 {
 	AddTokenGroups(rhs);
 }
 
 inline CTokenGroups &CTokenGroups::operator=(
-	_In_ const TOKEN_GROUPS &rhs) throw(...)
+	_In_ const TOKEN_GROUPS &rhs) noexcept(false)
 {
 	m_mapTokenGroups.RemoveAll();
 	AddTokenGroups(rhs);
@@ -3348,14 +3348,14 @@ inline CTokenGroups &CTokenGroups::operator=(
 }
 
 inline void CTokenGroups::Add(
-	_In_ const TOKEN_GROUPS &rTokenGroups) throw(...)
+	_In_ const TOKEN_GROUPS &rTokenGroups) noexcept(false)
 {
 	AddTokenGroups(rTokenGroups);
 }
 
 inline void CTokenGroups::Add(
 	_In_ const CSid &rSid,
-	_In_ DWORD dwAttributes) throw(...)
+	_In_ DWORD dwAttributes) noexcept(false)
 {
 	m_mapTokenGroups.SetAt(rSid, dwAttributes);
 	m_bDirty = true;
@@ -3377,7 +3377,7 @@ inline bool CTokenGroups::LookupSid(
 
 inline void CTokenGroups::GetSidsAndAttributes(
 	_Inout_ CSid::CSidArray *pSids,
-	_Inout_opt_ CAtlArray<DWORD> *pAttributes /* = NULL */) const throw(...)
+	_Inout_opt_ CAtlArray<DWORD> *pAttributes /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pSids);
 	if(pSids)
@@ -3421,7 +3421,7 @@ inline UINT CTokenGroups::GetLength() const throw()
 	return UINT(offsetof(TOKEN_GROUPS, Groups) + sizeof(SID_AND_ATTRIBUTES) * m_mapTokenGroups.GetCount());
 }
 
-inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const throw(...)
+inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const noexcept(false)
 {
 	if(m_bDirty)
 	{
@@ -3452,13 +3452,13 @@ inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const throw(...)
 	return m_pTokenGroups;
 }
 
-inline CTokenGroups::operator const TOKEN_GROUPS *() const throw(...)
+inline CTokenGroups::operator const TOKEN_GROUPS *() const noexcept(false)
 {
 	return GetPTOKEN_GROUPS();
 }
 
 inline void CTokenGroups::AddTokenGroups(
-	_In_ const TOKEN_GROUPS &rTokenGroups) throw(...)
+	_In_ const TOKEN_GROUPS &rTokenGroups) noexcept(false)
 {
 	m_bDirty = true;
 	for(UINT i = 0; i < rTokenGroups.GroupCount; i++)
@@ -3513,7 +3513,7 @@ inline HKEY CAccessToken::HKeyCurrentUser() const throw()
 inline bool CAccessToken::EnablePrivilege(
 	_In_z_ LPCTSTR pszPrivilege,
 	_In_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
-	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) noexcept(false)
 {
 	CTokenPrivileges NewState;
 	NewState.Add(pszPrivilege, true);
@@ -3523,7 +3523,7 @@ inline bool CAccessToken::EnablePrivilege(
 inline bool CAccessToken::EnablePrivileges(
 	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
-	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) noexcept(false)
 {
 	return EnableDisablePrivileges(rPrivileges, true, pPreviousState,pbErrNotAllAssigned);
 }
@@ -3531,7 +3531,7 @@ inline bool CAccessToken::EnablePrivileges(
 inline bool CAccessToken::DisablePrivilege(
 	_In_z_ LPCTSTR pszPrivilege,
 	_In_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
-	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) noexcept(false)
 {
 	CTokenPrivileges NewState;
 	NewState.Add(pszPrivilege, false);
@@ -3541,7 +3541,7 @@ inline bool CAccessToken::DisablePrivilege(
 inline bool CAccessToken::DisablePrivileges(
 	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
-	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) noexcept(false)
 {
 	return EnableDisablePrivileges(rPrivileges, false, pPreviousState,pbErrNotAllAssigned);
 }
@@ -3549,7 +3549,7 @@ inline bool CAccessToken::DisablePrivileges(
 inline bool CAccessToken::EnableDisablePrivileges(
 	_In_ const CTokenPrivileges &rNewState,
 	_Inout_opt_ CTokenPrivileges *pPreviousState /* = NULL */,
-	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned /*=NULL*/) noexcept(false)
 {
 	if(!rNewState.GetCount())
 	{
@@ -3600,7 +3600,7 @@ inline bool CAccessToken::PrivilegeCheck(
 	return true;
 }
 
-inline bool CAccessToken::GetLogonSid(_Inout_ CSid *pSid) const throw(...)
+inline bool CAccessToken::GetLogonSid(_Inout_ CSid *pSid) const noexcept(false)
 {
 	ATLASSERT(pSid);
 	if(!pSid)
@@ -3628,7 +3628,7 @@ inline bool CAccessToken::GetLogonSid(_Inout_ CSid *pSid) const throw(...)
 	return false;
 }
 
-inline bool CAccessToken::GetTokenId(_Out_ LUID *pluid) const throw(...)
+inline bool CAccessToken::GetTokenId(_Out_ LUID *pluid) const noexcept(false)
 {
 	ATLASSERT(pluid);
 	if(!pluid)
@@ -3642,7 +3642,7 @@ inline bool CAccessToken::GetTokenId(_Out_ LUID *pluid) const throw(...)
 	return true;
 }
 
-inline bool CAccessToken::GetLogonSessionId(_Out_ LUID *pluid) const throw(...)
+inline bool CAccessToken::GetLogonSessionId(_Out_ LUID *pluid) const noexcept(false)
 {
 	ATLASSERT(pluid);
 	if(!pluid)
@@ -3658,7 +3658,7 @@ inline bool CAccessToken::GetLogonSessionId(_Out_ LUID *pluid) const throw(...)
 
 inline bool CAccessToken::CheckTokenMembership(
 	_In_ const CSid &rSid,
-	_Inout_ bool *pbIsMember) const throw(...)
+	_Inout_ bool *pbIsMember) const noexcept(false)
 {
 	// "this" must be an impersonation token and NOT a primary token
 	BOOL bIsMember;
@@ -3700,63 +3700,63 @@ inline bool CAccessToken::IsTokenRestricted() const throw()
 }
 #endif
 
-inline bool CAccessToken::GetDefaultDacl(_Inout_ CDacl *pDacl) const throw(...)
+inline bool CAccessToken::GetDefaultDacl(_Inout_ CDacl *pDacl) const noexcept(false)
 {
 	return GetInfoConvert<CDacl, TOKEN_DEFAULT_DACL>(pDacl, TokenDefaultDacl);
 }
 
-inline bool CAccessToken::GetGroups(_Inout_ CTokenGroups *pGroups) const throw(...)
+inline bool CAccessToken::GetGroups(_Inout_ CTokenGroups *pGroups) const noexcept(false)
 {
 	return GetInfoConvert<CTokenGroups, TOKEN_GROUPS>(pGroups, TokenGroups);
 }
 
 inline bool CAccessToken::GetImpersonationLevel(
-	_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const throw(...)
+	_Inout_ SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const noexcept(false)
 {
 	return GetInfo<SECURITY_IMPERSONATION_LEVEL>(pImpersonationLevel, TokenImpersonationLevel);
 }
 
-inline bool CAccessToken::GetOwner(_Inout_ CSid *pSid) const throw(...)
+inline bool CAccessToken::GetOwner(_Inout_ CSid *pSid) const noexcept(false)
 {
 	return GetInfoConvert<CSid, TOKEN_OWNER>(pSid, TokenOwner);
 }
 
-inline bool CAccessToken::GetPrimaryGroup(_Inout_ CSid *pSid) const throw(...)
+inline bool CAccessToken::GetPrimaryGroup(_Inout_ CSid *pSid) const noexcept(false)
 {
 	return GetInfoConvert<CSid, TOKEN_PRIMARY_GROUP>(pSid, TokenPrimaryGroup);
 }
 
-inline bool CAccessToken::GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const throw(...)
+inline bool CAccessToken::GetPrivileges(_Inout_ CTokenPrivileges *pPrivileges) const noexcept(false)
 {
 	return GetInfoConvert<CTokenPrivileges, TOKEN_PRIVILEGES>(pPrivileges, TokenPrivileges);
 }
 
-inline bool CAccessToken::GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const throw(...)
+inline bool CAccessToken::GetTerminalServicesSessionId(_Inout_ DWORD *pdwSessionId) const noexcept(false)
 {
 	return GetInfo<DWORD>(pdwSessionId, TokenSessionId);
 }
 
-inline bool CAccessToken::GetSource(_Inout_ TOKEN_SOURCE *pSource) const throw(...)
+inline bool CAccessToken::GetSource(_Inout_ TOKEN_SOURCE *pSource) const noexcept(false)
 {
 	return GetInfo<TOKEN_SOURCE>(pSource, TokenSource);
 }
 
-inline bool CAccessToken::GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const throw(...)
+inline bool CAccessToken::GetStatistics(_Inout_ TOKEN_STATISTICS *pStatistics) const noexcept(false)
 {
 	return GetInfo<TOKEN_STATISTICS>(pStatistics, TokenStatistics);
 }
 
-inline bool CAccessToken::GetType(_Inout_ TOKEN_TYPE *pType) const throw(...)
+inline bool CAccessToken::GetType(_Inout_ TOKEN_TYPE *pType) const noexcept(false)
 {
 	return GetInfo<TOKEN_TYPE>(pType, TokenType);
 }
 
-inline bool CAccessToken::GetUser(_Inout_ CSid *pSid) const throw(...)
+inline bool CAccessToken::GetUser(_Inout_ CSid *pSid) const noexcept(false)
 {
 	return GetInfoConvert<CSid, TOKEN_USER>(pSid, TokenUser);
 }
 
-inline bool CAccessToken::SetOwner(_In_ const CSid &rSid) throw(...)
+inline bool CAccessToken::SetOwner(_In_ const CSid &rSid) noexcept(false)
 
 {
 	TOKEN_OWNER to;
@@ -3764,14 +3764,14 @@ inline bool CAccessToken::SetOwner(_In_ const CSid &rSid) throw(...)
 	return 0 != ::SetTokenInformation(m_hToken, TokenOwner, &to, sizeof(to));
 }
 
-inline bool CAccessToken::SetPrimaryGroup(_In_ const CSid &rSid) throw(...)
+inline bool CAccessToken::SetPrimaryGroup(_In_ const CSid &rSid) noexcept(false)
 {
 	TOKEN_PRIMARY_GROUP tpg;
 	tpg.PrimaryGroup = const_cast<SID *>(rSid.GetPSID());
 	return 0 != ::SetTokenInformation(m_hToken, TokenPrimaryGroup, &tpg, sizeof(tpg));
 }
 
-inline bool CAccessToken::SetDefaultDacl(_In_ const CDacl &rDacl) throw(...)
+inline bool CAccessToken::SetDefaultDacl(_In_ const CDacl &rDacl) noexcept(false)
 {
 	TOKEN_DEFAULT_DACL tdd;
 	tdd.DefaultDacl = const_cast<ACL *>(rDacl.GetPACL());
@@ -3780,7 +3780,7 @@ inline bool CAccessToken::SetDefaultDacl(_In_ const CDacl &rDacl) throw(...)
 
 inline bool CAccessToken::CreateImpersonationToken(
 	_Inout_ CAccessToken *pImp,
-	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) const throw(...)
+	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) const noexcept(false)
 {
 	ATLASSERT(pImp);
 	if(!pImp)
@@ -3798,7 +3798,7 @@ inline bool CAccessToken::CreateImpersonationToken(
 inline bool CAccessToken::CreatePrimaryToken(
 	_Inout_ CAccessToken *pPri,
 	_In_ DWORD dwDesiredAccess /* = MAXIMUM_ALLOWED */,
-	_In_opt_ const CSecurityAttributes *pTokenAttributes /* = NULL */) const throw(...)
+	_In_opt_ const CSecurityAttributes *pTokenAttributes /* = NULL */) const noexcept(false)
 {
 	ATLASSERT(pPri);
 	if(!pPri)
@@ -3823,7 +3823,7 @@ inline bool CAccessToken::CreateRestrictedToken(
 	_Inout_ CAccessToken *pRestrictedToken,
 	_In_ const CTokenGroups &SidsToDisable,
 	_In_ const CTokenGroups &SidsToRestrict,
-	_In_ const CTokenPrivileges &PrivilegesToDelete /* = CTokenPrivileges() */) const throw(...)
+	_In_ const CTokenPrivileges &PrivilegesToDelete /* = CTokenPrivileges() */) const noexcept(false)
 {
 	ATLASSERT(pRestrictedToken);
 	if(!pRestrictedToken)
@@ -3962,7 +3962,7 @@ inline bool CAccessToken::OpenThreadToken(
 	_In_ DWORD dwDesiredAccess,
 	_In_ bool bImpersonate /* = false */,
 	_In_ bool bOpenAsSelf /* = true */,
-	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) throw(...)
+	_In_ SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) noexcept(false)
 {
 	// If bImpersonate == false the original impersonate level should be restored after getting token.
 	SECURITY_IMPERSONATION_LEVEL silCurrent = SecurityAnonymous; 
@@ -4009,7 +4009,7 @@ inline bool CAccessToken::OpenThreadToken(
 inline bool CAccessToken::OpenCOMClientToken(
 	_In_ DWORD dwDesiredAccess,
 	_In_ bool bImpersonate /* = false */,
-	_In_ bool bOpenAsSelf /* = true */) throw(...)
+	_In_ bool bOpenAsSelf /* = true */) noexcept(false)
 {
 	CheckImpersonation();
 
@@ -4043,7 +4043,7 @@ inline bool CAccessToken::OpenNamedPipeClientToken(
 	_In_ HANDLE hPipe,
 	_In_ DWORD dwDesiredAccess,
 	_In_ bool bImpersonate /* = false */,
-	_In_ bool bOpenAsSelf /* = true */) throw(...)
+	_In_ bool bOpenAsSelf /* = true */) noexcept(false)
 {
 	CheckImpersonation();
 
@@ -4076,7 +4076,7 @@ inline bool CAccessToken::OpenRPCClientToken(
 	_In_ RPC_BINDING_HANDLE BindingHandle,
 	_In_ DWORD dwDesiredAccess,
 	_In_ bool bImpersonate /* = false */,
-	_In_ bool bOpenAsSelf /* = true */) throw(...)
+	_In_ bool bOpenAsSelf /* = true */) noexcept(false)
 {
 	CheckImpersonation();
 
@@ -4115,7 +4115,7 @@ inline bool CAccessToken::OpenRPCClientToken(
 	return true;
 }
 
-inline bool CAccessToken::ImpersonateLoggedOnUser() const throw(...)
+inline bool CAccessToken::ImpersonateLoggedOnUser() const noexcept(false)
 {
 	CheckImpersonation();
 
@@ -4136,7 +4136,7 @@ inline bool CAccessToken::ImpersonateLoggedOnUser() const throw(...)
 }
 
 inline bool CAccessToken::Impersonate(
-	_In_opt_ HANDLE hThread /* = NULL */) const throw(...)
+	_In_opt_ HANDLE hThread /* = NULL */) const noexcept(false)
 {
 	CheckImpersonation();
 
@@ -4158,7 +4158,7 @@ inline bool CAccessToken::Revert(
 	return bRet;
 }
 
-inline bool CAccessToken::LoadUserProfile() throw(...)
+inline bool CAccessToken::LoadUserProfile() noexcept(false)
 {
 	ATLASSUME(m_hToken && !m_hProfile);
 	if(!m_hToken || m_hProfile)
@@ -4294,7 +4294,7 @@ inline bool CAccessToken::EnableDisablePrivileges(
 	_In_ const CAtlArray<LPCTSTR> &rPrivileges,
 	_In_ bool bEnable,
 	_Inout_opt_ CTokenPrivileges *pPreviousState,
-	_Out_opt_ bool* pbErrNotAllAssigned/*=NULL*/) throw(...)
+	_Out_opt_ bool* pbErrNotAllAssigned/*=NULL*/) noexcept(false)
 {
 	CTokenPrivileges NewState;
 	for(UINT i = 0; i < rPrivileges.GetCount(); i++)
@@ -4580,7 +4580,7 @@ inline bool AtlGetSecurityDescriptor(
 		GROUP_SECURITY_INFORMATION |
 		DACL_SECURITY_INFORMATION |
 		SACL_SECURITY_INFORMATION */,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(pSecurityDescriptor);
 	if(!pSecurityDescriptor)
@@ -4638,7 +4638,7 @@ inline bool AtlGetSecurityDescriptor(
 		GROUP_SECURITY_INFORMATION |
 		DACL_SECURITY_INFORMATION |
 		SACL_SECURITY_INFORMATION */,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(pSecurityDescriptor);
 	if(!pSecurityDescriptor)
@@ -4690,7 +4690,7 @@ inline bool AtlGetSecurityDescriptor(
 inline bool AtlGetOwnerSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...)
+	_Inout_ CSid *pSid) noexcept(false)
 {
 	ATLASSERT(hObject && pSid);
 	if(!hObject || !pSid)
@@ -4719,7 +4719,7 @@ inline bool AtlGetOwnerSid(
 inline bool AtlSetOwnerSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...)
+	_In_ const CSid &rSid) noexcept(false)
 {
 	ATLASSERT(hObject && rSid.IsValid());
 	if(!hObject || !rSid.IsValid())
@@ -4735,7 +4735,7 @@ inline bool AtlSetOwnerSid(
 inline bool AtlGetOwnerSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...)
+	_Inout_ CSid *pSid) noexcept(false)
 {
 	ATLASSERT(pszObjectName && pSid);
 	if(!pszObjectName || !pSid)
@@ -4763,7 +4763,7 @@ inline bool AtlGetOwnerSid(
 inline bool AtlSetOwnerSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...)
+	_In_ const CSid &rSid) noexcept(false)
 {
 	ATLASSERT(pszObjectName && rSid.IsValid());
 	if(!pszObjectName || !rSid.IsValid())
@@ -4779,7 +4779,7 @@ inline bool AtlSetOwnerSid(
 inline bool AtlGetGroupSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...)
+	_Inout_ CSid *pSid) noexcept(false)
 {
 	ATLASSERT(hObject && pSid);
 	if(!hObject || !pSid)
@@ -4807,7 +4807,7 @@ inline bool AtlGetGroupSid(
 inline bool AtlSetGroupSid(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...)
+	_In_ const CSid &rSid) noexcept(false)
 {
 	ATLASSERT(hObject && rSid.IsValid());
 	if(!hObject || !rSid.IsValid())
@@ -4823,7 +4823,7 @@ inline bool AtlSetGroupSid(
 inline bool AtlGetGroupSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CSid *pSid) throw(...)
+	_Inout_ CSid *pSid) noexcept(false)
 {
 	ATLASSERT(pszObjectName && pSid);
 	if(!pszObjectName || !pSid)
@@ -4851,7 +4851,7 @@ inline bool AtlGetGroupSid(
 inline bool AtlSetGroupSid(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_In_ const CSid &rSid) throw(...)
+	_In_ const CSid &rSid) noexcept(false)
 {
 	ATLASSERT(pszObjectName && rSid.IsValid());
 	if(!pszObjectName || !rSid.IsValid())
@@ -4867,7 +4867,7 @@ inline bool AtlSetGroupSid(
 inline bool AtlGetDacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CDacl *pDacl) throw(...)
+	_Inout_ CDacl *pDacl) noexcept(false)
 {
 	ATLASSERT(hObject && pDacl);
 	if(!hObject || !pDacl)
@@ -4899,7 +4899,7 @@ inline bool AtlSetDacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CDacl &rDacl,
-	_In_ DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
+	_In_ DWORD dwInheritanceFlowControl /* = 0 */) noexcept(false)
 {
 	ATLASSERT(hObject);
 	if(!hObject)
@@ -4921,7 +4921,7 @@ inline bool AtlSetDacl(
 inline bool AtlGetDacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
-	_Inout_ CDacl *pDacl) throw(...)
+	_Inout_ CDacl *pDacl) noexcept(false)
 {
 	ATLASSERT(pszObjectName && pDacl);
 	if(!pszObjectName || !pDacl)
@@ -4953,7 +4953,7 @@ inline bool AtlSetDacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CDacl &rDacl,
-	_In_ DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
+	_In_ DWORD dwInheritanceFlowControl /* = 0 */) noexcept(false)
 {
 	ATLASSERT(pszObjectName);
 	if(!pszObjectName)
@@ -4976,7 +4976,7 @@ inline bool AtlGetSacl(
 	_In_ HANDLE hObject,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_Inout_ CSacl *pSacl,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(hObject && pSacl);
 	if(!hObject || !pSacl)
@@ -5028,7 +5028,7 @@ inline bool AtlSetSacl(
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CSacl &rSacl,
 	_In_ DWORD dwInheritanceFlowControl /* = 0 */,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(hObject);
 	if (!hObject)
@@ -5071,7 +5071,7 @@ inline bool AtlGetSacl(
 	_In_z_ LPCTSTR pszObjectName,
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_Inout_ CSacl *pSacl,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(pszObjectName && pSacl);
 	if(!pszObjectName || !pSacl)
@@ -5119,7 +5119,7 @@ inline bool AtlSetSacl(
 	_In_ SE_OBJECT_TYPE ObjectType,
 	_In_ const CSacl &rSacl,
 	_In_ DWORD dwInheritanceFlowControl /* = 0 */,
-	_In_ bool bRequestNeededPrivileges /* = true */) throw(...)
+	_In_ bool bRequestNeededPrivileges /* = true */) noexcept(false)
 {
 	ATLASSERT(pszObjectName);
 	if (!pszObjectName)
diff --git a/include/atlsimpcoll.h b/include/atlsimpcoll.h
index 6fc2c78..5e58861 100644
--- a/include/atlsimpcoll.h
+++ b/include/atlsimpcoll.h
@@ -175,7 +175,9 @@ public:
 				return FALSE;
 			}
 
+#if __MSVCRT_VERSION__ >= 0x900
 			aT = (T*)_recalloc(m_aT, nNewAllocSize, sizeof(T));
+#endif
 			if(aT == NULL)
 				return FALSE;
 			m_nAllocSize = nNewAllocSize;
@@ -335,12 +337,16 @@ public:
 		_In_ const TVal& val)
 	{
 		TKey* pKey;
+#if __MSVCRT_VERSION__ >= 0x900
 		pKey = (TKey*)_recalloc(m_aKey, (m_nSize + 1), sizeof(TKey));
+#endif
 		if(pKey == NULL)
 			return FALSE;
 		m_aKey = pKey;
 		TVal* pVal;
+#if __MSVCRT_VERSION__ >= 0x900
 		pVal = (TVal*)_recalloc(m_aVal, (m_nSize + 1), sizeof(TVal));
+#endif
 		if(pVal == NULL)
 			return FALSE;
 		m_aVal = pVal;
diff --git a/include/atlsimpstr.h b/include/atlsimpstr.h
index 51df29d..4d1fe39 100644
--- a/include/atlsimpstr.h
+++ b/include/atlsimpstr.h
@@ -39,17 +39,17 @@ public:
 	// Allocate a new CStringData
 	CStringData* Allocate(
 		_In_ int nAllocLength,
-		_In_ int nCharSize) throw();
+		_In_ int nCharSize) throw() {}
 	// Free an existing CStringData
-	void Free(_Inout_ CStringData* pData) throw();
+	void Free(_Inout_ CStringData* pData) throw() {}
 	// Change the size of an existing CStringData
 	CStringData* Reallocate(
 		_Inout_ CStringData* pData,
 		_In_ int nAllocLength,
-		_In_ int nCharSize) throw();
+		_In_ int nCharSize) throw() {}
 	// Get the CStringData for a Nil string
-	CStringData* GetNilString() throw();
-	IAtlStringMgr* Clone() throw();
+	CStringData* GetNilString() throw() {}
+	IAtlStringMgr* Clone() throw() {}
 };
 
 #ifdef _M_IX86
@@ -550,7 +550,7 @@ public:
 		return pStringMgr ? pStringMgr->Clone() : NULL;
 	}
 
-	_Ret_count_x_(m_nLength) PCXSTR GetString() const throw()
+	PCXSTR GetString() const throw()
 	{
 		return( m_pszData );
 	}
@@ -859,7 +859,7 @@ private:
 			else
 			{
 				// Exponential growth factor is 1.5.
-				nNewLength = nNewLength + nNewLength / 2;
+				nNewLength = nNewLength + (nNewLength / 2);
 			}
 			if( nNewLength < nLength )
 			{
@@ -944,7 +944,7 @@ public:
 	static const DWORD SET_LENGTH = 0x02;  // Set the length of the string object at GetBuffer time
 
 public:
-	explicit CStrBufT(_In_ StringType& str) throw( ... ) :
+	explicit CStrBufT(_In_ StringType& str) noexcept(false) :
 		m_str( str ),
 		m_pszBuffer( NULL ),
 #ifdef _DEBUG
@@ -958,7 +958,7 @@ public:
 	CStrBufT(
 			_In_ StringType& str,
 			_In_ int nMinLength,
-			_In_ DWORD dwFlags = AUTO_LENGTH) throw( ... ) :
+			_In_ DWORD dwFlags = AUTO_LENGTH) noexcept(false) :
 		m_str( str ),
 		m_pszBuffer( NULL ),
 #ifdef _DEBUG
diff --git a/include/atlsnap.h b/include/atlsnap.h
index 740e9aa..d3b79f2 100644
--- a/include/atlsnap.h
+++ b/include/atlsnap.h
@@ -571,7 +571,7 @@ public :
 			ATLTRACE(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
 		else
 		{
-			hr = pUnknown->QueryInterface(&m_spConsole);
+			hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_spConsole);
 			if (FAILED(hr))
 				ATLTRACE(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
 		}
@@ -600,7 +600,7 @@ public :
 			else
 			{
 				pComponent->m_pComponentData = static_cast<T*>(this);
-				hr = pComponent->QueryInterface(__uuidof(IComponent), (void**)ppComponent);
+				hr = pComponent->QueryInterface(IID_IComponent, (void**)&ppComponent);
 			}
 		}
 		return hr;
@@ -735,7 +735,7 @@ public:
 			m_spConsole = lpConsole;
 
 			CComPtr<IHeaderCtrl> spHeaderCtrl;
-			hr = m_spConsole.QueryInterface(&spHeaderCtrl);
+			hr = m_spConsole.QueryInterface(IID_IHeaderCtrl, (void**)&spHeaderCtrl);
 			if (FAILED(hr))
 				ATLTRACE(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
 			else
@@ -1649,7 +1649,7 @@ ATLPREFAST_SUPPRESS(6387)
 		pData->m_objectData.m_pItem = pT;
 		pData->m_objectData.m_type = type;
 
-		hr = pData->QueryInterface(__uuidof(IDataObject), (void**)(pDataObj));
+		hr = pData->QueryInterface(IID_IDataObject, (void**)&pDataObj);
 		return hr;
 	}
 ATLPREFAST_UNSUPPRESS()
@@ -1732,7 +1732,7 @@ ATLPREFAST_UNSUPPRESS()
 		return NULL;
 	}
 
-	static void _stdcall CleanUpToolbarInfo(_In_ DWORD_PTR dw)
+	static void __stdcall CleanUpToolbarInfo(_In_ DWORD_PTR dw)
 	{
 		for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
 		{
@@ -1775,12 +1775,12 @@ ATLPREFAST_UNSUPPRESS()
 	RESULTDATAITEM m_resultDataItem;
 };
 
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
-_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
+__declspec(selectany) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;
 
 }; //namespace ATL
 
diff --git a/include/atlsocket.h b/include/atlsocket.h
index c47825a..468c201 100644
--- a/include/atlsocket.h
+++ b/include/atlsocket.h
@@ -67,7 +67,7 @@ namespace ATL
 			_In_ int flags,						// 0 or combination of AI_PASSIVE, AI_CANONNAME or AI_NUMERICHOST
 			_In_ int addr_family,				// Address family (such as PF_INET)
 			_In_ int sock_type,					// Socket type (such as SOCK_STREAM)
-			_In_ int ai_proto);					// Protocol (such as IPPROTO_IP or IPPROTO_IPV6)
+			_In_ int ai_proto) throw();					// Protocol (such as IPPROTO_IP or IPPROTO_IPV6)
 
 		int FindAddr(
 			_In_z_ LPCTSTR szHost, 			// Host name or dotted IP address
@@ -104,5 +104,5 @@ namespace ATL
 #pragma pack(pop)
 #pragma warning(pop)
 
-#endif __ATL_SOCKET__
+#endif // __ATL_SOCKET__
 
diff --git a/include/atlstdthunk.h b/include/atlstdthunk.h
index 1755578..3c38a36 100644
--- a/include/atlstdthunk.h
+++ b/include/atlstdthunk.h
@@ -51,7 +51,7 @@ struct _stdcallthunk
 	{
 		return this;
 	}
-	_Ret_opt_bytecount_x_(sizeof(_stdcallthunk)) void* operator new(_In_ size_t)
+	void* operator new(_In_ size_t)
 	{
         return __AllocStdCallThunk();
     }
@@ -90,7 +90,7 @@ struct _stdcallthunk
 	{
 		return this;
 	}
-	_Ret_opt_bytecount_x_(sizeof(_stdcallthunk)) void* operator new(_In_ size_t)
+	void* operator new(_In_ size_t)
 	{
         return __AllocStdCallThunk();
     }
diff --git a/include/atlstr.h b/include/atlstr.h
index 9168563..911d899 100644
--- a/include/atlstr.h
+++ b/include/atlstr.h
@@ -47,7 +47,7 @@ public:
 
 // IAtlStringMgr
 public:
-	_Ret_opt_bytecap_x_(sizeof(CStringData) + nChars*nCharSize) virtual CStringData* Allocate(
+	virtual CStringData* Allocate(
 		_In_ int nChars,
 		_In_ int nCharSize) throw()
 	{
@@ -81,8 +81,8 @@ public:
 			
 		m_pMemMgr->Free( pData );
 	}
-	_Ret_opt_bytecap_x_(sizeof(CStringData) + nChars*nCharSize) virtual CStringData* Reallocate(
-		_Inout_ _Post_bytecount_x_(sizeof(CStringData)) CStringData* pData,
+	virtual CStringData* Reallocate(
+		_Inout_ CStringData* pData,
 		_In_ int nChars,
 		_In_ int nCharSize) throw()
 	{
@@ -244,7 +244,7 @@ public:
 		_In_z_ LPCSTR pStr,
 		_In_z_ LPCSTR pCharSet) throw()
 	{
-		return strstrT< ChTraitsOS<XCHAR> >(pStr,pCharSet);
+		return strstrT< ChTraitsOS<typename ChTraitsBase< char >::XCHAR> >(pStr,pCharSet);
 	}
 	static int strspn(
 		_In_z_ const _CharType* pStr,
@@ -807,7 +807,7 @@ public:
 		_In_z_ LPCWSTR pStr,
 		_In_z_ LPCWSTR pCharSet) throw()
 	{
-		return strstrT< ChTraitsOS<XCHAR> >(pStr,pCharSet);
+		return strstrT< ChTraitsOS<typename ChTraitsBase< wchar_t >::XCHAR> >(pStr,pCharSet);
 	}
 	static int strspn(
 		_In_z_ const wchar_t* psz,
@@ -1221,9 +1221,9 @@ inline typename ChTraits::PCXSTR strstrT(
 		return pStr;
 	//lstrlenA returns length in bytes, not chars.
 	size_t nStrLen = ChTraits::GetBaseTypeLength(pStr);
-	ChTraits::PCXSTR pStrEnd=pStr + nStrLen;
-	const ChTraits::XCHAR* pMatch;
-	const ChTraits::XCHAR* pStart = pStr;
+	typename ChTraits::PCXSTR pStrEnd = pStr + nStrLen;
+	const typename ChTraits::XCHAR* pMatch;
+	const typename ChTraits::XCHAR* pStart = pStr;
 	while ((pMatch = ChTraits::strchr(pStart, *pCharSet)) != NULL)
 	{
 		size_t nCharsLeftInStr=pStrEnd - pMatch;
@@ -1231,7 +1231,7 @@ inline typename ChTraits::PCXSTR strstrT(
 		{
 			break;
 		}
-		if (memcmp(pMatch, pCharSet, nCharSetLen*sizeof(ChTraits::XCHAR)) == 0)
+		if (memcmp(pMatch, pCharSet, nCharSetLen*sizeof(typename ChTraits::XCHAR)) == 0)
 		{
 			return pMatch;
 		}
diff --git a/include/atltime.inl b/include/atltime.inl
index 2dbc5e5..1a3398f 100644
--- a/include/atltime.inl
+++ b/include/atltime.inl
@@ -39,7 +39,7 @@ ATLTIME_INLINE CTimeSpan::CTimeSpan(
 	_In_ int nMins,
 	_In_ int nSecs) throw()
 {
- 	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));
+ 	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + ((__int64)(24) * lDays)));
 }
 
 ATLTIME_INLINE LONGLONG CTimeSpan::GetDays() const throw()
@@ -415,7 +415,7 @@ ATLTIME_INLINE __time64_t CTime::GetTime() const throw()
 	return( m_time );
 }
 
-ATLTIME_INLINE int CTime::GetYear() const
+ATLTIME_INLINE int CTime::GetYear() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -424,7 +424,7 @@ ATLTIME_INLINE int CTime::GetYear() const
 	return ptm ? (ptm->tm_year) + 1900 : 0 ;
 }
 
-ATLTIME_INLINE int CTime::GetMonth() const
+ATLTIME_INLINE int CTime::GetMonth() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -433,7 +433,7 @@ ATLTIME_INLINE int CTime::GetMonth() const
 	return ptm ? ptm->tm_mon + 1 : 0;
 }
 
-ATLTIME_INLINE int CTime::GetDay() const
+ATLTIME_INLINE int CTime::GetDay() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -442,7 +442,7 @@ ATLTIME_INLINE int CTime::GetDay() const
 	return ptm ? ptm->tm_mday : 0 ;
 }
 
-ATLTIME_INLINE int CTime::GetHour() const
+ATLTIME_INLINE int CTime::GetHour() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -451,7 +451,7 @@ ATLTIME_INLINE int CTime::GetHour() const
 	return ptm ? ptm->tm_hour : -1 ;
 }
 
-ATLTIME_INLINE int CTime::GetMinute() const
+ATLTIME_INLINE int CTime::GetMinute() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -460,7 +460,7 @@ ATLTIME_INLINE int CTime::GetMinute() const
 	return ptm ? ptm->tm_min : -1 ;
 }
 
-ATLTIME_INLINE int CTime::GetSecond() const
+ATLTIME_INLINE int CTime::GetSecond() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
@@ -469,7 +469,7 @@ ATLTIME_INLINE int CTime::GetSecond() const
 	return ptm ? ptm->tm_sec : -1 ;
 }
 
-ATLTIME_INLINE int CTime::GetDayOfWeek() const
+ATLTIME_INLINE int CTime::GetDayOfWeek() const throw()
 {
 	struct tm ttm;
 	struct tm * ptm;
diff --git a/include/atltrace.h b/include/atltrace.h
index 1aca816..71c07be 100644
--- a/include/atltrace.h
+++ b/include/atltrace.h
@@ -28,7 +28,6 @@ extern "C" IMAGE_DOS_HEADER __ImageBase;
 #endif  // _DEBUG
 
 
-#pragma pack(push,_ATL_PACKING)
 namespace ATL
 {
 
@@ -391,10 +390,6 @@ DECLARE_TRACE_CATEGORY( atlTraceUser2 )
 DECLARE_TRACE_CATEGORY( atlTraceUser3 )
 DECLARE_TRACE_CATEGORY( atlTraceUser4 )
 
-#pragma deprecated( atlTraceUser )
-#pragma deprecated( atlTraceUser2 )
-#pragma deprecated( atlTraceUser3 )
-#pragma deprecated( atlTraceUser4 )
 
 #ifdef _DEBUG
 
@@ -457,8 +452,6 @@ __declspec( selectany ) _CRT_REPORT_HOOK CNoUIAssertHook::s_pfnPrevHook = NULL;
 #define ATLTRACE2 ATLTRACE
 #endif
 
-#pragma warning(push)
-#pragma warning(disable : 4793)
 inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCSTR pszFormat, ...)
 {
 	va_list ptr;
@@ -466,10 +459,7 @@ inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCSTR pszFormat, ...
 	ATL::CTrace::s_trace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
 	va_end(ptr);
 }
-#pragma warning(pop)
 
-#pragma warning(push)
-#pragma warning(disable : 4793)
 inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCWSTR pszFormat, ...)
 {
 	va_list ptr;
@@ -477,10 +467,7 @@ inline void __cdecl AtlTrace(_In_z_ _Printf_format_string_ LPCWSTR pszFormat, ..
 	ATL::CTrace::s_trace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
 	va_end(ptr);
 }
-#pragma warning(pop)
 
-#pragma warning(push)
-#pragma warning(disable : 4793)
 inline void __cdecl AtlTrace2(
 	_In_ DWORD_PTR dwCategory,
 	_In_ UINT nLevel,
@@ -491,10 +478,7 @@ inline void __cdecl AtlTrace2(
 	ATL::CTrace::s_trace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
 	va_end(ptr);
 }
-#pragma warning(pop)
 
-#pragma warning(push)
-#pragma warning(disable : 4793)
 inline void __cdecl AtlTrace2(
 	_In_ DWORD_PTR dwCategory,
 	_In_ UINT nLevel,
@@ -505,14 +489,11 @@ inline void __cdecl AtlTrace2(
 	ATL::CTrace::s_trace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
 	va_end(ptr);
 }
-#pragma warning(pop)
 
 #define ATLTRACENOTIMPL(funcname)  do { ATLTRACE(ATL::atlTraceNotImpl, 0, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL; } while(0)
 
 #else // !DEBUG
 
-#pragma warning(push)
-#pragma warning(disable : 4793)
 inline void __cdecl AtlTraceNull(...)
 {
 }
@@ -536,7 +517,6 @@ inline void __cdecl AtlTrace2(
 	_In_z_ _Printf_format_string_ LPCWSTR, ...)
 {
 }
-#pragma warning(pop)
 
 #ifndef ATLTRACE
 
@@ -549,6 +529,5 @@ inline void __cdecl AtlTrace2(
 #endif //!_DEBUG
 
 };  // namespace ATL
-#pragma pack(pop)
 
 #endif  // __ATLTRACE_H__
diff --git a/include/atlutil.h b/include/atlutil.h
index fb92303..e764389 100644
--- a/include/atlutil.h
+++ b/include/atlutil.h
@@ -422,11 +422,11 @@ public:
 				}
 		  }
 		  else
-			  pszSymbol = "<no symbol>";
+			  pszSymbol = _TEXT("<no symbol>");
 		}
 		__except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode())
 		{
-			pszSymbol = "<EX: no symbol>";
+			pszSymbol = _TEXT("<EX: no symbol>");
 			siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
 		}
 
@@ -933,7 +933,12 @@ __declspec(selectany) char CDebugReportHook::m_szClientName[MAX_COMPUTERNAME_LEN
 // IThreadPoolConfig
 // Used to configure the worker thread pool. This can be used by any
 // client of the CThreadPool class.
+#ifdef _MSC_VER
 __interface __declspec(uuid("B1F64757-6E88-4fa2-8886-7848B0D7E660"))
+#else
+const IID IID_IThreadPoolConfig = { 0xb1f64757, 0x6e88, 0x4fa2, 0x88,0x86, 0x78,0x48,0xb0,0xd7,0xe6,0x60 };
+interface
+#endif
 	IThreadPoolConfig : public IUnknown
 {
 	STDMETHOD(SetSize)(_In_ int nNumThreads);
@@ -1167,8 +1172,8 @@ ATLPREFAST_UNSUPPRESS()
 
 		*ppv = NULL;
 
-		if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
-			InlineIsEqualGUID(riid, __uuidof(IThreadPoolConfig)))
+		if (InlineIsEqualGUID(riid, IID_IUnknown) ||
+			InlineIsEqualGUID(riid, IID_IThreadPoolConfig))
 		{
 			*ppv = static_cast<IThreadPoolConfig*>(this);
 			AddRef();
@@ -1244,7 +1249,7 @@ protected:
 				}
 				else										// Do work
 				{
-					Worker::RequestType request = (Worker::RequestType) dwCompletionKey;
+					typename Worker::RequestType request = (typename Worker::RequestType) dwCompletionKey;
 
 					// Process the request.  Notice the following:
 					// (1) It is the worker's responsibility to free any memory associated
@@ -3532,7 +3537,7 @@ inline BOOL CopyCString(
 		return FALSE;
 	}
 
-	StringType::PCXSTR szBuffer = str;
+	typename StringType::PCXSTR szBuffer = str;
 	if (szBuffer)
 	{
 		Checked::memcpy_s(szDest, *pdwDestLen * sizeof(StringType::XCHAR),
@@ -3634,7 +3639,7 @@ inline int AsciiStrnicmp (
 
 inline CString AtlGetErrorDescription(
 	_In_ HRESULT hr,
-	_In_ DWORD dwLangId = 0) throw(...)
+	_In_ DWORD dwLangId = 0) noexcept(false)
 {
 	LPTSTR szMessage = NULL;
 	CString str;
diff --git a/include/atlwin.h b/include/atlwin.h
index 25a7cbb..c480743 100644
--- a/include/atlwin.h
+++ b/include/atlwin.h
@@ -347,6 +347,10 @@ typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
 #else
 #define CWndClassInfo CWndClassInfoA
 #endif
+template <DWORD t_dwStyle, DWORD t_dwExStyle> class CWinTraits;
+typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>					CControlWinTraits;
+typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>		CFrameWinTraits;
+typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD>	CMDIChildWinTraits;
 template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowImpl;
 template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowWithReflectorImpl;
 template <class T, class TBase = CWindow> class CDialogImpl;
@@ -2240,7 +2244,7 @@ ATLPREFAST_UNSUPPRESS()
 	}
 };
 
-_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
+__declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
 
 /////////////////////////////////////////////////////////////////////////////
 // CAxWindow - client side for an ActiveX host window
@@ -2253,6 +2257,8 @@ class CAxWindowT :
 	public TBase
 {
 public:
+	HWND m_hWnd;
+
 // Constructors
 	CAxWindowT(_In_opt_ HWND hWnd = NULL) : TBase(hWnd)
 	{
@@ -2459,7 +2465,7 @@ public:
 	{
 		HRESULT hr;
 		CComPtr<IAxWinHostWindow> spHost;
-		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
+		hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
 		if (SUCCEEDED(hr))
 			hr = spHost->SetExternalDispatch(pDisp);
 		return hr;
@@ -2468,7 +2474,7 @@ public:
 	{
 		HRESULT hr;
 		CComPtr<IAxWinHostWindow> spHost;
-		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
+		hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
 		if (SUCCEEDED(hr))
 			hr = spHost->SetExternalUIHandler(pUIHandler);
 		return hr;
@@ -2483,6 +2489,8 @@ class CAxWindow2T :
 	public CAxWindowT<TBase>
 {
 public:
+	HWND m_hWnd;
+
 // Constructors
 	CAxWindow2T(_In_opt_ HWND hWnd = NULL) : 
 		CAxWindowT<TBase>(hWnd)
@@ -2546,7 +2554,7 @@ public:
 
 		// Get a pointer to the container object connected to this window
 		CComPtr<IAxWinHostWindowLic> spWinHost;
-		HRESULT hr = QueryHost(&spWinHost);
+		HRESULT hr = CAxWindow::QueryHost(&spWinHost);
 
 		// If QueryHost failed, there is no host attached to this window
 		// We assume that the user wants to create a new host and subclass the current window
@@ -2853,7 +2861,7 @@ public: \
 #define REFLECT_NOTIFICATIONS() \
 	{ \
 		bHandled = TRUE; \
-		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		lResult = CWindowImplRoot<TBase>::ReflectNotifications(uMsg, wParam, lParam, bHandled); \
 		if(bHandled) \
 			return TRUE; \
 	}
@@ -3075,7 +3083,7 @@ static ATL::CWndClassInfo& GetWndClassInfo() \
 { \
 	static ATL::CWndClassInfo wc = \
 	{ \
-		{ sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc, \
+		{ sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, CWindowImplBaseT<>::StartWindowProc, \
 		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
 		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
 	}; \
@@ -3087,7 +3095,7 @@ static ATL::CWndClassInfo& GetWndClassInfo() \
 { \
 	static ATL::CWndClassInfo wc = \
 	{ \
-		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
+		{ sizeof(WNDCLASSEX), style, CWindowImplBaseT<>::StartWindowProc, \
 		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
 		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
 	}; \
@@ -3099,7 +3107,7 @@ static ATL::CWndClassInfo& GetWndClassInfo() \
 { \
 	static ATL::CWndClassInfo wc = \
 	{ \
-		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
+		{ sizeof(WNDCLASSEX), 0, CWindowImplBaseT<>::StartWindowProc, \
 		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
 		OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
 	}; \
@@ -3155,6 +3163,7 @@ public:
 	CWndProcThunk m_thunk;
 	const _ATL_MSG* m_pCurrentMsg;
 	DWORD m_dwState;
+	HWND m_hWnd;
 
 	enum { WINSTATE_DESTROYED = 0x00000001 };
 
@@ -3243,7 +3252,7 @@ LRESULT CWindowImplRoot< TBase >::ForwardNotifications(
 	case WM_CTLCOLORMSGBOX:
 	case WM_CTLCOLORSCROLLBAR:
 	case WM_CTLCOLORSTATIC:
-		lResult = GetParent().SendMessage(uMsg, wParam, lParam);
+		lResult = CAxWindow::GetParent().SendMessage(uMsg, wParam, lParam);
 		break;
 	default:
 		bHandled = FALSE;
@@ -3278,7 +3287,7 @@ LRESULT CWindowImplRoot< TBase >::ReflectNotifications(
 			hWndChild = (HWND)lParam;
 			break;
 		default:
-			hWndChild = GetDlgItem(HIWORD(wParam));
+			hWndChild = CAxWindow::GetDlgItem(HIWORD(wParam));
 			break;
 		}
 		break;
@@ -3288,7 +3297,7 @@ LRESULT CWindowImplRoot< TBase >::ReflectNotifications(
 		break;
 	case WM_MEASUREITEM:
 		if(wParam)	// not from a menu
-			hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
+			hWndChild = CAxWindow::GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
 		break;
 	case WM_COMPAREITEM:
 		if(wParam)	// not from a menu
@@ -3370,6 +3379,7 @@ class ATL_NO_VTABLE CWindowImplBaseT :
 {
 public:
 	WNDPROC m_pfnSuperWindowProc;
+	HWND m_hWnd;
 
 	CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
 	{
@@ -3428,6 +3438,7 @@ public:
 
 	LRESULT DefWindowProc()
 	{
+		const _ATL_MSG* m_pCurrentMsg;
 		const _ATL_MSG* pMsg = m_pCurrentMsg;
 		LRESULT lRes = 0;
 		if (pMsg != NULL)
@@ -3504,6 +3515,8 @@ LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(
 	// restore saved value for the current message
 	ATLASSERT(pThis->m_pCurrentMsg == &msg);
 
+	enum { WINSTATE_DESTROYED = 0x00000001 };
+
 	// do the default processing if message was not handled
 	if(!bRet)
 	{
@@ -3549,6 +3562,7 @@ HWND CWindowImplBaseT< TBase, TWinTraits >::Create(
 	ATLASSUME(m_hWnd == NULL);
 
 	// Allocate the thunk structure here, where we can fail gracefully.
+	CWndProcThunk m_thunk;
 	BOOL result = m_thunk.Init(NULL,NULL);
 	if (result == FALSE) {
 		SetLastError(ERROR_OUTOFMEMORY);
@@ -3583,6 +3597,7 @@ BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(_In_ HWND hWnd)
 
 	// Allocate the thunk structure here, where we can fail gracefully.
 
+	CWndProcThunk m_thunk;
 	BOOL result = m_thunk.Init(GetWindowProc(), this);
 	if (result == FALSE)
 	{
@@ -3604,6 +3619,7 @@ HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(_In_ BOOL bForce /*
 {
 	ATLASSUME(m_hWnd != NULL);
 
+	CWndProcThunk m_thunk;
 	WNDPROC pOurProc = m_thunk.GetWNDPROC();
 	WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);
 
@@ -3627,6 +3643,8 @@ class ATL_NO_VTABLE CWindowImpl :
 public:
 	DECLARE_WND_CLASS(NULL)
 
+	WNDPROC m_pfnSuperWindowProc;
+
 	static LPCTSTR GetWndCaption()
 	{
 		return NULL;
@@ -3642,7 +3660,7 @@ public:
 		_In_opt_ LPVOID lpCreateParam = NULL)
 	{
 		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
-			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
+			T::GetWndClassInfo().m_lpszOrigName = T::GetWndClassName();
 		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
 
 		dwStyle = T::GetWndStyle(dwStyle);
@@ -3662,6 +3680,9 @@ class ATL_NO_VTABLE CWindowWithReflectorImpl :
 	public CWindowImpl< T, TBase, TWinTraits >
 {
 public:
+	WNDPROC m_pfnSuperWindowProc;
+	HWND m_hWnd;
+
 	HWND Create(
 		_In_opt_ HWND hWndParent,
 		_In_ _U_RECT rect = NULL,
@@ -3704,7 +3725,7 @@ public:
 		pWP->flags |= SWP_NOMOVE;
 		pWP->x = 0;
 		pWP->y = 0;
-		return DefWindowProc(uMsg, wParam, lParam);
+		return CWindowImplBaseT<>::DefWindowProc(uMsg, wParam, lParam);
 	}
 
 	// reflector window stuff
@@ -3730,6 +3751,8 @@ class ATL_NO_VTABLE CDialogImplBaseT :
 	public CWindowImplRoot< TBase >
 {
 public:
+	HWND m_hWnd;
+
 	virtual ~CDialogImplBaseT()
 	{
 	}
@@ -3786,7 +3809,7 @@ public:
 						if (0x403 == wMsg)
 						{
 							CA2T szText(reinterpret_cast<LPCSTR>(pDlgInit));
-							if (-1 == SendDlgItemMessage(wID, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szText))))
+							if (-1 == CWindow::SendDlgItemMessage(wID, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szText))))
 							{
 								bSuccess = FALSE;
 							}
@@ -3798,7 +3821,7 @@ public:
 							item.mask = CBEIF_TEXT;
 							item.iItem = -1;
 							item.pszText = CA2T(reinterpret_cast<LPSTR>(pDlgInit));
-							if (-1 == SendDlgItemMessage(wID, CBEM_INSERTITEM, 0, (LPARAM)&item))
+							if (-1 == CWindow::SendDlgItemMessage(wID, CBEM_INSERTITEM, 0, (LPARAM)&item))
 							{
 								bSuccess = FALSE;
 							}
@@ -3860,6 +3883,7 @@ INT_PTR CALLBACK CDialogImplBaseT< TBase >::DialogProc(
 	// restore saved value for the current message
 	ATLASSERT(pThis->m_pCurrentMsg == &msg);
 	pThis->m_pCurrentMsg = pOldMsg;
+	enum { WINSTATE_DESTROYED = 0x00000001 };
 	// set result if message was handled
 	if(bRet)
 	{
@@ -3915,6 +3939,8 @@ class ATL_NO_VTABLE CDialogImpl :
 	public CDialogImplBaseT< TBase >
 {
 public:
+	HWND m_hWnd;
+	CWndProcThunk m_thunk;
 #ifdef _DEBUG
 	bool m_bModal;
 	CDialogImpl() : m_bModal(false)
@@ -4021,6 +4047,8 @@ protected:
 	bool m_bModal;
 	HRESULT m_hrError;
 public:
+	HWND m_hWnd;
+	CWndProcThunk m_thunk;
 	CAxDialogImpl() : m_bModal(false), m_hrError(S_OK)
 	{
 	}
@@ -4164,7 +4192,7 @@ public:
 
 					// Get first control on the dialog
 					DLGITEMTEMPLATE* pItem = _DialogSplitHelper::FindFirstDlgItem(pDlg);
-					HWND hWndPrev = GetWindow(GW_CHILD);
+					HWND hWndPrev = CWindow::GetWindow(GW_CHILD);
 
 					// Create all ActiveX cotnrols in the dialog template and place them in the correct tab order (z-order)
 					for (WORD nItem = 0; nItem < nItems; nItem++)
@@ -4229,7 +4257,7 @@ public:
 										pItem->cy);
 
 								// Convert from dialog units to screen units
-								MapDialogRect(&rect);
+								CDialogImplBaseT<TBase>::MapDialogRect(&rect);
 
 								// Create AxWindow with a NULL caption.
 								wnd.Create(m_hWnd,
@@ -4317,7 +4345,7 @@ public:
 
 		// find a direct child of the dialog from the window that has focus
 		HWND hWndCtl = ::GetFocus();
-		if(IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
+		if(::IsChild(m_hWnd, hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
 		{
 			do
 			{
@@ -4476,6 +4504,7 @@ public:
 		_In_ WPARAM wParam,
 		_In_ LPARAM lParam)
 	{
+		HWND m_hWnd;
 #ifdef STRICT
 		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
 #else
@@ -4488,7 +4517,7 @@ public:
 		_In_ WPARAM wParam,
 		_In_ LPARAM lParam)
 	{
-		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)_AtlWinModule.ExtractCreateWndData();
+		CContainedWindowT< TBase, TWinTraits >* pThis = (CContainedWindowT< TBase, TWinTraits >*)_AtlWinModule.ExtractCreateWndData();
 		ATLASSERT(pThis != NULL);
 		if(!pThis)
 		{
@@ -4688,6 +4717,7 @@ public:
 
 	BOOL SubclassWindow(_In_ HWND hWnd)
 	{
+		HWND m_hWnd;
 		BOOL result;
 		ATLASSUME(m_hWnd == NULL);
 		ATLASSERT(::IsWindow(hWnd));
@@ -4711,6 +4741,8 @@ public:
 	// WindowProc will automatically subclass when  window goes away
 	HWND UnsubclassWindow(_In_ BOOL bForce = FALSE)
 	{
+		HWND m_hWnd;
+		CWndProcThunk m_thunk;
 		ATLASSUME(m_hWnd != NULL);
 
 		WNDPROC pOurProc = m_thunk.GetWNDPROC();
@@ -4753,7 +4785,7 @@ public:
 				hWndChild = (HWND)lParam;
 				break;
 			default:
-				hWndChild = GetDlgItem(HIWORD(wParam));
+				hWndChild = CWindow::GetDlgItem(HIWORD(wParam));
 				break;
 			}
 			break;
@@ -4763,7 +4795,7 @@ public:
 			break;
 		case WM_MEASUREITEM:
 			if(wParam)	// not from a menu
-				hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
+				hWndChild = CWindow::GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
 			break;
 		case WM_COMPAREITEM:
 			if(wParam)	// not from a menu
@@ -5201,7 +5233,7 @@ template <class T>
 ATLINLINE ATOM AtlModuleRegisterWndClassInfoT(
 	_In_ _ATL_BASE_MODULE* pBaseModule,
 	_In_ _ATL_WIN_MODULE* pWinModule,
-	_Inout_ _Prepost_bytecount_x_(sizeof(T::_ATL_WNDCLASSINFO)) typename T::_ATL_WNDCLASSINFO* p,
+	_Inout_ typename T::_ATL_WNDCLASSINFO* p,
 	_In_ WNDPROC* pProc, 
 	_In_ T)
 {
@@ -5226,11 +5258,11 @@ ATLINLINE ATOM AtlModuleRegisterWndClassInfoT(
 			if (p->m_lpszOrigName != NULL)
 			{
 				ATLASSERT(pProc != NULL);
-				T::PCXSTR lpsz = p->m_wc.lpszClassName;
+				typename T::PCXSTR lpsz = p->m_wc.lpszClassName;
 				WNDPROC proc = p->m_wc.lpfnWndProc;
 
-				T::WNDCLASSEX wc;
-				wc.cbSize = sizeof(T::WNDCLASSEX);
+				typename T::WNDCLASSEX wc;
+				wc.cbSize = sizeof(typename T::WNDCLASSEX);
 				// Try global class
 				if(!T::GetClassInfoEx(NULL, p->m_lpszOrigName, &wc))
 				{
@@ -5259,7 +5291,7 @@ ATLINLINE ATOM AtlModuleRegisterWndClassInfoT(
 				T::FormatWindowClassName(p->m_szAutoName, _countof(p->m_szAutoName), &p->m_wc);
 				p->m_wc.lpszClassName = p->m_szAutoName;
 			}
-			T::WNDCLASSEX wcTemp;
+			typename T::WNDCLASSEX wcTemp;
 			wcTemp = p->m_wc;
 			p->m_atom = static_cast<ATOM>(T::GetClassInfoEx(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp));
 			if (p->m_atom == 0)
diff --git a/include/atlxml.h b/include/atlxml.h
index b3e6347..54a7ca4 100644
--- a/include/atlxml.h
+++ b/include/atlxml.h
@@ -242,13 +242,13 @@ public:
 	{
 		return &m_pNode;
 	}
-	inline CComQIPtr<T>& Get()
+	inline CComQIPtr<T, &IID_IXMLDOMNode>& Get()
 	{
 		return m_pNode;
 	}
 
 private:
-	CComQIPtr<T> m_pNode;
+	CComQIPtr<T, &IID_IXMLDOMNode> m_pNode;
 };
 
 class CXMLDocument : 
@@ -624,7 +624,7 @@ protected:
 		{
 			m_bComInitialized = TRUE;
 
-			hr = Get().CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER);
+			hr = CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&Get());
 			IF_HR_INVALID_RETURN_HR(hr);
 
 			hr = Get()->put_async(VARIANT_FALSE);
@@ -657,8 +657,8 @@ protected:
 	{
 		IF_NOT_VALID_RETURN_EPTR;
 
-		CComQIPtr<IXMLDOMDocument2> doc2;
-		HRESULT hr = Get()->QueryInterface(&doc2);
+		CComQIPtr<IXMLDOMDocument2, &IID_IXMLDOMDocument2> doc2;
+		HRESULT hr = Get()->QueryInterface(IID_IXMLDOMDocument2, (void**)&doc2);
 
 		IF_HR_INVALID_RETURN_HR(hr);
 
diff --git a/include/cstringt.h b/include/cstringt.h
index 9f6bb6d..d52a12a 100644
--- a/include/cstringt.h
+++ b/include/cstringt.h
@@ -434,7 +434,7 @@ public:
 		_Inout_ _Deref_post_opt_valid_ _Post_z_ BSTR* pbstr,
 		_In_ int nDataLength) throw()
 	{
-		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, NULL, NULL );
+		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, NULL, 0 );
 		BOOL bSuccess = ::SysReAllocStringLen( pbstr, NULL, nLen );
 		if( bSuccess )
 		{
@@ -1037,7 +1037,7 @@ public:
 //ctors to prevent from oldSyntax template ctor (above) hijack certain types.
 //MFC dll instantiate all CStringT methods inside the dll and declares dllimport for
 //all methods in user build (see afxstr.h), so need to include the methods in MFC dll builds.
-#if defined(_AFXDLL) && defined(_MFC_DLL_BLD) || !defined(__cplusplus_cli) && defined(_MANAGED)
+#if (defined(_AFXDLL) && defined(_MFC_DLL_BLD)) || (!defined(__cplusplus_cli) && defined(_MANAGED))
 
 	/*CSTRING_EXPLICIT*/ CStringT(_In_opt_z_ char* pszSrc) :
 		CThisSimpleString( StringTraits::GetDefaultManager() )
@@ -1095,9 +1095,9 @@ public:
 		ATLASSERT( nLength >= 0 );
 		if( nLength > 0 )
 		{
-			PXSTR pszBuffer = GetBuffer( nLength );
+			PXSTR pszBuffer = this->GetBuffer( nLength );
 			StringTraits::FloodCharacters( XCHAR( ch ), nLength, pszBuffer );
-			ReleaseBufferSetLength( nLength );
+			this->ReleaseBufferSetLength( nLength );
 		}
 	}
 #undef _CSTRING_CHAR_T
@@ -1124,7 +1124,7 @@ public:
 			buffBaseTypeChar.Allocate(nBaseTypeCharLen+1);
 			StringTraits::ConvertToBaseType( buffBaseTypeChar, nBaseTypeCharLen+1, pszCh, 1 );
 			//Allocate enough characters in String and flood (replicate) with the (converted character)*nLength
-			PXSTR pszBuffer = GetBuffer( nLength*nBaseTypeCharLen );
+			PXSTR pszBuffer = this->GetBuffer( nLength*nBaseTypeCharLen );
 			if (nBaseTypeCharLen == 1)
 			{   //Optimization for a common case - wide char translates to 1 ansi/wide char.
 				StringTraits::FloodCharacters( buffBaseTypeChar[0], nLength, pszBuffer );
@@ -1140,7 +1140,7 @@ public:
 					}
 				}
 			}
-			ReleaseBufferSetLength( nLength*nBaseTypeCharLen );
+			this->ReleaseBufferSetLength( nLength*nBaseTypeCharLen );
 		}
 	}
 #else
@@ -1180,9 +1180,9 @@ public:
 				AtlThrow(E_INVALIDARG);
 
 			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
-			PXSTR pszBuffer = GetBuffer( nDestLength );
+			PXSTR pszBuffer = this->GetBuffer( nDestLength );
 			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
-			ReleaseBufferSetLength( nDestLength );
+			this->ReleaseBufferSetLength( nDestLength );
 		}
 	}
 
@@ -1200,9 +1200,9 @@ public:
 				AtlThrow(E_INVALIDARG);
 
 			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
-			PXSTR pszBuffer = GetBuffer( nDestLength );
+			PXSTR pszBuffer = this->GetBuffer( nDestLength );
 			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
-			ReleaseBufferSetLength( nDestLength );
+			this->ReleaseBufferSetLength( nDestLength );
 		}
 	}
 #endif // ndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
@@ -1242,13 +1242,13 @@ public:
 		int nDestLength = (pszSrc != NULL) ? StringTraits::GetBaseTypeLength( pszSrc ) : 0;
 		if( nDestLength > 0 )
 		{
-			PXSTR pszBuffer = GetBuffer( nDestLength );
+			PXSTR pszBuffer = this->GetBuffer( nDestLength );
 			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pszSrc);
-			ReleaseBufferSetLength( nDestLength );
+			this->ReleaseBufferSetLength( nDestLength );
 		}
 		else
 		{
-			Empty();
+			this->Empty();
 		}
 
 		return( *this );
@@ -1361,26 +1361,26 @@ public:
 	{
 		ATLENSURE( AtlIsValidString( psz ) );
 		__analysis_assume(psz); // AtlIsValidString guarantees that psz != NULL
-		return( StringTraits::StringCompare( GetString(), psz ) );
+		return( StringTraits::StringCompare( this->GetString(), psz ) );
 	}
 
 	int CompareNoCase(_In_z_ PCXSTR psz) const
 	{
 		ATLENSURE( AtlIsValidString( psz ) );
 		__analysis_assume(psz); // AtlIsValidString guarantees that psz != NULL
-		return( StringTraits::StringCompareIgnore( GetString(), psz ) );
+		return( StringTraits::StringCompareIgnore( this->GetString(), psz ) );
 	}
 
 	int Collate(_In_z_ PCXSTR psz) const throw()
 	{
 		ATLASSERT( AtlIsValidString( psz ) );
-		return( StringTraits::StringCollate( GetString(), psz ) );
+		return( StringTraits::StringCollate( this->GetString(), psz ) );
 	}
 
 	int CollateNoCase(_In_z_ PCXSTR psz) const throw()
 	{
 		ATLASSERT( AtlIsValidString( psz ) );
-		return( StringTraits::StringCollateIgnore( GetString(), psz ) );
+		return( StringTraits::StringCollateIgnore( this->GetString(), psz ) );
 	}
 
 	// Advanced manipulation
@@ -1396,7 +1396,7 @@ public:
 		if( nCount < 0 )
 			nCount = 0;
 
-		int nLength = GetLength();
+		int nLength = this->GetLength();
 		if( (::ATL::AtlAddThrow(nCount, iIndex)) > nLength )
 		{
 			nCount = nLength-iIndex;
@@ -1405,13 +1405,13 @@ public:
 		{
 			int nNewLength = nLength-nCount;
 			int nXCHARsToCopy = nLength-(iIndex+nCount)+1;
-			PXSTR pszBuffer = GetBuffer();
+			PXSTR pszBuffer = this->GetBuffer();
 			Checked::memmove_s( pszBuffer+iIndex, nXCHARsToCopy*sizeof( XCHAR ),
 				pszBuffer+iIndex+nCount, nXCHARsToCopy*sizeof( XCHAR ) );
-			ReleaseBufferSetLength( nNewLength );
+			this->ReleaseBufferSetLength( nNewLength );
 		}
 
-		return( GetLength() );
+		return( this->GetLength() );
 	}
 
 	// Insert character 'ch' before index 'iIndex'
@@ -1422,20 +1422,20 @@ public:
 		if( iIndex < 0 )
 			iIndex = 0;
 
-		if( iIndex > GetLength() )
+		if( iIndex > this->GetLength() )
 		{
-			iIndex = GetLength();
+			iIndex = this->GetLength();
 		}
-		int nNewLength = GetLength()+1;
+		int nNewLength = this->GetLength()+1;
 
-		PXSTR pszBuffer = GetBuffer( nNewLength );
+		PXSTR pszBuffer = this->GetBuffer( nNewLength );
 
 		// move existing bytes down
 		Checked::memmove_s( pszBuffer+iIndex+1, (nNewLength-iIndex)*sizeof( XCHAR ),
 			pszBuffer+iIndex, (nNewLength-iIndex)*sizeof( XCHAR ) );
 		pszBuffer[iIndex] = ch;
 
-		ReleaseBufferSetLength( nNewLength );
+		this->ReleaseBufferSetLength( nNewLength );
 
 		return( nNewLength );
 	}
@@ -1448,25 +1448,25 @@ public:
 		if( iIndex < 0 )
 			iIndex = 0;
 
-		if( iIndex > GetLength() )
+		if( iIndex > this->GetLength() )
 		{
-			iIndex = GetLength();
+			iIndex = this->GetLength();
 		}
 
 		// nInsertLength and nNewLength are in XCHARs
 		int nInsertLength = StringTraits::SafeStringLen( psz );
-		int nNewLength = GetLength();
+		int nNewLength = this->GetLength();
 		if( nInsertLength > 0 )
 		{
 			nNewLength += nInsertLength;
 
-			PXSTR pszBuffer = GetBuffer( nNewLength );
+			PXSTR pszBuffer = this->GetBuffer( nNewLength );
 			// move existing bytes down
 			Checked::memmove_s( pszBuffer+iIndex+nInsertLength, (nNewLength-iIndex-nInsertLength+1)*sizeof( XCHAR ),
 				pszBuffer+iIndex, (nNewLength-iIndex-nInsertLength+1)*sizeof( XCHAR ) );
 			Checked::memcpy_s( pszBuffer+iIndex, nInsertLength*sizeof( XCHAR ),
 				psz, nInsertLength*sizeof( XCHAR ) );
-			ReleaseBufferSetLength( nNewLength );
+			this->ReleaseBufferSetLength( nNewLength );
 		}
 
 		return( nNewLength );
@@ -1484,9 +1484,9 @@ public:
 		{
 			// otherwise modify each character that matches in the string
 			bool bCopied = false;
-			PXSTR pszBuffer = const_cast< PXSTR >( GetString() );  // We don't actually write to pszBuffer until we've called GetBuffer().
+			PXSTR pszBuffer = const_cast< PXSTR >( this->GetString() );  // We don't actually write to pszBuffer until we've called GetBuffer().
 
-			int nLength = GetLength();
+			int nLength = this->GetLength();
 			int iChar = 0;
 			while( iChar < nLength )
 			{
@@ -1496,7 +1496,7 @@ public:
 					if( !bCopied )
 					{
 						bCopied = true;
-						pszBuffer = GetBuffer( nLength );
+						pszBuffer = this->GetBuffer( nLength );
 					}
 					pszBuffer[iChar] = chNew;
 					nCount++;
@@ -1505,7 +1505,7 @@ public:
 			}
 			if( bCopied )
 			{
-				ReleaseBufferSetLength( nLength );
+				this->ReleaseBufferSetLength( nLength );
 			}
 		}
 
@@ -1529,8 +1529,8 @@ public:
 		// loop once to figure out the size of the result string
 		int nCount = 0;
 		{
-			PCXSTR pszStart = GetString();
-			PCXSTR pszEnd = pszStart+GetLength();
+			PCXSTR pszStart = this->GetString();
+			PCXSTR pszEnd = pszStart+this->GetLength();
 			while( pszStart < pszEnd )
 			{
 				PCXSTR pszTarget;
@@ -1548,10 +1548,10 @@ public:
 		{
 			// if the buffer is too small, just
 			//   allocate a new buffer (slow but sure)
-			int nOldLength = GetLength();
+			int nOldLength = this->GetLength();
 			int nNewLength = nOldLength+(nReplacementLen-nSourceLen)*nCount;
 
-			PXSTR pszBuffer = GetBuffer( __max( nNewLength, nOldLength ) );
+			PXSTR pszBuffer = this->GetBuffer( __max( nNewLength, nOldLength ) );
 
 			PXSTR pszStart = pszBuffer;
 			PXSTR pszEnd = pszStart+nOldLength;
@@ -1574,7 +1574,7 @@ public:
 				pszStart += StringTraits::SafeStringLen( pszStart )+1;
 			}
 			ATLASSERT( pszBuffer[nNewLength] == 0 );
-			ReleaseBufferSetLength( nNewLength );
+			this->ReleaseBufferSetLength( nNewLength );
 		}
 
 		return( nCount );
@@ -1583,8 +1583,8 @@ public:
 	// Remove all occurrences of character 'chRemove'
 	int Remove(_In_ XCHAR chRemove)
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 
 		PXSTR pszSource = pszBuffer;
 		PXSTR pszDest = pszBuffer;
@@ -1611,7 +1611,7 @@ public:
 		}
 		*pszDest = 0;
 		int nCount = int( pszSource-pszDest );
-		ReleaseBufferSetLength( nLength-nCount );
+		this->ReleaseBufferSetLength( nLength-nCount );
 
 		return( nCount );
 	}
@@ -1627,15 +1627,15 @@ public:
 
 		if( (pszTokens == NULL) || (*pszTokens == (XCHAR)0) )
 		{
-			if (iStart < GetLength())
+			if (iStart < this->GetLength())
 			{
-				return( CStringT( GetString()+iStart, GetManager() ) );
+				return( CStringT( this->GetString()+iStart, GetManager() ) );
 			}
 		}
 		else
 		{
-			PCXSTR pszPlace = GetString()+iStart;
-			PCXSTR pszEnd = GetString()+GetLength();
+			PCXSTR pszPlace = this->GetString()+iStart;
+			PCXSTR pszEnd = this->GetString()+this->GetLength();
 			if( pszPlace < pszEnd )
 			{
 				int nIncluding = StringTraits::StringSpanIncluding( pszPlace,
@@ -1672,17 +1672,17 @@ public:
 		ATLASSERT( iStart >= 0 );
 
 		// nLength is in XCHARs
-		int nLength = GetLength();
+		int nLength = this->GetLength();
 		if( iStart < 0 || iStart >= nLength)
 		{
 			return( -1 );
 		}
 
 		// find first single character
-		PCXSTR psz = StringTraits::StringFindChar( GetString()+iStart, ch );
+		PCXSTR psz = StringTraits::StringFindChar( this->GetString()+iStart, ch );
 
 		// return -1 if not found and index otherwise
-		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
+		return( (psz == NULL) ? -1 : int( psz-this->GetString() ) );
 	}
 
 	// look for a specific sub-string
@@ -1701,35 +1701,35 @@ public:
 			return( -1 );
 		}
 		// nLength is in XCHARs
-		int nLength = GetLength();
+		int nLength = this->GetLength();
 		if( iStart < 0 || iStart > nLength )
 		{
 			return( -1 );
 		}
 
 		// find first matching substring
-		PCXSTR psz = StringTraits::StringFindString( GetString()+iStart, pszSub );
+		PCXSTR psz = StringTraits::StringFindString( this->GetString()+iStart, pszSub );
 
 		// return -1 for not found, distance from beginning otherwise
-		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
+		return( (psz == NULL) ? -1 : int( psz-this->GetString() ) );
 	}
 
 	// Find the first occurrence of any of the characters in string 'pszCharSet'
 	int FindOneOf(_In_z_ PCXSTR pszCharSet) const throw()
 	{
 		ATLASSERT( AtlIsValidString( pszCharSet ) );
-		PCXSTR psz = StringTraits::StringScanSet( GetString(), pszCharSet );
-		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
+		PCXSTR psz = StringTraits::StringScanSet( this->GetString(), pszCharSet );
+		return( (psz == NULL) ? -1 : int( psz-this->GetString() ) );
 	}
 
 	// Find the last occurrence of character 'ch'
 	int ReverseFind(_In_ XCHAR ch) const throw()
 	{
 		// find last single character
-		PCXSTR psz = StringTraits::StringFindCharRev( GetString(), ch );
+		PCXSTR psz = StringTraits::StringFindCharRev( this->GetString(), ch );
 
 		// return -1 if not found, distance from beginning otherwise
-		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
+		return( (psz == NULL) ? -1 : int( psz-this->GetString() ) );
 	}
 
 	// manipulation
@@ -1737,10 +1737,10 @@ public:
 	// Convert the string to uppercase
 	CStringT& MakeUpper()
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::StringUppercase( pszBuffer, nLength+1 );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 
 		return( *this );
 	}
@@ -1748,10 +1748,10 @@ public:
 	// Convert the string to lowercase
 	CStringT& MakeLower()
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::StringLowercase( pszBuffer, nLength+1 );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 
 		return( *this );
 	}
@@ -1759,10 +1759,10 @@ public:
 	// Reverse the string
 	CStringT& MakeReverse()
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::StringReverse( pszBuffer );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 
 		return( *this );
 	}
@@ -1775,7 +1775,7 @@ public:
 		// find beginning of trailing spaces by starting
 		// at beginning (DBCS aware)
 
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 		PCXSTR pszLast = NULL;
 
 		while( *psz != 0 )
@@ -1795,9 +1795,9 @@ public:
 		if( pszLast != NULL )
 		{
 			// truncate at trailing space start
-			int iLast = int( pszLast-GetString() );
+			int iLast = int( pszLast-this->GetString() );
 
-			Truncate( iLast );
+			this->Truncate( iLast );
 		}
 
 		return( *this );
@@ -1808,23 +1808,23 @@ public:
 	{
 		// find first non-space character
 
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 
 		while( StringTraits::IsSpace( *psz ) )
 		{
 			psz = StringTraits::CharNext( psz );
 		}
 
-		if( psz != GetString() )
+		if( psz != this->GetString() )
 		{
 			// fix up data and length
-			int iFirst = int( psz-GetString() );
-			PXSTR pszBuffer = GetBuffer( GetLength() );
+			int iFirst = int( psz-this->GetString() );
+			PXSTR pszBuffer = this->GetBuffer( this->GetLength() );
 			psz = pszBuffer+iFirst;
-			int nDataLength = GetLength()-iFirst;
-			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
+			int nDataLength = this->GetLength()-iFirst;
+			Checked::memmove_s( pszBuffer, (this->GetLength()+1)*sizeof( XCHAR ),
 				psz, (nDataLength+1)*sizeof( XCHAR ) );
-			ReleaseBufferSetLength( nDataLength );
+			this->ReleaseBufferSetLength( nDataLength );
 		}
 
 		return( *this );
@@ -1856,7 +1856,7 @@ public:
 		// find beginning of trailing matches
 		// by starting at beginning (DBCS aware)
 
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 		PCXSTR pszLast = NULL;
 
 		while( *psz != 0 )
@@ -1878,8 +1878,8 @@ public:
 		if( pszLast != NULL )
 		{
 			// truncate at left-most matching character
-			int iLast = int( pszLast-GetString() );
-			Truncate( iLast );
+			int iLast = int( pszLast-this->GetString() );
+			this->Truncate( iLast );
 		}
 
 		return( *this );
@@ -1897,7 +1897,7 @@ public:
 		// find beginning of trailing matches
 		// by starting at beginning (DBCS aware)
 
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 		PCXSTR pszLast = NULL;
 
 		while( *psz != 0 )
@@ -1919,8 +1919,8 @@ public:
 		if( pszLast != NULL )
 		{
 			// truncate at left-most matching character
-			int iLast = int( pszLast-GetString() );
-			Truncate( iLast );
+			int iLast = int( pszLast-this->GetString() );
+			this->Truncate( iLast );
 		}
 
 		return( *this );
@@ -1930,23 +1930,23 @@ public:
 	CStringT& TrimLeft(_In_ XCHAR chTarget)
 	{
 		// find first non-matching character
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 
 		while( chTarget == *psz )
 		{
 			psz = StringTraits::CharNext( psz );
 		}
 
-		if( psz != GetString() )
+		if( psz != this->GetString() )
 		{
 			// fix up data and length
-			int iFirst = int( psz-GetString() );
-			PXSTR pszBuffer = GetBuffer( GetLength() );
+			int iFirst = int( psz-this->GetString() );
+			PXSTR pszBuffer = this->GetBuffer( this->GetLength() );
 			psz = pszBuffer+iFirst;
-			int nDataLength = GetLength()-iFirst;
-			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
+			int nDataLength = this->GetLength()-iFirst;
+			Checked::memmove_s( pszBuffer, (this->GetLength()+1)*sizeof( XCHAR ),
 				psz, (nDataLength+1)*sizeof( XCHAR ) );
-			ReleaseBufferSetLength( nDataLength );
+			this->ReleaseBufferSetLength( nDataLength );
 		}
 
 		return( *this );
@@ -1961,22 +1961,22 @@ public:
 			return( *this );
 		}
 
-		PCXSTR psz = GetString();
+		PCXSTR psz = this->GetString();
 		while( (*psz != 0) && (StringTraits::StringFindChar( pszTargets, *psz ) != NULL) )
 		{
 			psz = StringTraits::CharNext( psz );
 		}
 
-		if( psz != GetString() )
+		if( psz != this->GetString() )
 		{
 			// fix up data and length
-			int iFirst = int( psz-GetString() );
-			PXSTR pszBuffer = GetBuffer( GetLength() );
+			int iFirst = int( psz-this->GetString() );
+			PXSTR pszBuffer = this->GetBuffer( this->GetLength() );
 			psz = pszBuffer+iFirst;
-			int nDataLength = GetLength()-iFirst;
-			Checked::memmove_s( pszBuffer, (GetLength()+1)*sizeof( XCHAR ),
+			int nDataLength = this->GetLength()-iFirst;
+			Checked::memmove_s( pszBuffer, (this->GetLength()+1)*sizeof( XCHAR ),
 				psz, (nDataLength+1)*sizeof( XCHAR ) );
-			ReleaseBufferSetLength( nDataLength );
+			this->ReleaseBufferSetLength( nDataLength );
 		}
 
 		return( *this );
@@ -1985,20 +1985,20 @@ public:
 	// Convert the string to the OEM character set
 	void AnsiToOem()
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::ConvertToOem( pszBuffer, nLength+1 );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 	}
 
 	// Convert the string to the ANSI character set
 
 	void OemToAnsi()
 	{
-		int nLength = GetLength();
-		PXSTR pszBuffer = GetBuffer( nLength );
+		int nLength = this->GetLength();
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::ConvertToAnsi( pszBuffer, nLength+1 );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 	}
 
 	// Very simple sub-string extraction
@@ -2006,7 +2006,7 @@ public:
 	// Return the substring starting at index 'iFirst'
 	CStringT Mid(_In_ int iFirst) const
 	{
-		return( Mid( iFirst, GetLength()-iFirst ) );
+		return( Mid( iFirst, this->GetLength()-iFirst ) );
 	}
 
 	// Return the substring starting at index 'iFirst', with length 'nCount'
@@ -2022,24 +2022,24 @@ public:
 		if (nCount < 0)
 			nCount = 0;
 
-		if( (::ATL::AtlAddThrow(iFirst,nCount)) > GetLength() )
+		if( (::ATL::AtlAddThrow(iFirst,nCount)) > this->GetLength() )
 		{
-			nCount = GetLength()-iFirst;
+			nCount = this->GetLength()-iFirst;
 		}
-		if( iFirst > GetLength() )
+		if( iFirst > this->GetLength() )
 		{
 			nCount = 0;
 		}
 
-		ATLASSERT( (nCount == 0) || ((iFirst+nCount) <= GetLength()) );
+		ATLASSERT( (nCount == 0) || ((iFirst+nCount) <= this->GetLength()) );
 
 		// optimize case of returning entire string
-		if( (iFirst == 0) && ((iFirst+nCount) == GetLength()) )
+		if( (iFirst == 0) && ((iFirst+nCount) == this->GetLength()) )
 		{
 			return( *this );
 		}
 
-		return( CStringT( GetString()+iFirst, nCount, GetManager() ) );
+		return( CStringT( this->GetString()+iFirst, nCount, GetManager() ) );
 	}
 
 	// Return the substring consisting of the rightmost 'nCount' characters
@@ -2049,13 +2049,13 @@ public:
 		if (nCount < 0)
 			nCount = 0;
 
-		int nLength = GetLength();
+		int nLength = this->GetLength();
 		if( nCount >= nLength )
 		{
 			return( *this );
 		}
 
-		return( CStringT( GetString()+nLength-nCount, nCount, GetManager() ) );
+		return( CStringT( this->GetString()+nLength-nCount, nCount, GetManager() ) );
 	}
 
 	// Return the substring consisting of the leftmost 'nCount' characters
@@ -2065,13 +2065,13 @@ public:
 		if (nCount < 0)
 			nCount = 0;
 
-		int nLength = GetLength();
+		int nLength = this->GetLength();
 		if( nCount >= nLength )
 		{
 			return( *this );
 		}
 
-		return( CStringT( GetString(), nCount, GetManager() ) );
+		return( CStringT( this->GetString(), nCount, GetManager() ) );
 	}
 
 	// Return the substring consisting of the leftmost characters in the set 'pszCharSet'
@@ -2081,7 +2081,7 @@ public:
 		if(pszCharSet == NULL)
 			AtlThrow(E_INVALIDARG);
 
-		return( Left( StringTraits::StringSpanIncluding( GetString(), pszCharSet ) ) );
+		return( Left( StringTraits::StringSpanIncluding( this->GetString(), pszCharSet ) ) );
 	}
 
 	// Return the substring consisting of the leftmost characters not in the set 'pszCharSet'
@@ -2091,7 +2091,7 @@ public:
 		if(pszCharSet == NULL)
 			AtlThrow(E_INVALIDARG);
 
-		return( Left( StringTraits::StringSpanExcluding( GetString(), pszCharSet ) ) );
+		return( Left( StringTraits::StringSpanExcluding( this->GetString(), pszCharSet ) ) );
  	}
 
 	// Format data using format string 'pszFormat'
@@ -2114,16 +2114,16 @@ public:
 		if(pszFormat == NULL)
 			AtlThrow(E_INVALIDARG);
 
-		int nCurrentLength = GetLength();
+		int nCurrentLength = this->GetLength();
 		int nAppendLength = StringTraits::GetFormattedLength( pszFormat, args );
 
 		if (nAppendLength < 0)
 			AtlThrow(E_FAIL);
 
-		PXSTR pszBuffer = GetBuffer( nCurrentLength+nAppendLength );
+		PXSTR pszBuffer = this->GetBuffer( nCurrentLength+nAppendLength );
 		StringTraits::Format( pszBuffer+nCurrentLength,
 			nAppendLength+1, pszFormat, args );
-		ReleaseBufferSetLength( nCurrentLength+nAppendLength );
+		this->ReleaseBufferSetLength( nCurrentLength+nAppendLength );
 	}
 
 	void FormatV(
@@ -2139,9 +2139,9 @@ public:
 		if (nLength < 0)
 			AtlThrow(E_FAIL);
 
-		PXSTR pszBuffer = GetBuffer( nLength );
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::Format( pszBuffer, nLength+1, pszFormat, args );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 	}
 
 	// Format a message using format string 'pszFormat'
@@ -2178,7 +2178,7 @@ public:
 
 		if( ::GetLastError() != 0 )
 		{
-			ThrowMemoryException();
+			this->ThrowMemoryException();
 		}
 		::SetLastError(dwLastError);
 
@@ -2190,11 +2190,11 @@ public:
 	// Allocate a BSTR containing a copy of the string
 	_Ret_opt_z_ BSTR AllocSysString() const
 	{
-		BSTR bstrResult = StringTraits::AllocSysString( GetString(), GetLength() );
+		BSTR bstrResult = StringTraits::AllocSysString( this->GetString(), this->GetLength() );
 
 		if( bstrResult == NULL )
 		{
-			ThrowMemoryException();
+			this->ThrowMemoryException();
 		}
 		return( bstrResult );
 	}
@@ -2203,10 +2203,10 @@ public:
 	{
 		ATLASSERT( AtlIsValidAddress( pbstr, sizeof( BSTR ) ) );
 
-		if( !StringTraits::ReAllocSysString( GetString(), pbstr,
-			GetLength() ) )
+		if( !StringTraits::ReAllocSysString( this->GetString(), pbstr,
+			this->GetLength() ) )
 		{
-			ThrowMemoryException();
+			this->ThrowMemoryException();
 		}
 
 		ATLASSERT( *pbstr != NULL );
@@ -2222,13 +2222,13 @@ public:
 
 		if( nLength == 0 )
 		{
-			Empty();
+			this->Empty();
 		}
 		else
 		{
-			PXSTR pszBuffer = GetBuffer( nLength );
+			PXSTR pszBuffer = this->GetBuffer( nLength );
 			StringTraits::GetEnvironmentVariable( pszVar, pszBuffer, nLength );
-			ReleaseBuffer();
+			this->ReleaseBuffer();
 			bRetVal = TRUE;
 		}
 
@@ -2259,9 +2259,9 @@ public:
 		}
 
 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
-		PXSTR pszBuffer = GetBuffer( nLength );
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 
 		return( TRUE );
 	}
@@ -2279,9 +2279,9 @@ public:
 		}
 
 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
-		PXSTR pszBuffer = GetBuffer( nLength );
+		PXSTR pszBuffer = this->GetBuffer( nLength );
 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
-		ReleaseBufferSetLength( nLength );
+		this->ReleaseBufferSetLength( nLength );
 
 		return( TRUE );
 	}
@@ -2292,7 +2292,7 @@ public:
 	{
 		CStringT strResult( str1.GetManager() );
 
-		Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );
+		CStringT::Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );
 
 		return( strResult );
 	}
@@ -2303,7 +2303,7 @@ public:
 	{
 		CStringT strResult( str1.GetManager() );
 
-		Concatenate( strResult, str1, str1.GetLength(), psz2, StringLength( psz2 ) );
+		CStringT::Concatenate( strResult, str1, str1.GetLength(), psz2, CThisSimpleString::StringLength( psz2 ) );
 
 		return( strResult );
 	}
@@ -2314,7 +2314,7 @@ public:
 	{
 		CStringT strResult( str2.GetManager() );
 
-		Concatenate( strResult, psz1, StringLength( psz1 ), str2, str2.GetLength() );
+		CStringT::Concatenate( strResult, psz1, CThisSimpleString::StringLength( psz1 ), str2, str2.GetLength() );
 
 		return( strResult );
 	}
@@ -2399,7 +2399,7 @@ public:
 #ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
 	friend bool operator==(
 		_In_ const CStringT& str1,
-		_In_z_ PCYSTR psz2) throw( ... )
+		_In_z_ PCYSTR psz2) noexcept(false)
 	{
 		CStringT str2( psz2, str1.GetManager() );
 
@@ -2408,7 +2408,7 @@ public:
 
 	friend bool operator==(
 		_In_z_ PCYSTR psz1,
-		_In_ const CStringT& str2) throw( ... )
+		_In_ const CStringT& str2) noexcept(false)
 	{
 		CStringT str1( psz1, str2.GetManager() );
 
@@ -2440,7 +2440,7 @@ public:
 #ifndef _CSTRING_DISABLE_NARROW_WIDE_CONVERSION
 	friend bool operator!=(
 		_In_ const CStringT& str1,
-		_In_z_ PCYSTR psz2) throw( ... )
+		_In_z_ PCYSTR psz2) noexcept(false)
 	{
 		CStringT str2( psz2, str1.GetManager() );
 
@@ -2449,7 +2449,7 @@ public:
 
 	friend bool operator!=(
 		_In_z_ PCYSTR psz1,
-		_In_ const CStringT& str2) throw( ... )
+		_In_ const CStringT& str2) noexcept(false)
 	{
 		CStringT str1( psz1, str2.GetManager() );
 
@@ -2760,8 +2760,8 @@ public:
 			_Inout_ CStringData* pData,
 			_In_ int nChars,
 			_In_opt_ IAtlStringMgr* pMgr = NULL) throw() :
-		m_pData( pData ),
-		m_pMgr( pMgr )
+		m_pMgr( pMgr ),
+		m_pData( pData )
 	{
 		m_pData->nRefs = -1;
 		m_pData->nDataLength = 0;
@@ -2913,6 +2913,8 @@ class CFixedStringT :
 	public StringType
 {
 public:
+	typedef typename StringType::StrTraits StrTraits;
+
 	CFixedStringT() throw() :
 		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
 		StringType( static_cast< IAtlStringMgr* >( this ) )
@@ -2963,7 +2965,7 @@ public:
 
 	~CFixedStringT() throw()
 	{
-		Empty();
+		this->Empty();
 	}
 
 	CFixedStringT< StringType, t_nChars >& operator=(
@@ -3070,7 +3072,7 @@ public:
 	{
 		ATLENSURE( str != NULL );
 		ULONG nHash = 0;
-		const T::XCHAR* pch = str;
+		const typename T::XCHAR* pch = str;
 		while( *pch != 0 )
 		{
 			nHash = (nHash<<5)+nHash+(*pch);
diff --git a/include/statreg.h b/include/statreg.h
index 982e4fa..d2dd4ce 100644
--- a/include/statreg.h
+++ b/include/statreg.h
@@ -502,7 +502,8 @@ inline HRESULT CRegObject::RegisterFromResource(
 	}
 
 #ifdef _UNICODE
-	DWORD uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);
+	DWORD uniSize;
+	uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);
 	if (uniSize == 0)
 	{
 		hr = AtlHresultFromLastError();
