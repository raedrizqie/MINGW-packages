diff --git a/src/3rdparty/chromium/base/BUILD.gn b/src/3rdparty/chromium/base/BUILD.gn
index 57fd494..3f40725 100644
--- a/src/3rdparty/chromium/base/BUILD.gn
+++ b/src/3rdparty/chromium/base/BUILD.gn
@@ -108,7 +108,7 @@ if (is_fuchsia) {
   import("//third_party/fuchsia-gn-sdk/src/fidl_library.gni")
 }
 
-if (is_win) {
+if (is_msvc) {
   # This is in a separate config so the flags can be applied to dependents.
   # ldflags in GN aren't automatically inherited.
   config("base_win_linker_flags") {
@@ -126,6 +126,9 @@ if (is_win) {
       "/DELAYLOAD:shcore.dll",
     ]
   }
+} else if (is_mingw) {
+  config("base_win_linker_flags") {
+  }
 }
 
 if (is_android) {
@@ -1959,6 +1962,23 @@ jumbo_component("base") {
       "win/wrapped_window_proc.h",
     ]
 
+    if (is_mingw) {
+      sources -= [
+        "win/atl.h",                # requires <atlbase.h>
+        "win/atl_throw.cc",         # requires <atlbase.h>
+        "win/atl_throw.h",
+        "win/enum_variant.cc",      # requires <wrl/implements.h>
+        "win/enum_variant.h",
+        "win/vector.cc",            # requires <wrl/implements.h>
+        "win/vector.h",
+      ]
+
+      defines += [
+        "STRSAFE_NO_DEPRECATE",
+        "__STRSAFE__NO_INLINE",
+      ]
+    }
+
     # winternl.h and NTSecAPI.h have different definitions of UNICODE_STRING.
     # There's only one client of NTSecAPI.h in base but several of winternl.h,
     # so exclude the NTSecAPI.h one.
@@ -1974,17 +1994,17 @@ jumbo_component("base") {
     }
 
     libs += [
-      "cfgmgr32.lib",
-      "ntdll.lib",
-      "onecore.lib",
-      "pdh.lib",
-      "powrprof.lib",
-      "propsys.lib",
-      "setupapi.lib",
-      "shcore.lib",
-      "userenv.lib",
-      "wbemuuid.lib",
-      "winmm.lib",
+      "cfgmgr32",
+      "ntdll",
+      "onecore",
+      "pdh",
+      "powrprof",
+      "propsys",
+      "setupapi",
+      "shcore",
+      "userenv",
+      "wbemuuid",
+      "winmm",
     ]
     all_dependent_configs += [
       ":base_win_linker_flags",
@@ -2456,7 +2476,7 @@ jumbo_component("base") {
 
     all_dependent_configs += [ "//third_party/perfetto/gn:public_config" ]
 
-    if (is_win) {
+    if (is_msvc) {
       sources += [
         "trace_event/etw_interceptor_win.cc",
         "trace_event/etw_interceptor_win.h",
@@ -2954,14 +2974,18 @@ if (is_win) {
   # base/test/data/pe_image.
   shared_library("pe_image_test") {
     sources = [ "win/pe_image_test.cc" ]
-    ldflags = [
-      "/DELAYLOAD:cfgmgr32.dll",
-      "/DELAYLOAD:shell32.dll",
-      "/SUBSYSTEM:WINDOWS",
-    ]
+    if (is_mingw) {
+      ldflags = [ "-mwindows" ]
+    } else {
+      ldflags = [
+        "/DELAYLOAD:cfgmgr32.dll",
+        "/DELAYLOAD:shell32.dll",
+        "/SUBSYSTEM:WINDOWS",
+      ]
+    }
     libs = [
-      "cfgmgr32.lib",
-      "shell32.lib",
+      "cfgmgr32",
+      "shell32",
     ]
   }
 
diff --git a/src/3rdparty/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/win/windows_types.h b/src/3rdparty/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/win/windows_types.h
index 649a3b7..f17561d 100644
--- a/src/3rdparty/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/win/windows_types.h
+++ b/src/3rdparty/chromium/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_base/win/windows_types.h
@@ -80,12 +80,18 @@ struct PA_CHROME_SRWLOCK {
 
 // Define some macros needed when prototyping Windows functions.
 
+#ifndef DECLSPEC_IMPORT
 #define DECLSPEC_IMPORT __declspec(dllimport)
+#endif
 #define WINBASEAPI DECLSPEC_IMPORT
 #define WINAPI __stdcall
 
 // Needed for LockImpl.
+#ifdef _MSC_VER
 WINBASEAPI _Releases_exclusive_lock_(*SRWLock) VOID WINAPI
+#else
+VOID WINAPI
+#endif
     ReleaseSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
 WINBASEAPI BOOLEAN WINAPI TryAcquireSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
 
diff --git a/src/3rdparty/chromium/base/debug/handle_hooks_win.cc b/src/3rdparty/chromium/base/debug/handle_hooks_win.cc
index eb07225..6cb10f9 100644
--- a/src/3rdparty/chromium/base/debug/handle_hooks_win.cc
+++ b/src/3rdparty/chromium/base/debug/handle_hooks_win.cc
@@ -9,6 +9,8 @@
 #include <psapi.h>
 #include <stddef.h>
 
+#include <memory>
+
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
diff --git a/src/3rdparty/chromium/base/enterprise_util_win.cc b/src/3rdparty/chromium/base/enterprise_util_win.cc
index 1c0965f..39d6ad4 100644
--- a/src/3rdparty/chromium/base/enterprise_util_win.cc
+++ b/src/3rdparty/chromium/base/enterprise_util_win.cc
@@ -16,14 +16,22 @@ bool IsManagedDevice() {
   // they are managed.
   // In addition, simply being joined to AAD does not mean the device is being
   // managed by the AAD tenant, so checking for AAD join is not included here.
+#if defined(COMPILER_MSVC)
   return base::win::IsEnrolledToDomain() ||
          base::win::IsDeviceRegisteredWithManagement();
+#else
+  return base::win::IsEnrolledToDomain();
+#endif
 }
 
 bool IsEnterpriseDevice() {
   // Both legacy domain join and AAD join represent machine-wide enterprise
   // join.
+#if defined(COMPILER_MSVC)
   return base::win::IsEnrolledToDomain() || base::win::IsJoinedToAzureAD();
+#else
+  return base::win::IsEnrolledToDomain();
+#endif
 }
 
 }  // namespace base
diff --git a/src/3rdparty/chromium/base/export_template.h b/src/3rdparty/chromium/base/export_template.h
index 248d0d9..0914ffe 100644
--- a/src/3rdparty/chromium/base/export_template.h
+++ b/src/3rdparty/chromium/base/export_template.h
@@ -138,8 +138,10 @@
 
 EXPORT_TEMPLATE_TEST(DEFAULT, );
 EXPORT_TEMPLATE_TEST(DEFAULT, __attribute__((visibility("default"))));
+#if defined(_MSC_VER)
 EXPORT_TEMPLATE_TEST(EXPORT_DLLEXPORT, __declspec(dllexport));
 EXPORT_TEMPLATE_TEST(DEFAULT, __declspec(dllimport));
+#endif
 
 #undef EXPORT_TEMPLATE_TEST
 #undef EXPORT_TEMPLATE_TEST_DEFAULT_DEFAULT
diff --git a/src/3rdparty/chromium/base/lazy_instance.h b/src/3rdparty/chromium/base/lazy_instance.h
index 865bb4f..31331c4 100644
--- a/src/3rdparty/chromium/base/lazy_instance.h
+++ b/src/3rdparty/chromium/base/lazy_instance.h
@@ -173,7 +173,7 @@ class LazyInstance {
   // MSVC gives a warning that the alignment expands the size of the
   // LazyInstance struct to make the size a multiple of the alignment. This
   // is expected in this case.
-#if BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4324)
 #endif
@@ -186,7 +186,7 @@ class LazyInstance {
   // Preallocated space for the Type instance.
   alignas(Type) char private_buf_[sizeof(Type)];
 
-#if BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_MSVC)
 #pragma warning(pop)
 #endif
 
diff --git a/src/3rdparty/chromium/base/memory/aligned_memory.cc b/src/3rdparty/chromium/base/memory/aligned_memory.cc
index 86dd238..9f5ad09 100644
--- a/src/3rdparty/chromium/base/memory/aligned_memory.cc
+++ b/src/3rdparty/chromium/base/memory/aligned_memory.cc
@@ -22,7 +22,7 @@ void* AlignedAlloc(size_t size, size_t alignment) {
   DCHECK(std::has_single_bit(alignment));
   DCHECK_EQ(alignment % sizeof(void*), 0U);
   void* ptr = nullptr;
-#if defined(COMPILER_MSVC)
+#if BUILDFLAG(IS_WIN)
   ptr = _aligned_malloc(size, alignment);
 #elif BUILDFLAG(IS_ANDROID)
   // Android technically supports posix_memalign(), but does not expose it in
diff --git a/src/3rdparty/chromium/base/memory/aligned_memory.h b/src/3rdparty/chromium/base/memory/aligned_memory.h
index 23bbf5c..5413284 100644
--- a/src/3rdparty/chromium/base/memory/aligned_memory.h
+++ b/src/3rdparty/chromium/base/memory/aligned_memory.h
@@ -18,7 +18,7 @@
 #include "base/containers/span.h"
 #include "build/build_config.h"
 
-#if defined(COMPILER_MSVC)
+#if BUILDFLAG(IS_WIN)
 #include <malloc.h>
 #else
 #include <stdlib.h>
@@ -72,7 +72,7 @@ BASE_EXPORT void* AlignedAlloc(size_t size, size_t alignment);
 
 // Deallocate memory allocated by `AlignedAlloc`.
 inline void AlignedFree(void* ptr) {
-#if defined(COMPILER_MSVC)
+#if BUILDFLAG(IS_WIN)
   _aligned_free(ptr);
 #else
   free(ptr);
diff --git a/src/3rdparty/chromium/base/power_monitor/speed_limit_observer_win.cc b/src/3rdparty/chromium/base/power_monitor/speed_limit_observer_win.cc
index 3cf82bc..9babc2a 100644
--- a/src/3rdparty/chromium/base/power_monitor/speed_limit_observer_win.cc
+++ b/src/3rdparty/chromium/base/power_monitor/speed_limit_observer_win.cc
@@ -24,7 +24,9 @@
 namespace {
 
 // From ntdef.f
+#ifndef NT_SUCCESS
 #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
+#endif
 
 // We poll for new speed-limit values once every second.
 constexpr base::TimeDelta kSampleInterval = base::Seconds(1);
diff --git a/src/3rdparty/chromium/base/process/memory_win.cc b/src/3rdparty/chromium/base/process/memory_win.cc
index 059324c..84edeba 100644
--- a/src/3rdparty/chromium/base/process/memory_win.cc
+++ b/src/3rdparty/chromium/base/process/memory_win.cc
@@ -38,9 +38,13 @@ void EnableTerminationOnHeapCorruption() {
 }
 
 void EnableTerminationOnOutOfMemory() {
+#if defined(COMPILER_GCC)
+  std::set_new_handler(nullptr);
+#else
   constexpr int kCallNewHandlerOnAllocationFailure = 1;
   _set_new_handler(&ReleaseReservationOrTerminate);
   _set_new_mode(kCallNewHandlerOnAllocationFailure);
+#endif
 }
 
 bool UncheckedMalloc(size_t size, void** result) {
diff --git a/src/3rdparty/chromium/base/strings/string_number_conversions_win.h b/src/3rdparty/chromium/base/strings/string_number_conversions_win.h
index dd28d17..f3c8dc8 100644
--- a/src/3rdparty/chromium/base/strings/string_number_conversions_win.h
+++ b/src/3rdparty/chromium/base/strings/string_number_conversions_win.h
@@ -5,6 +5,7 @@
 #ifndef BASE_STRINGS_STRING_NUMBER_CONVERSIONS_WIN_H_
 #define BASE_STRINGS_STRING_NUMBER_CONVERSIONS_WIN_H_
 
+#include <cstdint>
 #include <string>
 #include <string_view>
 
diff --git a/src/3rdparty/chromium/base/trace_event/trace_logging_minimal_win.h b/src/3rdparty/chromium/base/trace_event/trace_logging_minimal_win.h
index bf0f69e..4500f82 100644
--- a/src/3rdparty/chromium/base/trace_event/trace_logging_minimal_win.h
+++ b/src/3rdparty/chromium/base/trace_event/trace_logging_minimal_win.h
@@ -263,11 +263,6 @@ class BASE_EXPORT TlmProvider {
   template <class... FieldTys>
   struct DataDescCountSum;  // undefined
 
-  template <>
-  struct DataDescCountSum<> {
-    static constexpr uint8_t value = 0;
-  };
-
   template <class FieldTy1, class... FieldTyRest>
   struct DataDescCountSum<FieldTy1, FieldTyRest...> {
     static constexpr uint8_t value =
@@ -326,6 +321,11 @@ class BASE_EXPORT TlmProvider {
   char provider_metadata_[kMaxProviderMetadataSize] = {};
 };
 
+template <>
+struct TlmProvider::DataDescCountSum<> {
+  static constexpr uint8_t value = 0;
+};
+
 // Base class for field types.
 // It's expected that data (name, value) will outlive the TlmFieldBase object.
 class BASE_EXPORT TlmFieldBase {
diff --git a/src/3rdparty/chromium/base/win/com_init_balancer.h b/src/3rdparty/chromium/base/win/com_init_balancer.h
index 571f2d7..fd3f6ce 100644
--- a/src/3rdparty/chromium/base/win/com_init_balancer.h
+++ b/src/3rdparty/chromium/base/win/com_init_balancer.h
@@ -7,7 +7,9 @@
 
 #include <objidl.h>
 #include <winnt.h>
+#if defined(COMPILER_MSVC)
 #include <wrl/implements.h>
+#endif
 
 #include <optional>
 
@@ -28,9 +30,13 @@ namespace internal {
 // revoke the registered spy and allow for the successful uninitialization of
 // the COM library.
 class BASE_EXPORT ComInitBalancer
+#if defined(COMPILER_MSVC)
     : public Microsoft::WRL::RuntimeClass<
           Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>,
           IInitializeSpy> {
+#else
+    : public IInitializeSpy {
+#endif
  public:
   // Constructs a COM initialize balancer. |co_init| defines the apartment's
   // concurrency model used by the balancer.
@@ -39,7 +45,7 @@ class BASE_EXPORT ComInitBalancer
   ComInitBalancer(const ComInitBalancer&) = delete;
   ComInitBalancer& operator=(const ComInitBalancer&) = delete;
 
-  ~ComInitBalancer() override;
+  ~ComInitBalancer();
 
   // Disables balancer by revoking the registered spy and consequently
   // unblocking attempts to uninitialize the COM library.
@@ -50,12 +56,12 @@ class BASE_EXPORT ComInitBalancer
  private:
   // IInitializeSpy:
   IFACEMETHODIMP PreInitialize(DWORD apartment_type,
-                               DWORD reference_count) override;
+                               DWORD reference_count);
   IFACEMETHODIMP PostInitialize(HRESULT result,
                                 DWORD apartment_type,
-                                DWORD new_reference_count) override;
-  IFACEMETHODIMP PreUninitialize(DWORD reference_count) override;
-  IFACEMETHODIMP PostUninitialize(DWORD new_reference_count) override;
+                                DWORD new_reference_count);
+  IFACEMETHODIMP PreUninitialize(DWORD reference_count);
+  IFACEMETHODIMP PostUninitialize(DWORD new_reference_count);
 
   const DWORD co_init_;
 
diff --git a/src/3rdparty/chromium/base/win/core_winrt_util.h b/src/3rdparty/chromium/base/win/core_winrt_util.h
index 79124a8..e98edac 100644
--- a/src/3rdparty/chromium/base/win/core_winrt_util.h
+++ b/src/3rdparty/chromium/base/win/core_winrt_util.h
@@ -28,6 +28,7 @@ BASE_EXPORT HRESULT RoActivateInstance(HSTRING class_id,
 // Retrieves an activation factory for the type specified.
 template <typename InterfaceType, wchar_t const* runtime_class_id>
 HRESULT GetActivationFactory(InterfaceType** factory) {
+#if defined(COMPILER_MSVC)
   ScopedHString class_id_hstring = ScopedHString::Create(runtime_class_id);
   if (!class_id_hstring.is_valid()) {
     return E_FAIL;
@@ -35,6 +36,7 @@ HRESULT GetActivationFactory(InterfaceType** factory) {
 
   return base::win::RoGetActivationFactory(class_id_hstring.get(),
                                            IID_PPV_ARGS(factory));
+#endif
 }
 
 }  // namespace base::win
diff --git a/src/3rdparty/chromium/base/win/post_async_results.h b/src/3rdparty/chromium/base/win/post_async_results.h
index 70e132c..2f33d64 100644
--- a/src/3rdparty/chromium/base/win/post_async_results.h
+++ b/src/3rdparty/chromium/base/win/post_async_results.h
@@ -5,6 +5,8 @@
 #ifndef BASE_WIN_POST_ASYNC_RESULTS_H_
 #define BASE_WIN_POST_ASYNC_RESULTS_H_
 
+#ifdef _MSC_VER
+
 #include <unknwn.h>
 
 #include <windows.foundation.h>
@@ -350,4 +352,6 @@ HRESULT PostAsyncResults(
 }  // namespace win
 }  // namespace base
 
+#endif
+
 #endif  // BASE_WIN_POST_ASYNC_RESULTS_H_
diff --git a/src/3rdparty/chromium/base/win/propvarutil.h b/src/3rdparty/chromium/base/win/propvarutil.h
index 41f9659..69809ba 100644
--- a/src/3rdparty/chromium/base/win/propvarutil.h
+++ b/src/3rdparty/chromium/base/win/propvarutil.h
@@ -11,7 +11,11 @@
 #include "base/win/windows_undefines.inc"
 // clang-format on
 
+#if defined(COMPILER_MSVC)
 #include <propvarutil.h>
+#else
+#include_next <propvarutil.h>
+#endif
 
 // Undefine the poisonous defines
 #include "base/win/windows_undefines.inc"  // NOLINT(build/include)
diff --git a/src/3rdparty/chromium/base/win/scoped_com_initializer.cc b/src/3rdparty/chromium/base/win/scoped_com_initializer.cc
index 4c26c94..2effe1f 100644
--- a/src/3rdparty/chromium/base/win/scoped_com_initializer.cc
+++ b/src/3rdparty/chromium/base/win/scoped_com_initializer.cc
@@ -4,7 +4,9 @@
 
 #include "base/win/scoped_com_initializer.h"
 
+#if defined(COMPILER_MSVC)
 #include <wrl/implements.h>
+#endif
 
 #include <ostream>
 
@@ -48,6 +50,7 @@ DWORD ScopedCOMInitializer::GetCOMBalancerReferenceCountForTesting() const {
 void ScopedCOMInitializer::Initialize(COINIT init,
                                       Uninitialization uninitialization) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+#if defined(COMPILER_MSVC)
   // COINIT_DISABLE_OLE1DDE is always added based on:
   // https://docs.microsoft.com/en-us/windows/desktop/learnwin32/initializing-the-com-library
   if (uninitialization == Uninitialization::kBlockPremature) {
@@ -73,6 +76,7 @@ void ScopedCOMInitializer::Initialize(COINIT init,
       hr_ == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)) {
     base::win::OnResourceExhausted();
   }
+#endif
 }
 
 }  // namespace win
diff --git a/src/3rdparty/chromium/base/win/scoped_variant.cc b/src/3rdparty/chromium/base/win/scoped_variant.cc
index c4b2d06..801b427 100644
--- a/src/3rdparty/chromium/base/win/scoped_variant.cc
+++ b/src/3rdparty/chromium/base/win/scoped_variant.cc
@@ -107,10 +107,15 @@ VARIANT* ScopedVariant::Receive() {
 
 VARIANT ScopedVariant::Copy() const {
   VARIANT ret = {{{VT_EMPTY}}};
+#if defined(COMPILER_GCC) // FIXME: VariantCopy is implemented differently
+  ::VariantCopy(&ret, const_cast<VARIANT*>(&var_));
+#else
   ::VariantCopy(&ret, &var_);
+#endif
   return ret;
 }
 
+
 int ScopedVariant::Compare(const VARIANT& other, bool ignore_case) const {
   DCHECK(!V_ISARRAY(&var_))
       << "Comparison is not supported when |this| owns a SAFEARRAY";
@@ -179,7 +184,15 @@ int ScopedVariant::Compare(const VARIANT& other, bool ignore_case) const {
 
   // 5. Otherwise returns the lexicographical comparison of the values held by
   //    the two VARIANTS that share the same VARTYPE.
+#if defined(COMPILER_GCC) // FIXME: VariantCompare is not yet supported
+  PROPVARIANT var1;
+  PROPVARIANT var2;
+  VariantToPropVariant(&var_, &var1);
+  VariantToPropVariant(&other, &var2);
+  return PropVariantCompareEx(var1, var2, PVCU_DEFAULT, PVCHF_DEFAULT);
+#else
   return ::VariantCompare(var_, other);
+#endif
 }
 
 void ScopedVariant::Set(const wchar_t* str) {
@@ -291,7 +304,11 @@ void ScopedVariant::Set(SAFEARRAY* array) {
 
 void ScopedVariant::Set(const VARIANT& var) {
   DCHECK(!IsLeakableVarType(var_.vt)) << "leaking variant: " << var_.vt;
+#if defined(COMPILER_GCC) // FIXME: VariantCopy is implemented differently
+  if (FAILED(::VariantCopy(&var_, const_cast<VARIANT*>(&var)))) {
+#else
   if (FAILED(::VariantCopy(&var_, &var))) {
+#endif
     DLOG(ERROR) << "VariantCopy failed";
     var_.vt = VT_EMPTY;
   }
diff --git a/src/3rdparty/chromium/base/win/shlwapi.h b/src/3rdparty/chromium/base/win/shlwapi.h
index 2ca59ee..8ad4a59 100644
--- a/src/3rdparty/chromium/base/win/shlwapi.h
+++ b/src/3rdparty/chromium/base/win/shlwapi.h
@@ -11,7 +11,11 @@
 #include "base/win/windows_undefines.inc"
 // clang-format on
 
+#if defined(COMPILER_MSVC)
 #include <shlwapi.h>
+#else
+#include_next <shlwapi.h>
+#endif
 
 // Undefine the poisonous defines
 #include "base/win/windows_undefines.inc"  // NOLINT(build/include)
diff --git a/src/3rdparty/chromium/base/win/shortcut.cc b/src/3rdparty/chromium/base/win/shortcut.cc
index 967e130..aa4b19d 100644
--- a/src/3rdparty/chromium/base/win/shortcut.cc
+++ b/src/3rdparty/chromium/base/win/shortcut.cc
@@ -179,6 +179,7 @@ bool CreateOrUpdateShortcutLink(const FilePath& shortcut_path,
                                                 properties.app_id.c_str())) {
       return false;
     }
+#if !defined(COMPILER_GCC) // missing PKEY_AppUserModel_IsDualMode, PKEY_AppUserModel_ToastActivatorCLSID
     if (has_dual_mode && !SetBooleanValueForPropertyStore(
                              property_store.Get(), PKEY_AppUserModel_IsDualMode,
                              properties.dual_mode)) {
@@ -190,6 +191,7 @@ bool CreateOrUpdateShortcutLink(const FilePath& shortcut_path,
                                   properties.toast_activator_clsid)) {
       return false;
     }
+#endif
   }
 
   // Release the interfaces to the old shortcut to make sure it doesn't prevent
@@ -322,6 +324,7 @@ bool ResolveShortcutProperties(const FilePath& shortcut_path,
       }
     }
 
+#if !defined(COMPILER_GCC) // missing PKEY_AppUserModel_IsDualMode, PKEY_AppUserModel_ToastActivatorCLSID
     if (options & ShortcutProperties::PROPERTIES_DUAL_MODE) {
       ScopedPropVariant pv_dual_mode;
       if (property_store->GetValue(PKEY_AppUserModel_IsDualMode,
@@ -360,6 +363,7 @@ bool ResolveShortcutProperties(const FilePath& shortcut_path,
                        << pv_toast_activator_clsid.get().vt;
       }
     }
+#endif
   }
 
   return true;
diff --git a/src/3rdparty/chromium/base/win/sphelper.h b/src/3rdparty/chromium/base/win/sphelper.h
index 649dcb0..bc023d3 100644
--- a/src/3rdparty/chromium/base/win/sphelper.h
+++ b/src/3rdparty/chromium/base/win/sphelper.h
@@ -11,7 +11,11 @@
 #include "base/win/windows_undefines.inc"
 // clang-format on
 
+#if defined(COMPILER_MSVC)
 #include <sphelper.h>
+#else
+#include_next <sphelper.h>
+#endif
 
 // Undefine the poisonous defines
 #include "base/win/windows_undefines.inc"  // NOLINT(build/include)
diff --git a/src/3rdparty/chromium/base/win/variant_vector.h b/src/3rdparty/chromium/base/win/variant_vector.h
index 41ff85f..ed70a97 100644
--- a/src/3rdparty/chromium/base/win/variant_vector.h
+++ b/src/3rdparty/chromium/base/win/variant_vector.h
@@ -84,20 +84,6 @@ class BASE_EXPORT VariantVector final {
     vector_.push_back(std::move(scoped_variant));
   }
 
-  // Specialize VT_DATE because ScopedVariant has a separate SetDate method,
-  // this is because VT_R8 and VT_DATE share the same underlying type.
-  template <>
-  void Insert<VT_DATE>(
-      typename internal::VariantConverter<VT_DATE>::Type value) {
-    if (vartype_ == VT_EMPTY) {
-      vartype_ = VT_DATE;
-    }
-    AssertVartype<VT_DATE>();
-    ScopedVariant scoped_variant;
-    scoped_variant.SetDate(value);
-    vector_.push_back(std::move(scoped_variant));
-  }
-
   // Populates a VARIANT based on what is stored, transferring ownership
   // of managed contents.
   // This is only valid when the VariantVector is empty or has a single element.
@@ -140,6 +126,20 @@ class BASE_EXPORT VariantVector final {
   std::vector<ScopedVariant> vector_;
 };
 
+// Specialize VT_DATE because ScopedVariant has a separate SetDate method,
+// this is because VT_R8 and VT_DATE share the same underlying type.
+template <>
+void VariantVector::Insert<VT_DATE>(
+    typename internal::VariantConverter<VT_DATE>::Type value) {
+  if (vartype_ == VT_EMPTY) {
+    vartype_ = VT_DATE;
+  }
+  AssertVartype<VT_DATE>();
+  ScopedVariant scoped_variant;
+  scoped_variant.SetDate(value);
+  vector_.push_back(std::move(scoped_variant));
+}
+
 }  // namespace win
 }  // namespace base
 
diff --git a/src/3rdparty/chromium/base/win/vector.h b/src/3rdparty/chromium/base/win/vector.h
index 7ec11da..cd8d5c3 100644
--- a/src/3rdparty/chromium/base/win/vector.h
+++ b/src/3rdparty/chromium/base/win/vector.h
@@ -5,6 +5,7 @@
 #ifndef BASE_WIN_VECTOR_H_
 #define BASE_WIN_VECTOR_H_
 
+#if defined(COMPILER_MSVC)
 #include <ivectorchangedeventargs.h>
 #include <windows.foundation.collections.h>
 #include <wrl/implements.h>
@@ -410,4 +411,6 @@ class Vector
 }  // namespace win
 }  // namespace base
 
+#endif // COMPILER_MSVC
+
 #endif  // BASE_WIN_VECTOR_H_
diff --git a/src/3rdparty/chromium/base/win/win_util.cc b/src/3rdparty/chromium/base/win/win_util.cc
index 2e0d6cd..c2dd667 100644
--- a/src/3rdparty/chromium/base/win/win_util.cc
+++ b/src/3rdparty/chromium/base/win/win_util.cc
@@ -20,7 +20,9 @@
 #include <cfgmgr32.h>
 #include <inspectable.h>
 #include <lm.h>
+#if defined(COMPILER_MSVC)
 #include <mdmregistration.h>
+#endif
 #include <ntstatus.h>
 #include <powrprof.h>
 #include <propkey.h>
@@ -161,6 +163,7 @@ bool* GetDomainEnrollmentStateStorage() {
 }
 
 bool* GetRegisteredWithManagementStateStorage() {
+#if defined(COMPILER_MSVC)
   static bool state = [] {
     // Mitigate the issues caused by loading DLLs on a background thread
     // (http://crbug/973868).
@@ -189,10 +192,14 @@ bool* GetRegisteredWithManagementStateStorage() {
   }();
 
   return &state;
+#else
+  return nullptr;
+#endif
 }
 
 // TODO (crbug/1300219): return a DSREG_JOIN_TYPE* instead of bool*.
 bool* GetAzureADJoinStateStorage() {
+#if defined(COMPILER_MSVC)
   static bool state = [] {
     base::ElapsedTimer timer;
 
@@ -231,6 +238,9 @@ bool* GetAzureADJoinStateStorage() {
     return is_aad_joined;
   }();
   return &state;
+#else
+  return nullptr;
+#endif
 }
 
 NativeLibrary PinUser32Internal(NativeLibraryLoadError* error) {
@@ -373,6 +383,7 @@ bool IsWindows11TabletMode() {
 // Convertible(5), or Detachable(6).
 // https://learn.microsoft.com/en-us/windows-hardware/customize/desktop/unattend/microsoft-windows-deployment-deviceform
 bool& IsDeviceFormConvertible() {
+#if defined(COMPILER_MSVC)
   static bool is_convertible = [] {
     DWORD deviceForm = DEVICEFAMILYDEVICEFORM_UNKNOWN;
     using lpfnRtlGetDeviceFamilyInfo =
@@ -391,6 +402,7 @@ bool& IsDeviceFormConvertible() {
            (deviceForm == DEVICEFAMILYDEVICEFORM_DETACHABLE);
   }();
   return is_convertible;
+#endif
 }
 
 // Returns a reference to a cached boolean that is true if the device hardware
@@ -549,6 +561,7 @@ bool QueryDeviceConvertibility() {
 // it to always return UserInteractionMode_Touch which as per documentation
 // indicates tablet mode.
 bool IsWindows10TabletMode(HWND hwnd) {
+#if defined(COMPILER_MSVC)
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
@@ -573,6 +586,9 @@ bool IsWindows10TabletMode(HWND hwnd) {
   }
 
   return mode == ABI::Windows::UI::ViewManagement::UserInteractionMode_Touch;
+#else
+  return false;
+#endif
 }
 
 void IsDeviceSlateWithKeyboard(HWND hwnd,
@@ -743,7 +759,9 @@ void SetAbortBehaviorForCrashReporting() {
   // Disabling the _CALL_REPORTFAULT behavior is important since otherwise it
   // has the sideffect of clearing our exception filter, which means we
   // don't get any crash.
+#if defined(COMPILER_MSVC) || (defined(COMPILER_GCC) && defined(_UCRT))
   _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
+#endif
 
   // Set a SIGABRT handler for good measure. We will crash even if the default
   // is left in place, however this allows us to crash earlier. And it also
@@ -904,13 +922,17 @@ bool GetLoadedModulesSnapshot(HANDLE process, std::vector<HMODULE>* snapshot) {
 }
 
 void EnableFlicks(HWND hwnd) {
+#if defined(COMPILER_MSVC)
   ::RemoveProp(hwnd, MICROSOFT_TABLETPENSERVICE_PROPERTY);
+#endif
 }
 
 void DisableFlicks(HWND hwnd) {
+#if defined(COMPILER_MSVC)
   ::SetProp(hwnd, MICROSOFT_TABLETPENSERVICE_PROPERTY,
             reinterpret_cast<HANDLE>(TABLET_DISABLE_FLICKS |
                                      TABLET_DISABLE_FLICKFALLBACKKEYS));
+#endif
 }
 
 void EnableHighDPISupport() {
diff --git a/src/3rdparty/chromium/base/win/windows_types.h b/src/3rdparty/chromium/base/win/windows_types.h
index ad294c6..3603342 100644
--- a/src/3rdparty/chromium/base/win/windows_types.h
+++ b/src/3rdparty/chromium/base/win/windows_types.h
@@ -11,6 +11,8 @@
 // Needed for function prototypes.
 #include <sal.h>
 #include <specstrings.h>
+#include <share.h> // for _SH_DENYNO
+#include <stdint.h>
 
 #include "base/win/win_handle_types.h"
 
@@ -22,8 +24,8 @@ extern "C" {
 
 typedef unsigned long DWORD;  // NOLINT(runtime/int)
 typedef long LONG;            // NOLINT(runtime/int)
-typedef __int64 LONGLONG;
-typedef unsigned __int64 ULONGLONG;
+typedef int64_t LONGLONG;
+typedef uint64_t ULONGLONG;
 
 #define VOID void
 typedef char CHAR;
@@ -32,7 +34,7 @@ typedef long LONG;    // NOLINT(runtime/int)
 typedef int INT;
 typedef unsigned int UINT;
 typedef unsigned int* PUINT;
-typedef unsigned __int64 UINT64;
+typedef uint64_t UINT64;
 typedef void* LPVOID;
 typedef void* PVOID;
 typedef void* HANDLE;
@@ -45,11 +47,11 @@ typedef WORD UWORD;
 typedef WORD ATOM;
 
 #if defined(_WIN64)
-typedef __int64 INT_PTR, *PINT_PTR;
-typedef unsigned __int64 UINT_PTR, *PUINT_PTR;
+typedef int64_t INT_PTR, *PINT_PTR;
+typedef uint64_t UINT_PTR, *PUINT_PTR;
 
-typedef __int64 LONG_PTR, *PLONG_PTR;
-typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
+typedef int64_t LONG_PTR, *PLONG_PTR;
+typedef uint64_t ULONG_PTR, *PULONG_PTR;
 #else
 typedef __w64 int INT_PTR, *PINT_PTR;
 typedef __w64 unsigned int UINT_PTR, *PUINT_PTR;
@@ -215,11 +217,30 @@ struct CHROME_MSG {
 // Work around there being two slightly different definitions in the SDK.
 #define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
 #endif
+#ifndef TLS_OUT_OF_INDEXES
 #define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)
+#endif
 #define HTNOWHERE 0
 #define MAX_PATH 260
 #define CS_GLOBALCLASS 0x4000
 
+#ifndef _MSC_VER
+#undef ERROR_SUCCESS
+#undef ERROR_FILE_NOT_FOUND
+#undef ERROR_ACCESS_DENIED
+#undef ERROR_INVALID_HANDLE
+#undef ERROR_SHARING_VIOLATION
+#undef ERROR_LOCK_VIOLATION
+#undef ERROR_MORE_DATA
+#undef REG_BINARY
+#undef REG_NONE
+#undef READ_CONTROL
+#undef SYNCHRONIZE
+#undef HKEY_CLASSES_ROOT
+#undef HKEY_LOCAL_MACHINE
+#undef HKEY_CURRENT_USER
+#endif
+
 #define ERROR_SUCCESS 0L
 #define ERROR_FILE_NOT_FOUND 2L
 #define ERROR_ACCESS_DENIED 5L
@@ -235,8 +256,12 @@ struct CHROME_MSG {
 #define STATUS_PENDING ((DWORD   )0x00000103L)
 #endif  // STATUS_PENDING
 #define STILL_ACTIVE STATUS_PENDING
+#ifndef SUCCEEDED
 #define SUCCEEDED(hr) (((HRESULT)(hr)) >= 0)
+#endif
+#ifndef FAILED
 #define FAILED(hr) (((HRESULT)(hr)) < 0)
+#endif
 
 #define HKEY_CLASSES_ROOT (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
 #define HKEY_LOCAL_MACHINE (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
@@ -257,7 +282,9 @@ struct CHROME_MSG {
 
 #define STANDARD_RIGHTS_READ (READ_CONTROL)
 #define STANDARD_RIGHTS_WRITE (READ_CONTROL)
+#ifndef STANDARD_RIGHTS_ALL
 #define STANDARD_RIGHTS_ALL (0x001F0000L)
+#endif
 
 #define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                   KEY_QUERY_VALUE            |\
@@ -294,18 +321,28 @@ struct CHROME_MSG {
 
 // Define some macros needed when prototyping Windows functions.
 
+#ifndef DECLSPEC_IMPORT
 #define DECLSPEC_IMPORT __declspec(dllimport)
+#endif
 #define WINBASEAPI DECLSPEC_IMPORT
 #define WINUSERAPI DECLSPEC_IMPORT
 #define WINAPI __stdcall
+#ifndef APIENTRY
 #define APIENTRY WINAPI
+#endif
+#ifndef CALLBACK
 #define CALLBACK __stdcall
+#endif
 #define NTAPI __stdcall
 
 typedef INT_PTR(WINAPI* FARPROC)();
 
 // Needed for LockImpl.
+#ifdef _MSC_VER
 WINBASEAPI _Releases_exclusive_lock_(*SRWLock) VOID WINAPI
+#else
+VOID WINAPI
+#endif
     ReleaseSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
 WINBASEAPI BOOLEAN WINAPI TryAcquireSRWLockExclusive(_Inout_ PSRWLOCK SRWLock);
 
@@ -371,6 +408,29 @@ inline MSG* ChromeToWindowsType(CHROME_MSG* p) {
 // undefined everywhere. As windows.h is removed from more source files we may
 // be able to shorten this list.
 
+#ifndef _MSC_VER
+#undef CopyFile
+#undef CreateDirectory
+#undef CreateFile
+#undef CreateService
+#undef DeleteFile
+#undef DispatchMessage
+#undef DrawText
+#undef FindFirstFile
+#undef FindNextFile
+#undef GetClassName
+#undef GetCurrentDirectory
+#undef GetCurrentTime
+#undef GetFileAttributes
+#undef GetMessage
+#undef LoadIcon
+#undef PostMessage
+#undef ReplaceFile
+#undef SendMessage
+#undef SendMessageCallback
+#undef SetCurrentDirectory
+#endif
+
 #define CopyFile CopyFileW
 #define CreateDirectory CreateDirectoryW
 #define CreateFile CreateFileW
diff --git a/src/3rdparty/chromium/base/win/windows_version.cc b/src/3rdparty/chromium/base/win/windows_version.cc
index 42c07eb..5608c1f 100644
--- a/src/3rdparty/chromium/base/win/windows_version.cc
+++ b/src/3rdparty/chromium/base/win/windows_version.cc
@@ -23,7 +23,7 @@
 #include "base/win/registry.h"
 #include "build/build_config.h"
 
-#if !defined(__clang__) && _MSC_FULL_VER < 191125507
+#if !defined(__clang__) && defined(_MSC_VER) && _MSC_FULL_VER < 191125507
 #error VS 2017 Update 3.2 or higher is required
 #endif
 
diff --git a/src/3rdparty/chromium/base/win/wrapped_window_proc.h b/src/3rdparty/chromium/base/win/wrapped_window_proc.h
index 5cacecb..da200a2 100644
--- a/src/3rdparty/chromium/base/win/wrapped_window_proc.h
+++ b/src/3rdparty/chromium/base/win/wrapped_window_proc.h
@@ -13,6 +13,7 @@
 #include <windows.h>
 
 #include "base/base_export.h"
+#include "build/build_config.h"
 
 namespace base {
 namespace win {
