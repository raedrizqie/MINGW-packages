diff --git a/src/3rdparty/chromium/sandbox/win/BUILD.gn b/src/3rdparty/chromium/sandbox/win/BUILD.gn
index 5c47439..4a3da81 100644
--- a/src/3rdparty/chromium/sandbox/win/BUILD.gn
+++ b/src/3rdparty/chromium/sandbox/win/BUILD.gn
@@ -188,10 +188,17 @@ static_library("sandbox") {
     "//build/config/win:maybe_set_appcontainer_acls",
   ]
 
-  libs = [
-    "ntdll.lib",
-    "userenv.lib",
-  ]
+  if (is_msvc) {
+    libs = [
+      "ntdll.lib",
+      "userenv.lib",
+    ]
+  } else {
+    libs = [
+      "ntdll",
+      "userenv",
+    ]
+  }
 }
 
 test("sbox_integration_tests") {
diff --git a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
index 519b686..227b265 100644
--- a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
@@ -47,7 +47,7 @@ InterceptionAgent* InterceptionAgent::GetInterceptionAgent() {
 
     size_t array_bytes = g_interceptions->num_intercepted_dlls * sizeof(void*);
     s_singleton = reinterpret_cast<InterceptionAgent*>(
-        new (NT_ALLOC) char[array_bytes + sizeof(InterceptionAgent)]);
+        new char[array_bytes + sizeof(InterceptionAgent)]);
 
     bool success = s_singleton->Init(g_interceptions);
     if (!success) {
@@ -111,7 +111,7 @@ bool InterceptionAgent::OnDllLoad(const UNICODE_STRING* full_path,
   size_t buffer_bytes = offsetof(DllInterceptionData, thunks) +
                         dll_info->num_functions * sizeof(ThunkData);
   dlls_[i] = reinterpret_cast<DllInterceptionData*>(
-      new (NT_PAGE, base_address) char[buffer_bytes]);
+      new char[buffer_bytes]);
 
   DCHECK_NT(dlls_[i]);
   if (!dlls_[i])
diff --git a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
index 8df2c68..4844504 100644
--- a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
+++ b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
@@ -40,12 +40,14 @@ typedef NTSTATUS(WINAPI* NtOpenFileFunction)(OUT PHANDLE FileHandle,
 
 typedef NTSTATUS(WINAPI* NtCloseFunction)(IN HANDLE Handle);
 
+#ifdef _MSC_VER
 typedef struct _FILE_RENAME_INFORMATION {
   BOOLEAN ReplaceIfExists;
   HANDLE RootDirectory;
   ULONG FileNameLength;
   WCHAR FileName[1];
 } FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationFileFunction)(
     IN HANDLE FileHandle,
@@ -54,6 +56,7 @@ typedef NTSTATUS(WINAPI* NtSetInformationFileFunction)(
     IN ULONG Length,
     IN FILE_INFORMATION_CLASS FileInformationClass);
 
+#ifdef _MSC_VER
 typedef struct FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -61,11 +64,13 @@ typedef struct FILE_BASIC_INFORMATION {
   LARGE_INTEGER ChangeTime;
   ULONG FileAttributes;
 } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PFILE_BASIC_INFORMATION FileAttributes);
 
+#ifdef _MSC_VER
 typedef struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -75,6 +80,7 @@ typedef struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER EndOfFile;
   ULONG FileAttributes;
 } FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryFullAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
@@ -147,8 +153,10 @@ typedef NTSTATUS(WINAPI* NtOpenProcessFunction)(OUT PHANDLE ProcessHandle,
                                                     ObjectAttributes,
                                                 IN PCLIENT_ID ClientId);
 
+#ifdef _MSC_VER
 // Provide ThreadImpersonationToken which is not in THREADINFOCLASS.
 constexpr auto ThreadImpersonationToken = static_cast<THREADINFOCLASS>(5);
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN HANDLE ThreadHandle,
@@ -208,8 +216,10 @@ typedef NTSTATUS(WINAPI* NtOpenProcessTokenExFunction)(
 // -----------------------------------------------------------------------
 // Memory
 
+#ifdef _MSC_VER
 // Don't really need this structure right now.
 typedef PVOID PRTL_HEAP_PARAMETERS;
+#endif
 
 typedef PVOID(WINAPI* RtlCreateHeapFunction)(IN ULONG Flags,
                                              IN PVOID HeapBase OPTIONAL,
@@ -271,8 +281,10 @@ typedef NTSTATUS(WINAPI* NtProtectVirtualMemoryFunction)(
 // -----------------------------------------------------------------------
 // Objects
 
+#ifdef _MSC_VER
 // Add some field not in OBJECT_INFORMATION_CLASS.
 constexpr auto ObjectNameInformation = static_cast<OBJECT_INFORMATION_CLASS>(1);
+#endif
 
 typedef enum _POOL_TYPE {
   NonPagedPool,
@@ -284,6 +296,7 @@ typedef enum _POOL_TYPE {
   NonPagedPoolCacheAlignedMustS
 } POOL_TYPE;
 
+#ifdef _MSC_VER
 typedef struct _OBJECT_BASIC_INFORMATION {
   ULONG Attributes;
   ACCESS_MASK GrantedAccess;
@@ -326,6 +339,7 @@ typedef struct _OBJECT_TYPE_INFORMATION {
 typedef struct _OBJECT_NAME_INFORMATION {
   UNICODE_STRING ObjectName;
 } OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryObjectFunction)(
     IN HANDLE Handle,
diff --git a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
index 26158cc..ea4119c 100644
--- a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
@@ -19,6 +19,7 @@
 #include "base/compiler_specific.h"
 #include "base/containers/span.h"
 #include "base/win/pe_image.h"
+#include "build/build_config.h"
 #include "sandbox/win/src/internal_types.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/sandbox_factory.h"
@@ -326,7 +327,9 @@ NTSTATUS CopyData(void* destination, const void* source, size_t bytes) {
   __try {
     GetNtExports()->memcpy(destination, source, bytes);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
+#ifdef _MSC_VER
     ret = (NTSTATUS)GetExceptionCode();
+#endif
   }
   return ret;
 }
@@ -352,7 +355,7 @@ NTSTATUS CopyNameAndAttributes(
         break;
 
       size_t size = in_object->ObjectName->Length / sizeof(wchar_t);
-      out_name->reset(new (NT_ALLOC) wchar_t[size + 1]);
+      out_name->reset(new wchar_t[size + 1]);
       if (!*out_name)
         break;
 
@@ -369,7 +372,9 @@ NTSTATUS CopyNameAndAttributes(
       ret = STATUS_SUCCESS;
     } while (false);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
+#ifdef _MSC_VER
     ret = (NTSTATUS)GetExceptionCode();
+#endif
   }
 
   if (!NT_SUCCESS(ret) && *out_name)
@@ -475,7 +480,7 @@ UNICODE_STRING* AnsiToUnicode(const char* string) {
       ansi_string.MaximumLength * sizeof(wchar_t) + sizeof(UNICODE_STRING);
 
   UNICODE_STRING* out_string =
-      reinterpret_cast<UNICODE_STRING*>(new (NT_ALLOC) char[name_bytes]);
+      reinterpret_cast<UNICODE_STRING*>(new char[name_bytes]);
   if (!out_string)
     return nullptr;
 
@@ -558,7 +563,7 @@ UNICODE_STRING* GetBackingFilePath(PVOID address) {
 
   for (;;) {
     MEMORY_SECTION_NAME* section_name = reinterpret_cast<MEMORY_SECTION_NAME*>(
-        new (NT_ALLOC) char[buffer_bytes]);
+        new char[buffer_bytes]);
 
     if (!section_name)
       return nullptr;
@@ -611,7 +616,7 @@ UNICODE_STRING* ExtractModuleName(const UNICODE_STRING* module_path) {
   // Because module_path is a UNICODE_STRING, size_bytes will be small enough
   // to make the static_cast below safe.
   DCHECK_NT(UINT16_MAX > size_bytes);
-  char* str_buffer = new (NT_ALLOC) char[size_bytes + sizeof(UNICODE_STRING)];
+  char* str_buffer = new char[size_bytes + sizeof(UNICODE_STRING)];
   if (!str_buffer)
     return nullptr;
 
diff --git a/src/3rdparty/chromium/sandbox/win/src/target_process.cc b/src/3rdparty/chromium/sandbox/win/src/target_process.cc
index df0be21..4c963d8 100644
--- a/src/3rdparty/chromium/sandbox/win/src/target_process.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/target_process.cc
@@ -249,7 +249,7 @@ ResultCode TargetProcess::TransferVariable(const char* name,
   if (!module)
     return SBOX_ERROR_CANNOT_LOADLIBRARY_EXECUTABLE;
 
-  target_address = ::GetProcAddress(module, name);
+  target_address = reinterpret_cast<void*>(::GetProcAddress(module, name));
   ::FreeLibrary(module);
 
   if (!target_address)
diff --git a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
index 6ebaf2c..0ef44a9 100644
--- a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
@@ -98,8 +98,8 @@ std::optional<std::wstring> GetPathFromHandle(HANDLE handle) {
   OBJECT_NAME_INFORMATION* name =
       reinterpret_cast<OBJECT_NAME_INFORMATION*>(buffer->data());
   return std::wstring(
-      name->ObjectName.Buffer,
-      name->ObjectName.Length / sizeof(name->ObjectName.Buffer[0]));
+      name->Name.Buffer,
+      name->Name.Length / sizeof(name->Name.Buffer[0]));
 }
 
 std::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
@@ -110,8 +110,8 @@ std::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
     return std::nullopt;
   OBJECT_TYPE_INFORMATION* name =
       reinterpret_cast<OBJECT_TYPE_INFORMATION*>(buffer->data());
-  return std::wstring(name->Name.Buffer,
-                      name->Name.Length / sizeof(name->Name.Buffer[0]));
+  return std::wstring(name->TypeName.Buffer,
+                      name->TypeName.Length / sizeof(name->TypeName.Buffer[0]));
 }
 
 bool CopyToChildMemory(HANDLE child,
